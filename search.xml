<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>spring事务的传播机制</title>
    <url>/2021/02/16/spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>七个事务传播机制如下:<a id="more"></a></p>
<table>
<thead>
<tr>
<th>传播机制</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)</code></td>
<td>支持当前事务，如果没有事务会创建一个新的事务</td>
</tr>
<tr>
<td><code>SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS)</code></td>
<td>支持当前事务，如果没有事务的话以非事务方式执行</td>
</tr>
<tr>
<td><code>MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY)</code></td>
<td>支持当前事务，如果没有事务抛出异常</td>
</tr>
<tr>
<td><code>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)</code></td>
<td>表示当前方法必须运行在自己的事务中，创建一个新的事务并挂起当前事务</td>
</tr>
<tr>
<td><code>NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED)</code></td>
<td>以非事务方式执行，如果当前存在事务则将当前事务挂起</td>
</tr>
<tr>
<td><code>NEVER(TransactionDefinition.PROPAGATION_NEVER)</code></td>
<td>以非事务方式进行，如果存在事务则抛出异常</td>
</tr>
<tr>
<td><code>NESTED(TransactionDefinition.PROPAGATION_NESTED)</code></td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody>
</table>
<p>Spring的API设计很不错，基本上根据英文翻译就能知道作用:</p>
<p>Required:必须的。说明必须要有事物，没有就新建事物。</p>
<p>supports:支持。说明仅仅是支持事务，没有事务就非事务方式执行。</p>
<p>mandatory:强制的。说明一定要有事务，没有事务就抛出异常。</p>
<p>required_new:必须新建事物。如果当前存在事物就挂起。</p>
<p>not_supported:不支持事物，如果存在事物就挂起。</p>
<p>never:绝不有事务。如果存在事物就抛出异常.</p>
<p>nested:嵌套的，存在事务，则在嵌套事务中执行，不存在就创建新事务(不存在时，与REQUIRED类似)。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql查询太慢，我们如何进行性能优化？</title>
    <url>/2021/02/15/mysql%E6%9F%A5%E8%AF%A2%E5%A4%AA%E6%85%A2%EF%BC%8C%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<p>本篇内容相对简洁，核心内容在SQL优化经验总结，通过这篇mysql的性能优化，大家能够掌握如下内容：</p>
<ol>
<li>会使用和分析慢查询日志</li>
<li>会使用和分析profile</li>
<li>SQL优化经验总结<a id="more"></a></li>
</ol>
<h2 id="如何进行性能分析？"><a href="#如何进行性能分析？" class="headerlink" title="如何进行性能分析？"></a>如何进行性能分析？</h2><p>一般进行性能分析，分如下三步：</p>
<ol>
<li>首先需要使用 <strong>慢查询日志</strong>功能，去获取所有查询时间比较长的SQL语句</li>
<li>其次 <strong>查看执行计划</strong>查看有问题的SQL的执行计划 explain</li>
<li>最后可以使用 <strong>show profile</strong>查看有问题的SQL的性能使用情况</li>
</ol>
<h3 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h3><p>首先我们要使用慢查询日志，因为它收集了查询时间比较长的SQL语句，但使用之前必须开启慢查询日志，在配置文件my.cnf（一般为/etc/my.cnf）中的[mysqld] 增加如下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow_query_log=ON</span><br><span class="line">long_query_time=3</span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow-log.log</span><br></pre></td></tr></table></figure>
<p>增加这些参数之后，重启MySQL，可以进行查询慢查询日志是否开启。</p>
<p><img src="https://gitee.com/BigDataLiu/big-data-map/raw/master/2021-2-6/1612607647167-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.PNG" alt="img"></p>
<h3 id="分析慢查询日志的工具"><a href="#分析慢查询日志的工具" class="headerlink" title="分析慢查询日志的工具"></a>分析慢查询日志的工具</h3><p>分析慢查询日志的工具有很多，老刘分享几种工具，详细的用法大家自行查询。</p>
<ol>
<li>mysqldumpslow是MySQL自带的慢查询日志工具，我们可以使用mysqldumpslow工具搜索慢查询日志中的SQL语句。</li>
<li>percona-toolkit是一组高级命令行工具的集合，可以查看当前服务的摘要信息，磁盘检测，分析慢查询日志，查找重复索引，实现表同步等等.</li>
</ol>
<h3 id="explain查看有问题的SQL语句"><a href="#explain查看有问题的SQL语句" class="headerlink" title="explain查看有问题的SQL语句"></a>explain查看有问题的SQL语句</h3><p>当SQL查询速度比较慢的时候，我们可以用explain查看这个SQL语句的相关情况，<a href="https://juejin.cn/post/6923773896248262664#heading-8" target="_blank" rel="noopener">这部分内容已经在精通MySQL之索引篇讲过，大家可以去看看。</a></p>
<h3 id="show-profile查看有问题的SQL语句"><a href="#show-profile查看有问题的SQL语句" class="headerlink" title="show profile查看有问题的SQL语句"></a>show profile查看有问题的SQL语句</h3><p>Query Profiler是MySQL自带的一种query诊断分析工具，通过它可以分析出一条SQL语句的硬件性能瓶颈在什么地方。比如CPU，IO等，以及该SQL执行所耗费的时间等。不过该工具只有在MySQL 5.0.37以及以上版本中才有实现。默认的情况下，MYSQL的该功能没有打开，需要自己手动启动。</p>
<h2 id="SQL优化经验总结"><a href="#SQL优化经验总结" class="headerlink" title="SQL优化经验总结"></a>SQL优化经验总结</h2><ol>
<li><p>任何地方都尽量避免使用 select <em> from t，用具体的字段列表代替</em>，不要返回用不到的任何字段。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where和order by相关的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</p>
<p>例如： select * from t where num is null</p>
<p>我们可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select * from t where num=0。</p>
</li>
<li><p>索引字段上不要使用不等，索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</p>
<p>例如： select * from t where num=10 or num=20</p>
<p>我们可以这样查询：select <em> from t where num=10 union all select </em> from t where num=20</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>例如：select * from t where num/2=100</p>
<p>我们应该改为: select <em> from t where num=100</em>2</p>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>例如：select * from t where substring(name,1,3)=’abc’ – name以abc开头的id</p>
<p>我们应该改为: select * from t where name like ‘abc%’</p>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>很多时候用 exists 代替 in 是一个好的选择。例如：select num from a where num in(select num from b)</p>
<p>我们应该这样替换：select num from a where exists(select 1 from b where num=a.num)</p>
</li>
<li><p>数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</p>
</li>
<li><p>多表连接时，使用表别名关联字段</p>
</li>
<li><p>多表连接查询时，将表与表之间的关联条件写在WHERE左边关联，WHERE右边再写过滤最大的条件</p>
</li>
<li><p>FROM子句中包含多个表的情况下,将表数据最少的表放在最后，因为数据库的解析器是按照从右到左的顺序处理FROM子句中的表数据，FROM子句中写在最后的表将被最先处理</p>
</li>
<li><p>模糊查询 like，like ‘关键字%’会走索引,如果使用like ‘%关键字%’ 和’%关键字’将全文索引</p>
</li>
<li><p>单独使用Group By和Order by时，Group By和Order by的列尽可能要有索引，如果没有索引，执行过程中会产生临时表，如果Group By和Order by组合使用时如果条件列不一样，也会产生临时表降低效率。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java中常用的设计模式都有哪些？</title>
    <url>/2021/02/15/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>主要分为创建型、结构型、行为型三大类(23种)。<a id="more"></a></p>
<ul>
<li>创建型模式：工厂方法<strong>、</strong>抽象工厂<strong>、</strong>单例<strong>、</strong>建造者、原型</li>
<li>结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元</li>
<li>行为型模式：策略、模板方法、观察者、迭代子、责任链、命令、备忘录、状态、访问者、中介者、解释器</li>
</ul>
<h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3><p><strong>总原则</strong>：<strong>开闭原则</strong>。对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码。</p>
<p>一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。</p>
<p><strong>六大原则</strong>：</p>
<ol>
<li><strong>单一职责原则</strong>：不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责。不然的话，就应该把类拆分。</li>
<li><strong>里氏替换原则</strong>：面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。LSP（Liskov Substitution Principl e）是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<br>  里氏替换原则是对“开-闭”原则的补充，实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。里氏替换原则是对“开-闭”原则的补充，实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</li>
<li><strong>依赖倒转原则</strong>：这是开闭原则的基础。面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。</li>
<li><strong>接口隔离原则</strong>：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离接口，比使用单个接口（多个接口方法集合到一个）要好。</li>
<li><strong>迪米特法则</strong>（最少知道原则）：一个类对自己知道的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部，这样当被依赖的类变化时，才能最小的影响该类。<br>  最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们成出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们成出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</li>
<li><strong>合成复用原则</strong>：尽量首先使用合成/聚合的方式，而不是使用继承。</li>
</ol>
<h4 id="1-什么是单例模式？"><a href="#1-什么是单例模式？" class="headerlink" title="1.什么是单例模式？"></a>1.什么是单例模式？</h4><p>答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p>
<p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p>
<p>使用场景：IO 、数据库连接、Redis 连接等。</p>
<p>单例模式代码实现(饿汉模式)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        Singleton singleton2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果：true</p>
<p>可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？</p>
<p>单例延迟加载代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 单例模式-延迟加载版(懒汉模式)</span><br><span class="line">class SingletonLazy &#123;</span><br><span class="line">    private static SingletonLazy instance;</span><br><span class="line">    public static SingletonLazy getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为非线程安全的，单例模式如何支持多线程？</p>
<p>使用 synchronized 来保证，单例模式的线程安全代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SingletonLazy &#123;</span><br><span class="line">    private static SingletonLazy instance;</span><br><span class="line">    public static synchronized SingletonLazy getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-什么是简单工厂模式？"><a href="#2-什么是简单工厂模式？" class="headerlink" title="2.什么是简单工厂模式？"></a>2.什么是简单工厂模式？</h4><p>答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；</li>
<li>产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</li>
</ul>
<p>简单工厂<strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Mocca"</span>:</span><br><span class="line">                result = <span class="string">"摩卡"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Latte"</span>:</span><br><span class="line">                result = <span class="string">"拿铁"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="string">"其他"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-什么是抽象工厂模式？"><a href="#3-什么是抽象工厂模式？" class="headerlink" title="3.什么是抽象工厂模式？"></a>3.什么是抽象工厂模式？</h4><p>答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p>
<p>比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p>
<p>抽象工厂实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 抽象工厂</span></span><br><span class="line">       String result = (<span class="keyword">new</span> CoffeeFactory()).createProduct(<span class="string">"Latte"</span>);</span><br><span class="line">       System.out.println(result); <span class="comment">// output:拿铁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">createProduct</span><span class="params">(String product)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 啤酒工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Hans"</span>:</span><br><span class="line">               result = <span class="string">"汉斯"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Yanjing"</span>:</span><br><span class="line">               result = <span class="string">"燕京"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">"其他啤酒"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 咖啡工厂 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Mocca"</span>:</span><br><span class="line">               result = <span class="string">"摩卡"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Latte"</span>:</span><br><span class="line">               result = <span class="string">"拿铁"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">"其他咖啡"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-什么是观察者模式？"><a href="#4-什么是观察者模式？" class="headerlink" title="4.什么是观察者模式？"></a>4.什么是观察者模式？</h4><p>观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 <strong>优点</strong>：</p>
<ul>
<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；</li>
<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合；</li>
<li>观察者模式支持广播通信；</li>
<li>观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象；</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<p>观察者模式实现代码如下。</p>
<h5 id="1）定义观察者（消息接收方）"><a href="#1）定义观察者（消息接收方）" class="headerlink" title="1）定义观察者（消息接收方）"></a>1）定义观察者（消息接收方）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者（消息接收方）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的观察者（消息接收方）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcrereObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcrereObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2）定义被观察者（消息发送方）"><a href="#2）定义被观察者（消息发送方）" class="headerlink" title="2）定义被观察者（消息发送方）"></a>2）定义被观察者（消息发送方）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被观察者（消息发布方）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 通知订阅者更新消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体被观察者（消息发布方） </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅者列表（存储信息）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : list) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3）代码调用"><a href="#3）代码调用" class="headerlink" title="3）代码调用"></a>3）代码调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义发布者</span></span><br><span class="line">        ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">// 定义订阅者</span></span><br><span class="line">        ConcrereObserver concrereObserver = <span class="keyword">new</span> ConcrereObserver(<span class="string">"老王"</span>);</span><br><span class="line">        ConcrereObserver concrereObserver2 = <span class="keyword">new</span> ConcrereObserver(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        concreteSubject.attach(concrereObserver);</span><br><span class="line">        concreteSubject.attach(concrereObserver2);</span><br><span class="line">        <span class="comment">// 发布信息</span></span><br><span class="line">        concreteSubject.notify(<span class="string">"更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<blockquote>
<p>老王：更新了</p>
<p>Java：更新了</p>
</blockquote>
<h4 id="5-什么是装饰器模式？"><a href="#5-什么是装饰器模式？" class="headerlink" title="5.什么是装饰器模式？"></a>5.什么是装饰器模式？</h4><p>答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>装饰器模式的关键：装饰器中使用了被装饰的对象。</p>
<p>比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子……，这个执行过程就是装饰者模式，实现代码如下。</p>
<h5 id="1）定义顶层对象，定义行为"><a href="#1）定义顶层对象，定义行为" class="headerlink" title="1）定义顶层对象，定义行为"></a>1）定义顶层对象，定义行为</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2）定义装饰器超类"><a href="#2）定义装饰器超类" class="headerlink" title="2）定义装饰器超类"></a>2）定义装饰器超类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorBase</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    IPerson iPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorBase</span><span class="params">(IPerson iPerson)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iPerson = iPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iPerson.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3）定义具体装饰器"><a href="#3）定义具体装饰器" class="headerlink" title="3）定义具体装饰器"></a>3）定义具体装饰器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jacket</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jacket</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">"穿上夹克"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hat</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hat</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">"戴上帽子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4）定义具体对象"><a href="#4）定义具体对象" class="headerlink" title="4）定义具体对象"></a>4）定义具体对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"什么都没穿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5）装饰器模式调用"><a href="#5）装饰器模式调用" class="headerlink" title="5）装饰器模式调用"></a>5）装饰器模式调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LaoWang laoWang = <span class="keyword">new</span> LaoWang();</span><br><span class="line">        Jacket jacket = <span class="keyword">new</span> Jacket(laoWang);</span><br><span class="line">        Hat hat = <span class="keyword">new</span> Hat(jacket);</span><br><span class="line">        hat.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-什么是模板方法模式？"><a href="#6-什么是模板方法模式？" class="headerlink" title="6.什么是模板方法模式？"></a>6.什么是模板方法模式？</h4><p>答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；</li>
<li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。</li>
</ul>
<p>以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 → 关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加模板方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开冰箱门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关冰箱门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放香蕉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Refrigerator refrigerator = <span class="keyword">new</span> Banana();</span><br><span class="line">        refrigerator.open();</span><br><span class="line">        refrigerator.put();</span><br><span class="line">        refrigerator.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<blockquote>
<p>开冰箱门</p>
<p>放香蕉</p>
<p>关冰箱门</p>
</blockquote>
<h4 id="7-什么是代理模式？"><a href="#7-什么是代理模式？" class="headerlink" title="7.什么是代理模式？"></a>7.什么是代理模式？</h4><p>代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；</li>
<li>可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由于使用了代理模式，因此程序的性能没有直接调用性能高；</li>
<li>使用代理模式提高了代码的复杂度。</li>
</ul>
<p>举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。</p>
<p>代理模式实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义售票接口 </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义飞机场售票 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理售票平台 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyAirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AirTicket airTicket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyAirTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket = <span class="keyword">new</span> AirTicket();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理模式调用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAirTicket airTicket = <span class="keyword">new</span> ProxyAirTicket();</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-什么是策略模式？"><a href="#8-什么是策略模式？" class="headerlink" title="8.什么是策略模式？"></a>8.什么是策略模式？</h4><p>答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。</p>
<p><strong>优点</strong>：遵循了开闭原则，扩展性良好。</p>
<p><strong>缺点</strong>：随着策略的增加，对外暴露越来越多。</p>
<p>以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。 策略模式实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明旅行</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">going</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑自行车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义出行类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITrip trip;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trip</span><span class="params">(ITrip trip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip = trip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTrip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip.going();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trip trip = <span class="keyword">new</span> Trip(<span class="keyword">new</span> Bike());</span><br><span class="line">        trip.doTrip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行的结果：</p>
<blockquote>
<p>骑自行车</p>
</blockquote>
<h4 id="9-什么是适配器模式？"><a href="#9-什么是适配器模式？" class="headerlink" title="9.什么是适配器模式？"></a>9.什么是适配器模式？</h4><p>答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>可以让两个没有关联的类一起运行，起着中间转换的作用；</li>
<li>灵活性好，不会破坏原有的系统。</li>
</ul>
<p><strong>缺点</strong>：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。</p>
<p>以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，如下图所示：</p>
<p>适配器实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的充电线 MicroUSB</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeC 充电口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> <span class="keyword">implements</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TypeC 充电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterMicroUSB</span> <span class="keyword">implements</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdapterMicroUSB</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.charger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试调用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TypeC typeC = <span class="keyword">new</span> TypeC();</span><br><span class="line">        MicroUSB microUSB = <span class="keyword">new</span> AdapterMicroUSB(typeC);</span><br><span class="line">        microUSB.charger();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<blockquote>
<p>TypeC 充电</p>
</blockquote>
<h4 id="10-JDK-类库常用的设计模式有哪些？"><a href="#10-JDK-类库常用的设计模式有哪些？" class="headerlink" title="10.JDK 类库常用的设计模式有哪些？"></a>10.JDK 类库常用的设计模式有哪些？</h4><p>答：JDK 常用的设计模式如下：</p>
<h5 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h5><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</span><br></pre></td></tr></table></figure>
<p>加密类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"DESede"</span>);</span><br><span class="line">Cipher cipher =jCipher.getInstance(<span class="string">"DESede"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="2）适配器模式"><a href="#2）适配器模式" class="headerlink" title="2）适配器模式"></a>2）适配器模式</h5><p>把其他类适配为集合类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h5 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h5><p>如 JDK 本身的动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The dog is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The cat is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">// 取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前"</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(<span class="string">"调用后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK 动态代理调用</span></span><br><span class="line">    AnimalProxy proxy = <span class="keyword">new</span> AnimalProxy();</span><br><span class="line">    Animal dogProxy = (Animal) proxy.getInstance(<span class="keyword">new</span> Dog());</span><br><span class="line">    dogProxy.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4）单例模式"><a href="#4）单例模式" class="headerlink" title="4）单例模式"></a>4）单例模式</h5><p>全局只允许有一个实例，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime();</span><br></pre></td></tr></table></figure>
<h5 id="5）装饰器"><a href="#5）装饰器" class="headerlink" title="5）装饰器"></a>5）装饰器</h5><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.BufferedInputStream(InputStream);  </span><br><span class="line">java.io.DataInputStream(InputStream);  </span><br><span class="line">java.io.BufferedOutputStream(OutputStream);  </span><br><span class="line">java.util.zip.ZipOutputStream(OutputStream);  </span><br><span class="line">java.util.Collections.checkedList(List list, Class type) ;</span><br></pre></td></tr></table></figure>
<h5 id="6）模板方法模式"><a href="#6）模板方法模式" class="headerlink" title="6）模板方法模式"></a>6）模板方法模式</h5><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p>
<p>比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Person person = (Person)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age.compareTo(person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SortTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">5</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="number">15</span>);</span><br><span class="line">        Person[] persons = &#123;p1,p2,p3&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-IO-使用了什么设计模式？"><a href="#11-IO-使用了什么设计模式？" class="headerlink" title="11.IO 使用了什么设计模式？"></a>11.IO 使用了什么设计模式？</h4><p>答：IO 使用了<strong>适配器模式</strong>和<strong>装饰器模式</strong>。</p>
<ul>
<li><strong>适配器模式：</strong>由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li>
<li><strong>装饰器模式</strong>：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li>
</ul>
<h4 id="12-Spring-中都使用了哪些设计模式？"><a href="#12-Spring-中都使用了哪些设计模式？" class="headerlink" title="12.Spring 中都使用了哪些设计模式？"></a>12.Spring 中都使用了哪些设计模式？</h4><p>答：Spring 框架使用的设计模式如下。</p>
<ul>
<li><strong>代理模式：</strong>在 AOP 中有使用</li>
<li><strong>单例模式</strong>：bean 默认是单例模式</li>
<li><strong>模板方法模式：</strong>jdbcTemplate</li>
<li><strong>工厂模式：</strong>BeanFactory</li>
<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件</li>
<li><strong>适配器模式：</strong>Spring MVC 中也是用到了适配器模式适配 Controller</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java在new一个对象的过程中发生了什么？</title>
    <url>/2021/02/15/Java%E5%9C%A8new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大致过程如下：</strong><a id="more"></a></p>
<p>1，首先到常量池中找类的带路径全名，然后检查对应的字节码是否已执行类加载过程，如果没有先执行类加载过程(class.forname())。</p>
<p>2，类加载过程完成后，虚拟机会为对象分配内存。</p>
<p>分配内存有两种方式:</p>
<ol>
<li><strong>指针碰撞：</strong>假设堆内存是规整的，把用过的内存放一边，没用过得放另一边，中间做个标记指针分开，当需要分配内存的时候就把标记指针向没用过的一边移动相应的距离。</li>
<li><strong>空闲列表</strong>：假设堆内存是一个个的内存碎片，已使用的和未使用的相互交错，当需要分配内存的时候，从未使用的内存碎片中找一个足够大的空间划分给对象实例，并更新使用情况记录。</li>
</ol>
<p>要根据使用的垃圾收集器的不同使用不同的分配机制。</p>
<p>3，设置对象头信息，如所属类，元数据信息，哈希码，gc分代年龄，偏向锁等等。</p>
<p>4，调用对象的init()方法,根据传入的属性值给对象属性赋值。</p>
<p>5，在线程栈中新建对象引用，并指向堆中刚刚新建的对象实例。</p>
<p><strong>过程的详细说明：</strong></p>
<p>java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。</p>
<p>我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：<strong>加载并初始化类</strong>和<strong>创建对象。</strong></p>
<p><strong>一、类加载过程：</strong></p>
<p>　　java是使用<strong>双亲委派模型</strong>来进行类的加载的，所以在描述类加载过程前，我们先看一下它的工作过程：</p>
<blockquote>
<p>​    双亲委托模型的工作过程是：如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。<br>​    使用双亲委托机制的<strong>好处</strong>是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。</p>
</blockquote>
<p><strong>1、加载</strong></p>
<p>​    由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</p>
<p><strong>2、验证</strong></p>
<p>​    <strong>格式验证</strong>：验证是否符合class文件规范.<br>​    <strong>语义验证</strong>：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类                  和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）.<br>​    <strong>操作验证</strong>：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执            行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符            是否允许访问等）.</p>
<p><strong>3、准备</strong></p>
<p>​    为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内），被final修饰的static变量（常量），会直接赋值；</p>
<p><strong>4、解析</strong></p>
<p>​    将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。解析需要静态绑定的内容。  // 所有不会被重写的方法和域都会被静态绑定。</p>
<p>　　<strong>以上2、3、4三个阶段又合称为链接阶段</strong>，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。</p>
<p><strong>5、初始化（先父后子）</strong></p>
<p>​    5.1 为静态变量赋值</p>
<p>​    5.2 执行static代码块</p>
<blockquote>
<p><strong>注意：</strong>static代码块只有jvm能够调用<br>　　　如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</p>
</blockquote>
<p>因为子类存在对父类的依赖，所以<strong>类的加载顺序是先加载父类后加载子类，初始化也一样。</strong>不过，父类初始化时，子类静态变量的值也是有的，是默认值。</p>
<p>最终，方法区会存储当前类类信息，包括类的<strong>静态变量</strong>、<strong>类初始化代码</strong>（<strong>定义静态变量时的赋值语句</strong> 和 <strong>静态初始化代码块</strong>）、<strong>实例变量定义</strong>、<strong>实例初始化代码</strong>（<strong>定义实例变量时的赋值语句实例代码块</strong>和<strong>构造方法</strong>）和<strong>实例方法</strong>，还有<strong>父类的类信息引用。</strong></p>
<p><strong>二、创建对象</strong></p>
<p><strong>1、在堆区分配对象需要的内存</strong></p>
<p>　　分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p>
<p><strong>2、对所有实例变量赋默认值</strong></p>
<p>　　将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p>
<p><strong>3、执行实例初始化代码</strong></p>
<p>　　初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p>
<p><strong>4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</strong></p>
<p>需要注意的是，<strong>每个子类对象持有父类对象的引用</strong>，可在内部通过super关键字来调用父类对象，但在外部不可访问</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p>
<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为<strong>虚方法表</strong>的方法来优化调用的效率。</p>
<p>所谓<strong>虚方法表</strong>，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中List,Integer[],int[]的相互转换</title>
    <url>/2021/02/15/Java%E4%B8%ADList-Integer%5B%5D-int%5B%5D-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>学习过程中总是遇见List，Integer[],int[] 等之间的转换问题让人头疼，下面提供一些方法，希望能帮到您，如果你有更好的方法，欢迎评论区留言。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. int[] 转 List&lt;Integer&gt;       </span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.stream(data).boxed().collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Arrays.stream(arr) 可以替换成IntStream.of(arr)。      </span></span><br><span class="line">        <span class="comment">// 1.使用Arrays.stream将int[]转换成IntStream。       </span></span><br><span class="line">        <span class="comment">// 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream&lt;Integer&gt;。       </span></span><br><span class="line">        <span class="comment">// 3.使用Stream的collect()，将Stream&lt;T&gt;转换成List&lt;T&gt;，因此正是List&lt;Integer&gt;。        </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. int[] 转 Integer[]       </span></span><br><span class="line">        Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="comment">// 前两步同上，此时是Stream&lt;Integer&gt;。      </span></span><br><span class="line">            <span class="comment">// 然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator。       </span></span><br><span class="line">            <span class="comment">// 这样就可以返回Integer数组。      </span></span><br><span class="line">            <span class="comment">// 不然默认是Object[]。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. List&lt;Integer&gt; 转 Integer[]       </span></span><br><span class="line">        Integer[] integers2 = list1.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  调用toArray。传入参数T[] a。这种用法是目前推荐的。      </span></span><br><span class="line">        <span class="comment">// List&lt;String&gt;转String[]也同理。        </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. List&lt;Integer&gt; 转 int[]       </span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="comment">// 想要转换成int[]类型，就得先转成IntStream。      </span></span><br><span class="line">        <span class="comment">// 这里就通过mapToInt()把Stream&lt;Integer&gt;调用Integer::valueOf来转成IntStream         </span></span><br><span class="line">        <span class="comment">// 而IntStream中默认toArray()转成int[]。 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5. Integer[] 转 int[]       </span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="comment">// 思路同上。先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream。 </span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//6. Integer[] 转 List&lt;Integer&gt;       </span></span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(integers1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最简单的方式。String[]转List&lt;String&gt;也同理。        </span></span><br><span class="line">        <span class="comment">// 同理 String[] strings1 = &#123;"a", "b", "c"&#125;;      </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. String[] 转 List&lt;String&gt;       </span></span><br><span class="line">        List&lt;String&gt; list3 = Arrays.asList(strings1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. List&lt;String&gt; 转 String[]       </span></span><br><span class="line">        String[] strings2 = list3.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-注解</title>
    <url>/2020/12/21/Java%E5%9F%BA%E7%A1%80-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a><a id="more"></a>1.什么是注解</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>说明程序的，给计算机看的。</p>
<p><strong>什么是注释</strong>：用文字描述程序的，给程序员看的。</p>
<p><strong>百度上的解释：</strong></p>
<p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制，是一种代码级别的说明。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p>
<p><strong>概念描述：</strong></p>
<ul>
<li>JDK1.5 之后的新特性</li>
<li>用来说明程序的</li>
<li>使用注解：@注解名称</li>
</ul>
<h3 id="1-2-作用分类"><a href="#1-2-作用分类" class="headerlink" title="1.2 作用分类"></a>1.2 作用分类</h3><ol>
<li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li>
<li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】，API文档是通过抽取代码中的文档注释生成的。</li>
</ol>
<p>例如新建一个类：</p>
<p><img src="https://img-blog.csdnimg.cn/20200305141931761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6dV9zZXU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> 打开命令行窗口，用  <strong>javadoc AnnoDemo1.java</strong>  这个命令进行抽取，点开生成文件中的index.html：</p>
<p><img src="https://img-blog.csdnimg.cn/20200305143648431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6dV9zZXU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>\3. 代码分析：通过代码里标识的注解对代码进行分析【使用反射】</p>
<h2 id="2-JDK中预定义的一些注解"><a href="#2-JDK中预定义的一些注解" class="headerlink" title="2. JDK中预定义的一些注解"></a>2. JDK中预定义的一些注解</h2><p>@Override ： 检测被该注解标注的方法是否搜集继承自父类(接口)的</p>
<p>@Deprecated ：将该注解标注的内容，表示已过时</p>
<p>@SuppressWarnings ：压制警告，一般传递参数all @SuppressWarnings(“all”)</p>
<h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3. 自定义注解"></a>3. 自定义注解</h2><h3 id="3-1-格式"><a href="#3-1-格式" class="headerlink" title="3.1 格式"></a><strong>3.1 格式</strong></h3><p>​    元注解：   public  @interface 注解名称{}</p>
<h3 id="3-2-注解的本质"><a href="#3-2-注解的本质" class="headerlink" title="3.2 注解的本质"></a><strong>3.2 注解的本质</strong></h3><p><strong>注解本质上就是一个接口，该接口默认继承Annotation接口</strong></p>
<p>将以下注解编译过后进行反编译，得到结果：</p>
<p><strong>编译前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反编译后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-属性"><a href="#3-3-属性" class="headerlink" title="3.3 属性"></a><strong>3.3 属性</strong></h3><p>可以理解为接口中可以定义的抽象方法。</p>
<p><strong>要求：</strong> </p>
<p>1.属性的返回值类型只能为以下几种：</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
<p>2.定义了的属性（本质上是抽象方法），在使用时需要进行赋值</p>
<ul>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且这个属性的名称是value，那么value可以省略，直接赋值即可。</li>
<li>数组赋值时，值使用大括号包裹。如果数组中只有一个值，那么{}可以省略</li>
</ul>
<h3 id="3-4-元注解"><a href="#3-4-元注解" class="headerlink" title="3.4 元注解"></a>3.4 元注解</h3><p><strong>概念：用于描述注解的注解。</strong></p>
<p>@Target：描述能够作用的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;) <span class="comment">//表示该MyAnno注解只能作用于类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中value中ElementType取值可以有以下几种情况：</p>
<ul>
<li>TYPE:可以作用在类上</li>
<li>METHOD:可以作用在方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;) </span><br><span class="line"><span class="comment">//表示该MyAnno注解可以同时作用于类上，方法上和成员变量上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Retention：</strong>描述注解被保留的阶段</p>
<p>​    @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到字节码文件中，并被JVM读取到，一般自己定义的注解都加RUNTIME</p>
<p><strong>@Documented</strong>：描述该注解是否会被抽取到api文档中</p>
<p><strong>@Inherited：</strong>描述注解是否被子类继承</p>
<h3 id="4-在程序中使用注解"><a href="#4-在程序中使用注解" class="headerlink" title="4. 在程序中使用注解"></a>4. 在程序中使用注解</h3><p>注解在程序中经常和反射一起使用，注解大多数来说都是用来替换配置文件的，拿之前<a href="https://blog.csdn.net/zzu_seu/article/details/104627482" target="_blank" rel="noopener">反射</a>的程序来举例：</p>
<p><strong>被测试的类AnnoTest1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AnnoTest1 method play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原始的反射代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.reflect;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">         * 即：拒绝硬编码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//1.2.1获取class目录下的配置文件  使用类加载器</span></span><br><span class="line">        ClassLoader classLoader = ReflectTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"pro.properties"</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.获取配置文件中定义的数据</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对应的配置文件pro：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">className=cn.other.annotation.AnnoTest1</span><br><span class="line">methodName=play</span><br></pre></td></tr></table></figure>
<p><strong>新建注解AnnoReflect ：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">//可以被作用在类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoReflect &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>使用注解的方式来淘汰配置文件(注释很重要)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.annotation;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AnnoReflect</span>(className = <span class="string">"cn.other.annotation.AnnoTest1"</span>,methodName = <span class="string">"play"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectAnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 解析注解</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.1 获取该类的字节码文件对象</span></span><br><span class="line"></span><br><span class="line">        Class&lt;ReflectAnnotationTest&gt; rac = ReflectAnnotationTest.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.2 获取上面的注解对象,其实就是在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line">        AnnoReflect an = rac.getAnnotation(AnnoReflect.class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        相当于</span></span><br><span class="line"><span class="comment">        public class AnnotationReflect implements AnnoReflect&#123;</span></span><br><span class="line"><span class="comment">            public String className()&#123;</span></span><br><span class="line"><span class="comment">                return "cn.other.annotation.AnnoTest1";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            public String methodName()&#123;</span></span><br><span class="line"><span class="comment">                return "play";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">        String className = an.className();</span><br><span class="line">        String methodName = an.methodName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        </span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line"></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line"></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/20200306202943796.png" alt="img"></p>
<h3 id="使用总结："><a href="#使用总结：" class="headerlink" title="使用总结："></a>使用总结：</h3><p>在程序中使用注解：获取注解中定义的属性值</p>
<ol>
<li>获取注解定义的位置的对象  (Class, Method, Field)</li>
<li>获取指定的注解：getAnnotation(Class)</li>
<li>调用注解中的抽象方法获取配置的属性值</li>
</ol>
<h2 id="案例：简单的测试框架"><a href="#案例：简单的测试框架" class="headerlink" title="案例：简单的测试框架"></a>案例：简单的测试框架</h2><p>需求：设计一个框架，检测一个类中的方法使用有异常，并进行统计。</p>
<h3 id="待测试的类"><a href="#待测试的类" class="headerlink" title="待测试的类"></a><strong>待测试的类</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.annotation.demo;</span><br><span class="line"><span class="comment">/** 计算器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1+0="</span>+(<span class="number">1</span>+<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1-0="</span>+(<span class="number">1</span>-<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1*0="</span>+(<span class="number">1</span>*<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1/0="</span>+(<span class="number">1</span>/<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"今天天气真不错！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>首先自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//运行时</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">//加在方法前面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写一个类专门用于检查(注意注释)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.annotation.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 简单的测试框架</span></span><br><span class="line"><span class="comment"> * 当主方法执行后，会自动自行检测所有方法(加了check注解的方法)，判断方法是否有异常并记录*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 创建计算机对象</span></span><br><span class="line">        calculator c = <span class="keyword">new</span> calculator();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 获取字节码文件对象</span></span><br><span class="line">        Class cls = c.getClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 获取所有方法</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录出现异常的次数</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bug.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4. 判断方法上是否有Check注解</span></span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(Check.class))&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//5. 有注解就执行,捕获异常</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(c);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//6.将异常记录在文件中</span></span><br><span class="line">                    num++;</span><br><span class="line">                    bw.write(method.getName()+<span class="string">"方法出异常了"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常的名称是："</span>+e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常原因："</span>+e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"====================="</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">"本次测试一共出现"</span>+num+<span class="string">"次异常"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在待测试的类中每个需要测试的方法前面都加上@Check</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.other.annotation.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1+0="</span>+(<span class="number">1</span>+<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1-0="</span>+(<span class="number">1</span>-<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1*0="</span>+(<span class="number">1</span>*<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1/0="</span>+(<span class="number">1</span>/<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"今天天气真不错！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行TestCheck类中的主方法，就会自动检查所有注解@Check的方法是否异常：</p>
<p><img src="https://img-blog.csdnimg.cn/20200306214605527.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200306214630500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6dV9zZXU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="小结-："><a href="#小结-：" class="headerlink" title="小结 ："></a>小结 ：</h2><ul>
<li>大多数时候，我们会使用注解而不是自定义注解</li>
<li>注解给编译器和解析程序用</li>
<li>注解不是程序的一部分，可以理解为标签</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Web项目中解决中文乱码方法总结</title>
    <url>/2020/12/12/Java-Web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、了解常识："><a href="#一、了解常识：" class="headerlink" title="一、了解常识："></a><a id="more"></a>一、了解常识：</h2><p>1.UTF-8国际编码，GBK中文编码。GBK包含GB2312，即通过GB2312编码后可以通过GBK解码，反之可能不成立;</p>
<p>2、web tomcat:默认是ISO8859-1，不支持中文的</p>
<p>3.java.nio.charset.Charset.defaultCharset() 获得平台默认字符编码；</p>
<p>4.getBytes() 是通过平台默认字符集进行编码；</p>
<h2 id="二、引入"><a href="#二、引入" class="headerlink" title="二、引入"></a>二、引入</h2><p>在学习任何一门技术时，经常会有初学者遇到中文乱码问题，比如MySQL，是因为在安装时没有设置；而在Servlet中，也会遇到中文乱码问题；</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">out.write(String);</span><br></pre></td></tr></table></figure>
<p>输出中文时可能会出现乱码；</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;    </span><br><span class="line">      </span><br><span class="line">    OutputStream out = response.getOutputStream();    </span><br><span class="line">    String data = <span class="string">"博客"</span>;    </span><br><span class="line">    out.write(data.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>
<p>输出乱码的问题是程序用UTF-8编码，而浏览器默认用GBK解码了，因此会出现乱码；</p>
<h2 id="三、Servlet相关的几种乱码"><a href="#三、Servlet相关的几种乱码" class="headerlink" title="三、Servlet相关的几种乱码"></a>三、Servlet相关的几种乱码</h2><h3 id="1、浏览器调用jsp，html等页面中文显示乱码"><a href="#1、浏览器调用jsp，html等页面中文显示乱码" class="headerlink" title="1、浏览器调用jsp，html等页面中文显示乱码"></a>1、浏览器调用jsp，html等页面中文显示乱码</h3><p><strong>此情况需满足两个要求：</strong></p>
<p>（1）文件本身是以utf-8编辑保存的（myEclipse中在properties中鼠标右键选择utf-8）</p>
<p>（2）浏览器用utf-8解析：</p>
<p>(手动)==&gt; 在浏览器中右键选择编码格式为utf-8</p>
<p>(智能)==&gt; 在文件中写入如： <meta name="content-type" content="text/html; charset=UTF-8">  通过<meta>标签模拟response头，起到告诉浏览器用utf-8的编码解析</p>
<p>(智能)==&gt; response.setContentType(“text/html;charset=UTF-8”);起到告诉浏览器用utf-8的编码解析</p>
<p><strong>常用：</strong></p>
<p><meta name="content-type" content="text/html; charset=UTF-8">或<meta charset="utf-8"><br>&lt;%@ pageEncoding=”utf-8”%&gt;<br>&lt;?xml encoding=”UTF-8”?&gt;</p>
<h3 id="2、通过浏览器调用servlet，页面显示乱码。"><a href="#2、通过浏览器调用servlet，页面显示乱码。" class="headerlink" title="2、通过浏览器调用servlet，页面显示乱码。"></a>2、通过浏览器调用servlet，页面显示乱码。</h3><p>Servlet乱码分为request乱码和response乱码；</p>
<h4 id="（1）response乱码问题"><a href="#（1）response乱码问题" class="headerlink" title="（1）response乱码问题"></a>（1）response乱码问题</h4><p><strong>解决方法：</strong></p>
<p>在网上很有效的解决方法是添加：</p>
<p>response.setCharacterEncoding(“UTF-8”);</p>
<p>解决不了，后来又搜到一条解决方法是：</p>
<p>response.setContentType(“text/html;charset=utf-8”);或者 response.setHeader(“content-type”,”text/html;charset=UTF-8”);告诉浏览器用utf-8解析。(setHeader是HttpServletResponse的方法。如果想在拦截器Filter中设置字符编码，则无此方法，因为Filter的doFilter方法的参数类型是ServletResponse)</p>
<p>两句都填上，后来终于解决了这个问题；</p>
<p>其实我们应该思考一下本质：</p>
<p>response.setContentType(“text/html;charset=UTF-8”); <strong>目的是为了控制浏览器的行为，即控制浏览器用UTF-8进行解码；</strong></p>
<p>response.setCharacterEncoding(“UTF-8”);<strong>目的是用于response.getWriter()输出的字符流的乱码问题。如果是response.getOutputStream()是不需要此种解决方案的，因为这句话的意思是为了将response对象中的数据以UTF-8解码后的字节流发向浏览器；</strong></p>
<p>问题代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">        PrintWriter out = response.getWriter();  </span><br><span class="line">        String data = <span class="string">"博客"</span>;  </span><br><span class="line">        out.println(data);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>浏览器输出的结果为： ？？</p>
<p><strong>原因</strong>：”博客”首先被封装在response对象中，因为IE和WEB服务器之间不能传输文本，然后就通过ISO-8859-1进行编码，但是ISO-8859-1中没有“博客”的编码，因此输出“？？”表示没有编码； </p>
<p>而解决方案是：response.setCharacterEncoding(“GB2312”); 设置response使用的码表 </p>
<h4 id="（2）request乱码问题"><a href="#（2）request乱码问题" class="headerlink" title="（2）request乱码问题"></a><strong>（2）request乱码问题</strong></h4><p>request请求分为post和get，对于不同的请求方式有不同的解决乱码的方案；</p>
<p><strong>==&gt;POST请求：</strong></p>
<h3 id="gt-GET请求-URI方式传递参数乱码-："><a href="#gt-GET请求-URI方式传递参数乱码-：" class="headerlink" title="==&gt;GET请求(URI方式传递参数乱码)："></a>==&gt;GET请求(URI方式传递参数乱码)：</h3><p><strong>出现情况：</strong>浏览器访问<a href><form method="get"></form></a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/webproject/display.jsp?username=张三&amp;password=123"</span>&gt;</span>显示用户名和密码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决方法：问题本质是get方式传递的参数内容默认编码方式问ISO8859-1，而且使用request.setCharacterEncoding(“utf-8”)也无法解决问题。</p>
<p><strong>法一：</strong>要解决这个问题，修改tomcat服务器的配置文件。修改tomcat目录下的conf/server.xml文件的第43行：</p>
<p>修改前内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">     <span class="attr">maxThreads</span>=<span class="string">"150"</span>   <span class="attr">connectionTimeout</span>=<span class="string">"200000"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">     <span class="attr">redirecPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改后内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">     <span class="attr">maxThreads</span>=<span class="string">"150"</span>   <span class="attr">connectionTimeout</span>=<span class="string">"200000"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">     <span class="attr">redirecPort</span>=<span class="string">"8443"</span>    <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>法二</strong>：String usernameString = new String(username.getBytes(“ISO-8859-1”),”UTF-8”); （如下图）</p>
<h3 id="3、调用数据库出现乱码"><a href="#3、调用数据库出现乱码" class="headerlink" title="3、调用数据库出现乱码"></a>3、调用数据库出现乱码</h3><p>安装数据的时候选择UTF-8</p>
<h2 id="四、JSP相关乱码解决方案-部分已经在上面介绍了"><a href="#四、JSP相关乱码解决方案-部分已经在上面介绍了" class="headerlink" title="四、JSP相关乱码解决方案(部分已经在上面介绍了)"></a>四、JSP相关乱码解决方案(部分已经在上面介绍了)</h2><p>问题描述：通过jsp，html，或servlet中的表单元素把参数提交给对应的jsp或者servlet时，在接收的jsp或servlet中接收到的参数中文显示乱码。</p>
<p>例如：</p>
<p>提交jsp代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">pageEncoding</span>=<span class="string">"utf-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>输入表单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"inputForm"</span> <span class="attr">name</span>=<span class="string">"inputForm"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"display.jsp"</span>&gt;</span></span><br><span class="line">          用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">          密 码  ：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接收参数的jsp代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> @<span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">pageEncoding</span>=<span class="string">"utf-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">tilte</span>&gt;</span>接收表单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">%</span> 在这里插入</span></span><br><span class="line"><span class="tag">            <span class="attr">request.setCharacterEncoding</span>("<span class="attr">utf-8</span>");</span></span><br><span class="line"><span class="tag">         %&gt;</span></span><br><span class="line">           用户名：<span class="tag">&lt;<span class="name">%=request.getParameter("username")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">           密  码：<span class="tag">&lt;<span class="name">%=request.getParameter("password")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决方法：在接收post提交的参数前，使用request.setCharacterEncoding(“utf-8”)设定接收参数的内容格式为utf-8编码。见接收表单中的插入内容即可。当然这种乱码问题最好使用中文过滤器的方法最好。</p>
<h2 id="五、properties文件乱码"><a href="#五、properties文件乱码" class="headerlink" title="五、properties文件乱码"></a>五、properties文件乱码</h2><p>问题描述：在使用一些类库或者框架时，为了实现页面内容国际化，需要编写对应的properties文件。而properties文件中的中文内容在显示的时候也会出现乱码。</p>
<p>解决方法：这个乱码问题可以通过jdk中的native2ascii工具解决。使用如下命令：</p>
<p>native2ascii   -encoding   utf-8  display.properties    display_zh_CN.properties</p>
<p>出现乱码问题的原因是因为java编译器只能处理Latin-1或unicode编码的字符文件。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数库模块-bisect</title>
    <url>/2020/10/15/python%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E5%9D%97-bisect/</url>
    <content><![CDATA[<h1 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect<a id="more"></a></h1><hr>
<p><strong>bisect模块实现了二分查找和插入算法</strong></p>
<p>我们可以看一下bisect模块的源码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite above definitions with a fast C implementation</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _bisect <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这可能是Python初学者少有的能快速看懂的标准库源代码。整个模块去掉注释语句，就这么多行代码。</p>
<p><code>bisect = bisect_right</code>这一行其实就是个alias，用于向后兼容。</p>
<p>最后的try、except语句为我们提供了用C语言重写算法的钩子。</p>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>bisect模块采用经典的二分算法查找元素。模块提供下面几个方法：</p>
<p><strong>bisect.bisect_left(a, x, lo=0, hi=len(a))</strong></p>
<p>定位x在序列a中的插入点，并保持原来的有序状态不变。参数lo和hi用于指定查找区间。如果x已经存在于a中，那么插入点在已存在元素的左边。函数的返回值是列表的整数下标。</p>
<p><strong>bisect.bisect_right(a, x, lo=0, hi=len(a))</strong></p>
<p>和上面的区别是插入点在右边。函数的返回值依然是一个列表下标整数。</p>
<p><strong>bisect.bisect(a, x, lo=0, hi=len(a))</strong></p>
<p>等同于bisect_right()。</p>
<p>注意，前面这三个方法都是获取插入位置，也就是列表的某个下标的，并不实际插入。但下面三个方法实际插入元素，没有返回值。</p>
<p><strong>bisect.insort_left(a, x, lo=0, hi=len(a))</strong></p>
<p>将x插入有序序列a内，并保持有序状态。相当于<code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。碰到相同的元素则插入到元素的左边。这个操作通常是 O(log n) 的时间复杂度。</p>
<p><strong>bisect.insort_right(a, x, lo=0, hi=len(a))</strong></p>
<p>同上，只不过碰到相同的元素则插入到元素的右边。</p>
<p><strong>bisect.insort(a, x, lo=0, hi=len(a))</strong></p>
<p>等同于insort_right()。</p>
<p>实例展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">x = <span class="number">200</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">454</span>, <span class="number">555</span>, <span class="number">1234</span>, <span class="number">6900</span>]</span><br><span class="line">ret = bisect.bisect(list1, x)</span><br><span class="line">print(<span class="string">"返回值： "</span>, ret)</span><br><span class="line">print(<span class="string">"list1 = "</span>, list1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------</span></span><br><span class="line">运行结果：</span><br><span class="line">返回值：  <span class="number">6</span></span><br><span class="line">list1 =  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">454</span>, <span class="number">555</span>, <span class="number">1234</span>, <span class="number">6900</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">x = <span class="number">200</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">454</span>, <span class="number">555</span>, <span class="number">1234</span>, <span class="number">6900</span>]</span><br><span class="line">ret = bisect.insort(list1, x)</span><br><span class="line">print(<span class="string">"返回值： "</span>, ret)</span><br><span class="line">print(<span class="string">"list1 = "</span>, list1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------</span></span><br><span class="line">运行结果：</span><br><span class="line">返回值：  <span class="literal">None</span></span><br><span class="line">list1 =  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">200</span>, <span class="number">454</span>, <span class="number">555</span>, <span class="number">1234</span>, <span class="number">6900</span>]</span><br></pre></td></tr></table></figure>
<p>下面是一个bisect和random配合的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'New  Pos Contents'</span>)</span><br><span class="line">print(<span class="string">'---  --- --------'</span>)</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">15</span>):</span><br><span class="line">    r = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    position = bisect.bisect(l, r)</span><br><span class="line">    bisect.insort(l, r)</span><br><span class="line">    print(<span class="string">'%3d  %3d'</span> % (r, position), l)</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------</span></span><br><span class="line">打印结果：</span><br><span class="line">New  Pos Contents</span><br><span class="line">---  --- --------</span><br><span class="line"> <span class="number">18</span>    <span class="number">0</span> [<span class="number">18</span>]</span><br><span class="line"> <span class="number">73</span>    <span class="number">1</span> [<span class="number">18</span>, <span class="number">73</span>]</span><br><span class="line"> <span class="number">98</span>    <span class="number">2</span> [<span class="number">18</span>, <span class="number">73</span>, <span class="number">98</span>]</span><br><span class="line">  <span class="number">9</span>    <span class="number">0</span> [<span class="number">9</span>, <span class="number">18</span>, <span class="number">73</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">33</span>    <span class="number">2</span> [<span class="number">9</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">73</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">16</span>    <span class="number">1</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">73</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">64</span>    <span class="number">4</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">98</span>    <span class="number">7</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">58</span>    <span class="number">4</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">58</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">61</span>    <span class="number">5</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">58</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">84</span>    <span class="number">8</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">58</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">49</span>    <span class="number">4</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">33</span>, <span class="number">49</span>, <span class="number">58</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">27</span>    <span class="number">3</span> [<span class="number">9</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">27</span>, <span class="number">33</span>, <span class="number">49</span>, <span class="number">58</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br><span class="line"> <span class="number">13</span>    <span class="number">1</span> [<span class="number">9</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">27</span>, <span class="number">33</span>, <span class="number">49</span>, <span class="number">58</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">98</span>, <span class="number">98</span>]</span><br></pre></td></tr></table></figure>
<p>下面的5个例子是利用bisect模块实现通用的列表元素查询方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'定位最左边的值等于x的元素的下标'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a) <span class="keyword">and</span> a[i] == x:</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'获取最靠右的值小于x的元素'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'获取最靠右的值小于等于x的元素'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'获取最靠左边的值大于x的元素'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'获取最靠左边的值大于或等于x的元素'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br></pre></td></tr></table></figure>
<p>下面是一个利用bisect自动由百分制成绩转换为ABCD等级的方法：90 以上是‘A’, 80 -89 是‘B’,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score, breakpoints=[<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>], grades=<span class="string">'FDCBA'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    i = bisect(breakpoints, score)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> grades[i]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[grade(score) <span class="keyword">for</span> score <span class="keyword">in</span> [<span class="number">33</span>, <span class="number">99</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">100</span>]]</span><br><span class="line">[<span class="string">'F'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure>
<p>另外一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">'red'</span>, <span class="number">5</span>), (<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'yellow'</span>, <span class="number">8</span>), (<span class="string">'black'</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.sort(key=<span class="keyword">lambda</span> r: r[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [r[<span class="number">1</span>] <span class="keyword">for</span> r <span class="keyword">in</span> data]         <span class="comment"># precomputed list of keys</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">0</span>)]</span><br><span class="line">(<span class="string">'black'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">1</span>)]</span><br><span class="line">(<span class="string">'blue'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">5</span>)]</span><br><span class="line">(<span class="string">'red'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">8</span>)]</span><br><span class="line">(<span class="string">'yellow'</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p><strong>转自：</strong><a href="https://www.liujiangblog.com/course/python/57" target="_blank" rel="noopener">https://www.liujiangblog.com/course/python/57</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>bitsect</tag>
        <tag>python标准库</tag>
      </tags>
  </entry>
  <entry>
    <title>python标准库模块-heapq</title>
    <url>/2020/10/14/python%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E5%9D%97-heapq/</url>
    <content><![CDATA[<h1 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a><strong>heapq</strong><a id="more"></a></h1><p>该模块提供了堆排序算法的实现。堆是二叉树，最大堆中父节点大于或等于两个子节点，最小堆父节点小于或等于两个子节点。</p>
<p>（Ki &lt;= 2Ki  Ki &lt;= 2Ki+1）</p>
<h3 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a><strong>创建堆</strong></h3><p>heapq有两种方式创建堆， 一种是使用一个空列表，然后使用heapq.heappush()函数把值加入堆中，另外一种就是使用heap.heapify(list)转换列表成为堆结构 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.heappush(heap, item)</span></span><br><span class="line"><span class="string">    - Push the value item onto the heap, maintaining the heap invariant.</span></span><br><span class="line"><span class="string">heapq.heappop(heap)</span></span><br><span class="line"><span class="string">    - Pop and return the smallest item from the heap, maintaining the heap invariant.</span></span><br><span class="line"><span class="string">    If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0].</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    heapq.heappush(heap, num)  <span class="comment"># 加入堆</span></span><br><span class="line"></span><br><span class="line">print(heap[<span class="number">0</span>])  <span class="comment"># 如果只是想获取最小值而不是弹出，使用heap[0]</span></span><br><span class="line">print([heapq.heappop(heap) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line">print([heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))])  <span class="comment"># 堆排序结果</span></span><br><span class="line"><span class="comment"># out: [1, 2, 3, 5, 23, 54, 132]</span></span><br></pre></td></tr></table></figure>
<p>heapq 模块还有一个<code>heapq.merge(*iterables)</code> 方法，用于合并多个排序后的序列成一个排序后的序列， 返回排序后的值的迭代器。<br> 类似于<code>sorted(itertools.chain(*iterables))</code>，但返回的是可迭代的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.merge(*iterables)</span></span><br><span class="line"><span class="string">    - Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values.</span></span><br><span class="line"><span class="string">    - Similar to sorted(itertools.chain(*iterables)) but returns an iterable, does not pull the data into memory all at once, and assumes that each of the input streams is already sorted (smallest to largest).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">num1 = [<span class="number">32</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">23</span>, <span class="number">132</span>]</span><br><span class="line">num2 = [<span class="number">23</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">656</span>, <span class="number">324</span>, <span class="number">23</span>, <span class="number">54</span>]</span><br><span class="line">num1 = sorted(num1)</span><br><span class="line">num2 = sorted(num2)</span><br><span class="line"></span><br><span class="line">res = heapq.merge(num1, num2)</span><br><span class="line">print(list(res))</span><br></pre></td></tr></table></figure>
<h3 id="访问堆内容"><a href="#访问堆内容" class="headerlink" title="访问堆内容"></a><strong>访问堆内容</strong></h3><p>堆创建好后，可以通过`heapq.heappop() 函数弹出堆中最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">12</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line"></span><br><span class="line">print(heapq.heappop(nums))</span><br><span class="line"><span class="comment"># out: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要所有堆排序后的元素</span></span><br><span class="line">result = [heapq.heappop(nums) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># out: [12, 23, 43, 45]</span></span><br></pre></td></tr></table></figure>
<p>如果需要删除堆中最小元素并加入一个元素，可以使用<code>heapq.heaprepalce()</code> 函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">heapq.heapify(nums)</span><br><span class="line"></span><br><span class="line">heapq.heapreplace(nums, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([heapq.heappop(nums) <span class="keyword">for</span> _ in <span class="keyword">range</span>(<span class="built_in">len</span>(nums))])</span><br><span class="line"># out: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br></pre></td></tr></table></figure>
<h3 id="获取堆最大或最小值"><a href="#获取堆最大或最小值" class="headerlink" title="获取堆最大或最小值"></a><strong>获取堆最大或最小值</strong></h3><p>如果需要获取堆中最大或最小的范围值，则可以使用<code>heapq.nlargest()</code> 或<code>heapq.nsmallest()</code> 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数定义：</span></span><br><span class="line"><span class="string">heapq.nlargest(n, iterable[, key])¶</span></span><br><span class="line"><span class="string">    - Return a list with the n largest elements from the dataset defined by iterable. </span></span><br><span class="line"><span class="string">    - key if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower</span></span><br><span class="line"><span class="string">    - Equivalent to: sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">[5, 4, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>这两个函数还接受一个key参数，用于dict或其他数据结构类型使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">pprint(cheap)</span><br><span class="line">pprint(expensive)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">[&#123;'name': 'YHOO', 'price': 16.35, 'shares': 45&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'FB', 'price': 21.09, 'shares': 200&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'HPQ', 'price': 31.75, 'shares': 35&#125;]</span></span><br><span class="line"><span class="string">[&#123;'name': 'AAPL', 'price': 543.22, 'shares': 50&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'ACME', 'price': 115.65, 'shares': 75&#125;,</span></span><br><span class="line"><span class="string"> &#123;'name': 'IBM', 'price': 91.1, 'shares': 100&#125;]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="heapq应用"><a href="#heapq应用" class="headerlink" title="heapq应用"></a><strong>heapq应用</strong></h3><p>实现heap堆排序算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>该算法和<code>sorted(iterable)</code> 类似，但是它是不稳定的。</p>
<p>堆的值可以是元组类型，可以实现对带权值的元素进行排序。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; h = []</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></table></figure>
<p>转自：<a href="https://www.jianshu.com/p/801318c77ab5" target="_blank" rel="noopener">https://www.jianshu.com/p/801318c77ab5</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>python标准库</tag>
        <tag>heapq</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-183</title>
    <url>/2020/08/15/leetcode-183/</url>
    <content><![CDATA[<h4 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/" target="_blank" rel="noopener">183. 从不订购的客户</a></h4><a id="more"></a><strong>题目描述：</strong><br><br>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。<br><br><code>Customers</code> 表：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<p><code>Orders</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>
<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>
<p><strong>代码及解析：</strong></p>
<p>利用左连接即可轻松解决，左连接保留左表，右表无数据则用NULL自动填充，所以左连接后，只需判断CustomerId 是否为NULL即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line">select Name Customers</span><br><span class="line"></span><br><span class="line">from Customers  a left join Orders  b on a.Id = b.CustomerId</span><br><span class="line"></span><br><span class="line">where b.CustomerId is NULL;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-181</title>
    <url>/2020/07/15/leetcode-181/</url>
    <content><![CDATA[<h4 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">181. 超过经理收入的员工</a></h4><a id="more"></a><strong>题目描述：</strong><br><br><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>
<p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<p><strong>代码及解析：</strong></p>
<p>自连查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT a.Name Employee</span><br><span class="line">FROM Employee a,Employee b</span><br><span class="line">WHERE a.Salary &gt; b.Salary and a.ManagerId=b.Id;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-184</title>
    <url>/2020/07/07/leetcode-184/</url>
    <content><![CDATA[<h4 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></h4><a id="more"></a><strong>题目描述：</strong><br><br>Employee` 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Jim   | 90000  | 1            |</span><br><span class="line">| 3  | Henry | 80000  | 2            |</span><br><span class="line">| 4  | Sam   | 60000  | 2            |</span><br><span class="line">| 5  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Jim      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</p>
<p><strong>代码及解释：</strong></p>
<p><strong>解题思路:</strong><br>先对Employee表对工资进行排序并加上序号，根据样例最大值都要输出，所以利用DENSE_RANK()的特性，特性就是对于同样大的数序号相等，所以本题就序号进行判断是否等于1即可，即序号为1就输出<br>扩展：<br>如果最大值只输出一个那就利用ROW_NUMBER(),此函数与上面函数几乎一样，唯一差别就在于，这个函数对于同样大的数，序号不相等，而是依次排列。</p>
<p><strong>扩展：</strong></p>
<p>RANK():这个排序是跳跃排序，比如两个第一名，序号都为1，第二名则序号为3<br>DENSE_RANK()为连续排序，比如两个第一名，序号都为1，则第二名序号为2<br>ROW_NUMBER() 是没有重复值的排序(即使两条记录相等也是不重复的)，可以利用它来实现分页<br>解释：<br>partition by<br>答：<br>partition by为分析函数的一部分，并不把相同的数据合并，只把相同的数据分为一组，每项都会保留。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select a.Name Department,b.Name Employee,b.Salary Salary</span><br><span class="line">from Department a,</span><br><span class="line">(select Salary,Name,Id, DepartmentId,dense_rank()  over(partition by DepartmentId order by Salary DESC) sort</span><br><span class="line">from Employee) b</span><br><span class="line">where sort=1 and b.DepartmentId=a.Id;</span><br></pre></td></tr></table></figure>
<p>练习：</p>
<h4 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178. 分数排名</a></h4>]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-180</title>
    <url>/2020/06/30/leetcode-180/</url>
    <content><![CDATA[<h4 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener">180. 连续出现的数字</a></h4><a id="more"></a><strong>题目描述：</strong><br><br>编写一个 SQL 查询，查找所有至少连续出现三次的数字。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure>
<p>例如，给定上面的 <code>Logs</code> 表， <code>1</code> 是唯一连续出现至少三次的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ConsecutiveNums |</span><br><span class="line">+-----------------+</span><br><span class="line">| 1               |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>代码及解析：</p>
<p>利用distinct去重，以用lead(Num,n) 获取Num的第n行Num值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select distinct Num ConsecutiveNums</span><br><span class="line">from (select Id,Num,lead(Num,1) over(order by Id)  Num2,</span><br><span class="line">lead(Num,2) over(order by Id)  Num3</span><br><span class="line">from Logs) as a</span><br><span class="line">where Num=Num2 and Num2=Num3;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-101</title>
    <url>/2020/06/27/leetcode-101/</url>
    <content><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><h4 id><a href="#" class="headerlink" title></a><a id="more"></a></h4><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>代码及题解：</p>
<p>思路：将同一层的节点值放入一个临时数组temp，NULL也要放进去，判断该数组是否左右对称，如果不对称返回False，到全部判断完都对称，则该二叉树为对称的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        deque=[root]</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            deq_node=[]</span><br><span class="line">            tmp=[]</span><br><span class="line">            <span class="keyword">while</span> deque:</span><br><span class="line">                que=deque.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> que:</span><br><span class="line">                    tmp.append(que.val)</span><br><span class="line">                    deq_node.append(que.left)</span><br><span class="line">                    deq_node.append(que.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(que)</span><br><span class="line">            lens=len(tmp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(lens):</span><br><span class="line">                <span class="keyword">if</span> (lens - i<span class="number">-1</span>) &gt;= i:</span><br><span class="line">                    <span class="keyword">if</span> tmp[i] != tmp[lens - <span class="number">1</span>-i]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            deque.extend(deq_node)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-257</title>
    <url>/2020/06/25/leetcode-257/</url>
    <content><![CDATA[<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></h4><a id="more"></a><strong>题目描述：</strong><br><br>给定一个二叉树，返回所有从根节点到叶子节点的路径。<br><br><strong>说明:</strong> 叶子节点是指没有子节点的节点。<br><br><strong>示例:</strong><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>代码及解析：</strong></p>
<p>利用dfs深搜递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:</span><br><span class="line">        res=[]</span><br><span class="line">        def dfs(root,temp):</span><br><span class="line">            if root :</span><br><span class="line">                temp+=str(root.val)</span><br><span class="line">                if not root.left and not root.right:</span><br><span class="line">                    res.append(temp)</span><br><span class="line">                else:</span><br><span class="line">                    temp+=&apos;-&gt;&apos;</span><br><span class="line">                    dfs(root.left,temp)</span><br><span class="line">                    dfs(root.right,temp)</span><br><span class="line">        dfs(root,&apos;&apos;)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-13</title>
    <url>/2020/06/23/leetcode-13/</url>
    <content><![CDATA[<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a><a id="more"></a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</span><br><span class="line"></span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</span><br><span class="line">输入：II</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>代码及解析：</strong></p>
<p>利用字典存储字符与数字，key为字符，value为数值，将特殊规则那六种情况也存进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'IV'</span>:<span class="number">3</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'IX'</span>:<span class="number">8</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'XL'</span>:<span class="number">30</span>, <span class="string">'L'</span>:<span class="number">50</span>,</span><br><span class="line">         <span class="string">'XC'</span>:<span class="number">80</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'CD'</span>:<span class="number">300</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'CM'</span>:<span class="number">800</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            res+=d.get(s[max(i<span class="number">-1</span>,<span class="number">0</span>):i+<span class="number">1</span>],d[x]) <span class="comment">#关键就在这，s[i-1:i+1]就是处理特殊规则的，max的作用防止出现 s[-1:0]的情况</span></span><br><span class="line">            <span class="comment"># get的作用 如果key中找到结果，即存在该特例字符串，返回该字符串对应的数值，否则返回的d[x]单个字符对应的数值</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-60</title>
    <url>/2020/06/20/leetcode-60/</url>
    <content><![CDATA[<h4 id="60-第k个排列"><a href="#60-第k个排列" class="headerlink" title="60. 第k个排列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 第k个排列</a><a id="more"></a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</span><br><span class="line"></span><br><span class="line">按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</span><br><span class="line"></span><br><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br><span class="line">给定 n 和 k，返回第 k 个排列。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">给定 n 的范围是 [1, 9]。</span><br><span class="line">给定 k 的范围是[1,  n!]。</span><br></pre></td></tr></table></figure>
<p><strong>代码及解析：</strong></p>
<p>看到这种题，第一感觉直接暴力枚举，可能超时，但根据题目n&lt;=9则不会超时，虽然不会超时，但这不是最明智的方法，此题可以利用康托逆运算。</p>
<p><strong>康托展开</strong></p>
<p>对于1-n的全排列，判断给定的序列的位置。</p>
<p><strong>原理：</strong></p>
<p>X=a[n]*(n-1)!+a[n-1]*(n-2)!+…+a[i]*(i-1)!+…+a[1]*0!<br>其中, a[i]为整数，并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n, a[i]表示未出现元素中小于当前值的个数，X为小于该序列的个数，则x+1为该序列在所有排列中的位置，这就是康托展开。</p>
<p>例如有3个数（1，2，3），则其排列组合及其相应的康托展开值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">排列组合</th>
<th>名次</th>
<th>康托展开</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">123</td>
<td>1</td>
<td>0 <em> 2! + 0 </em> 1! + 0 * 0!</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:left">132</td>
<td>2</td>
<td>0 <em> 2! + 1 </em> 1! + 0 * 0!</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">213</td>
<td>3</td>
<td>1 <em> 2! + 0 </em> 1! + 0 * 0!</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:left">231</td>
<td>4</td>
<td>1 <em> 2! + 1 </em> 1! + 0 * 0!</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">312</td>
<td>5</td>
<td>2 <em> 2! + 0 </em> 1! + 0 * 0!</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:left">321</td>
<td>6</td>
<td>2 <em> 2! + 1 </em> 1! + 0 * 0!</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>比如其中的 231：</p>
<ul>
<li>想要计算排在它前面的排列组合数目（123，132，213），则可以转化为计算比首位小即小于2的所有排列「1 <em> 2！」，首位相等为2并且第二位小于3的所有排列「1 </em> 1！」，前两位相等为23并且第三位小于1的所有排列（0 <em> 0！）的和即可，康托展开为：1 </em> 2！+1 <em> 1+0 </em> 0=3。</li>
<li>所以小于231的组合有3个，所以231的名次是4。</li>
</ul>
<p>再举个例子说明。<br>在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。</p>
<ul>
<li>首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为 a[5]*(5-1)!</li>
<li>第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2</li>
<li>第三位是1，则在其之后小于1的数有0个，所以a[3]=0</li>
<li>第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1</li>
<li>最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0</li>
<li>根据公式：<br><code>X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! = 2 * 24 + 2 * 6 + 1 = 61</code><br>所以比 34152 小的组合有61个，即34152是排第62。</li>
</ul>
<p><strong>逆康托展开：</strong></p>
<p>对于上述例子，在（1，2，3，4，5）给出62可以算出起排列组合为 34152。由上述的计算过程可以容易的逆推回来，具体过程如下：</p>
<p>排第62名，则值为61即小于它的序列有61个。</p>
<ul>
<li>用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。</li>
<li>用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。</li>
<li>用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。</li>
<li>用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。</li>
<li>最后一位自然就是剩下的数2啦。</li>
<li>通过以上分析，所求排列组合为 34152</li>
</ul>
<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于n=<span class="number">4</span>, k=<span class="number">15</span> 找到k=<span class="number">15</span>排列的过程:</span><br><span class="line"><span class="number">1</span> + 对<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>的全排列 (<span class="number">3</span>!个)         </span><br><span class="line">        <span class="number">2</span> + 对<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>的全排列 (<span class="number">3</span>!个)         <span class="number">3</span>, <span class="number">1</span> + 对<span class="number">2</span>,<span class="number">4</span>的全排列(<span class="number">2</span>!个)</span><br><span class="line">        <span class="number">3</span> + 对<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>的全排列 (<span class="number">3</span>!个)-------&gt; <span class="number">3</span>, <span class="number">2</span> + 对<span class="number">1</span>,<span class="number">4</span>的全排列(<span class="number">2</span>!个)-------&gt; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> + 对<span class="number">4</span>的全排列(<span class="number">1</span>!个)-------&gt; <span class="number">3214</span></span><br><span class="line">        <span class="number">4</span> + 对<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>的全排列 (<span class="number">3</span>!个)         <span class="number">3</span>, <span class="number">4</span> + 对<span class="number">1</span>,<span class="number">2</span>的全排列(<span class="number">2</span>!个)         <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> + 对<span class="number">1</span>的全排列(<span class="number">1</span>!个)</span><br><span class="line">        </span><br><span class="line">        确定第一位:</span><br><span class="line">            k = <span class="number">14</span>(从<span class="number">0</span>开始计数)</span><br><span class="line">            index = k / (n-<span class="number">1</span>)! = <span class="number">2</span>, 说明第<span class="number">15</span>个数的第一位是<span class="number">3</span> </span><br><span class="line">            更新k</span><br><span class="line">            k = k - index*(n-<span class="number">1</span>)! = <span class="number">2</span></span><br><span class="line">        确定第二位:</span><br><span class="line">            k = <span class="number">2</span></span><br><span class="line">            index = k / (n-<span class="number">2</span>)! = <span class="number">1</span>, 说明第<span class="number">15</span>个数的第二位是<span class="number">2</span></span><br><span class="line">            更新k</span><br><span class="line">            k = k - index*(n-<span class="number">2</span>)! = <span class="number">0</span></span><br><span class="line">        确定第三位:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            index = k / (n-<span class="number">3</span>)! = <span class="number">0</span>, 说明第<span class="number">15</span>个数的第三位是<span class="number">1</span></span><br><span class="line">            更新k</span><br><span class="line">            k = k - index*(n-<span class="number">3</span>)! = <span class="number">0</span></span><br><span class="line">        确定第四位:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            index = k / (n-<span class="number">4</span>)! = <span class="number">0</span>, 说明第<span class="number">15</span>个数的第四位是<span class="number">4</span></span><br><span class="line">        最终确定n=<span class="number">4</span>时第<span class="number">15</span>个数为<span class="number">3214</span></span><br></pre></td></tr></table></figure>
<p>所以此题根据康托逆展开代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        factorial=[]<span class="comment">#存储阶乘</span></span><br><span class="line">        order=[]<span class="comment">#存储未出现的数</span></span><br><span class="line">        factorial.append(<span class="number">1</span>)</span><br><span class="line">        temp=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            order.append(i)</span><br><span class="line">            temp*=i</span><br><span class="line">            factorial.append(temp)</span><br><span class="line">        k-=<span class="number">1</span> <span class="comment">#第k个，即小于它的有k-1个</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n)[::<span class="number">-1</span>]:</span><br><span class="line">            index=k//factorial[i]</span><br><span class="line">            res.append(order.pop(index))</span><br><span class="line">            k-=factorial[i]*index</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
        <tag>康托</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1577</title>
    <url>/2020/06/17/leetcode-5508/</url>
    <content><![CDATA[<h4 id="1577-数的平方等于两数乘积的方法数"><a href="#1577-数的平方等于两数乘积的方法数" class="headerlink" title="1577. 数的平方等于两数乘积的方法数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/" target="_blank" rel="noopener">1577. 数的平方等于两数乘积的方法数</a><a id="more"></a></h4><p>给你两个整数数组 nums1 和 nums2 ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p>
<p>类型 1：三元组 (i, j, k) ，如果 nums1[i]^2 == nums2[j] <em> nums2[k] 其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; k &lt; nums2.length<br>类型 2：三元组 (i, j, k) ，如果 nums2[i]^2 == nums1[j] </em> nums1[k] 其中 0 &lt;= i &lt; nums2.length 且 0 &lt;= j &lt; k &lt; nums1.length</p>
<p>结果返回    (类型1+类型2)个数</p>
<p>代码及解析：</p>
<p>题目意思就是其中一个数组中的数的平方等于另一个数组里任意两个数乘积的个数</p>
<p>代码中我用到了hash记录乘积值，原因是数组访问速度慢，容易超时(结果的确超时了)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTriplets</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">        num11=[] <span class="comment">#nums1的平方数</span></span><br><span class="line">        num22=[] <span class="comment">#nums2的平方数</span></span><br><span class="line">        num111=&#123;&#125;<span class="comment">#nums1的任意两元素的乘积，key为乘积值，value为内部元素乘积相等的次数</span></span><br><span class="line">        num222=&#123;&#125;<span class="comment">#num2的任意两元素的乘积，key为乘积值，value为内部元素乘积相等的次数</span></span><br><span class="line">        res=<span class="number">0</span> <span class="comment">#记录次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            num11.append(i**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">            num22.append(j**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i  <span class="keyword">in</span> range(len(nums1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums1)):</span><br><span class="line">                num111[nums1[i]*nums1[j]]=num111.get(nums1[i]*nums1[j],<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i  <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums2)):</span><br><span class="line">                num222[nums2[i]*nums2[j]]=num222.get(nums2[i]*nums2[j],<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num11)):</span><br><span class="line">            <span class="keyword">if</span> num11[i] <span class="keyword">in</span> num222.keys():</span><br><span class="line">                res+=num222[num11[i]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num22)):</span><br><span class="line">            <span class="keyword">if</span> num22[i] <span class="keyword">in</span> num111.keys():</span><br><span class="line">                res+=num111[num22[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-102</title>
    <url>/2020/06/15/leetcode-102/</url>
    <content><![CDATA[<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a><a id="more"></a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码及解析：</p>
<p>将同一层的节点存到一个临时数组中，访问完同一层的所有节点，就将该临时数组添加到结果res数组中，利用队列每访问一个节点，将其pop掉，然后将该节点的左右节点推入队列，直到队列为空，返回结果res结束。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res=[]</span><br><span class="line">        deque=[root]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = []</span><br><span class="line">            node = []</span><br><span class="line">            <span class="keyword">while</span> deque:</span><br><span class="line">                que=deque.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(que.val)</span><br><span class="line">                <span class="keyword">if</span> que.left:</span><br><span class="line">                    node.append(que.left)</span><br><span class="line">                <span class="keyword">if</span> que.right:</span><br><span class="line">                    node.append(que.right)</span><br><span class="line">            deque.extend(node)</span><br><span class="line">            res.append(tmp) </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extend与append的区别：</span><br><span class="line">    两者作用差不多，都是添加元素至数组中，两者区别在于，比如添加一个数组，前者是按顺序在数组最后一个一个的添加进去，而后者是直接将整个数组添加进去，</span><br><span class="line">比如:a=[1],b=[2,3]</span><br><span class="line">extend:a=[1,2,3]</span><br><span class="line">append:a=[1,[2,3]]</span><br></pre></td></tr></table></figure>
<p><strong>举一反三：</strong></p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">leetcode-107</a>：与上述题目一样，只是将结果反向输出即可</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        deque=[root]</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            temp=[]</span><br><span class="line">            extend=[]</span><br><span class="line">            <span class="keyword">while</span> deque:</span><br><span class="line">                que=deque.pop(<span class="number">0</span>)</span><br><span class="line">                temp.append(que.val)</span><br><span class="line">                <span class="keyword">if</span> que.left:</span><br><span class="line">                    extend.append(que.left)</span><br><span class="line">                <span class="keyword">if</span> que.right:</span><br><span class="line">                    extend.append(que.right)</span><br><span class="line">            deque.extend(extend)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>] <span class="comment">#将数组反向顺序返回即可</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode-104</a>：求二叉树的最大深度，利用层序遍历，每遍历一层深度+1</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        max=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        deque=[root]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = [] <span class="comment">#存储每层的节点</span></span><br><span class="line">            node = []</span><br><span class="line">            <span class="keyword">while</span> deque:</span><br><span class="line">                que=deque.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(que.val)</span><br><span class="line">                <span class="keyword">if</span> que.left:</span><br><span class="line">                    node.append(que.left)</span><br><span class="line">                <span class="keyword">if</span> que.right:</span><br><span class="line">                    node.append(que.right)</span><br><span class="line">            <span class="keyword">if</span> tmp:</span><br><span class="line">                max+=<span class="number">1</span> <span class="comment">#若此层不为空，深度+1</span></span><br><span class="line">            deque.extend(node)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max</span><br></pre></td></tr></table></figure>
<p><strong>写在最后：</strong></p>
<p>如果您有任何不明白，或描述上述有问题，请在下方留言。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于django中出现no such table: auth_user错误的解决办法</title>
    <url>/2020/06/11/%E5%85%B3%E4%BA%8Edjango%E4%B8%AD%E5%87%BA%E7%8E%B0no-such-table-auth-user%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><a id="more"></a>我们创建过Django工程后,Django会自动给我们创建一个Django的后台管理页面.,我们要进去登录就必须需要先创建一个超级用户.</p>
<p>输入命令进行创建：python  manage.py createsuperuser</p>
<p>但弹出了django.db.utils.OperationalError: no such table: auth_user 错误</p>
<p>1.首先呢使用下面命令创建默认库</p>
<p>python manage.py migrate</p>
<p>如果是django1.7以前版本，命令是：</p>
<p>python manage.py sydb</p>
<p>2.使用命令行创建默认超级用户</p>
<p>python manage.py createsuperuser</p>
<p>然后根据提示完成uername及password的设置即可成功。</p>
<p><img src="/images/auth_error1.png" alt></p>
<p><img src="/images/auth_error.png" alt></p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>初学django-3</title>
    <url>/2020/06/10/%E5%88%9D%E5%AD%A6django-3/</url>
    <content><![CDATA[<p>上一节课已经教大家成功运行起来了django，这节课就教大家开发属于自己的web项目。<a id="more"></a></p>
<p>首先使用pycharm打开上一节创建的django项目，然后点击下面的Terminal 然后输入命令：python manage.py startapp [name] (name是自己创建的app名称，以book为例吧)。</p>
<p><img src="/images/pycharm创建app.png" alt></p>
<p>也可以在电脑终端进入到的创建的项目中，然后切换一个虚拟环境，再运行：python manage.py startapp book即可创建。</p>
<p>最后输入命令：deactivate退出虚拟环境。</p>
<p><img src="/images/终端创建app.png" alt></p>
<p><strong>视图：</strong></p>
<p>视图一般写在创建的app的views.py中，并且视图的第一个参数永远是request(一个HttpRequest)对象，这个对象存储了请求过来的所有信息，包括携带的参数以及一些头部信息等，在视图中，一般是完成逻辑相关的操作，比如这个请求是添加一篇博客，那么可以通过request来接受这些数据，然后存储到数据库中，最后再把执行的结果返回给浏览器，视图函数的返回值必须是HttpResponse对象或子类的对象。</p>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'图书首页'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>URL映射：</strong></p>
<p>视图写完以后，要与URL进行映射，也就是用户在浏览器中输入URL时可以到这个视图函数。在用户输入某个URL，请求我们网站时，django就会从项目的urls.py中寻找对应的视图，在urls.py中有一个urlpatterns变量，以后django就会从这个变量中读取所有的匹配规则，匹配规则需要使用django.url中的path函数进行包裹，这个函数会根据传入的参数返回urlpatterns或者是urlResolver的对象。</p>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> book <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'book/'</span>,views.book)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样运行django项目后， http:/ /127.0.0.1:8000/就访问不了了，因为urls.py中没有对应的url，访问 http:/ /127.0.0.1:8000/book/就可以看到页面显示”<strong>图书首页</strong>“了。</p>
<p>有同学可能可能会问，为什么在没有添加上面这些代码时 http:/ /127.0.0.1:8000/就可以访问成功呢，其实那是django自带的页面，告诉你的django项目正常运行起来了，这是django的初始状态，没有添加任何url的项目，只要添加任何的url，原始页面就不存在了，如果你想 http:// 127.0.0.1:8000/该网址可以正常访问，你可以在urlparterns变量中添加一个下面这样的url即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">比如：</span><br><span class="line">path(<span class="string">''</span>,views.book)</span><br></pre></td></tr></table></figure>
<p><strong>URL中添加参数：</strong></p>
<p><strong>url映射：</strong></p>
<p>1.为什么回去urls.py文件中去寻找映射呢”</p>
<p>是因为在setting,py文件中配置了’ROOT_URLCONF’为’urls.py’。这样django的url都会去urls.py中去寻找。</p>
<p>2.要记住在’urls.py’中的映射，都要放在’urlpatterns’这个变量中。</p>
<p><strong>url传递参数</strong>：</p>
<p>1.采用在url中使用变量的方式：在path的第一个参数中，使用’&lt;参数名&gt;’的方式可以传递参数。然后在视图函数中也要写一个函数，视图函数中的函数必须和url中的参数名称保持一致，不然找不到这个这个参数，另外，url中可以传递多个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(request,book_id)</span>:</span></span><br><span class="line">    text=<span class="string">'您的图书代码是:%s'</span>%(book_id)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#urls.py   </span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> book <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'book/&lt;book_id&gt;/'</span>,views.book),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输入http:/ /127.0.0.1:8000/book/&lt; id &gt;即可访问。(‘&lt;&gt;’不用加，id取任意值)</p>
<p><img src="/images/传参运行结果.png" alt></p>
<p>2.采用查询字符串的方式：在url中，不需要单独的匹配查询字符串的部分.只需要在视图函数中使用’request.GET.get(‘参数名称’)’的方式来获取。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(request)</span>:</span></span><br><span class="line">    book_id=request.GET.get(<span class="string">'id'</span>)</span><br><span class="line">    <span class="comment">#或者book_id=request.GET['id']</span></span><br><span class="line">    text=<span class="string">'您的图书代码是:%s'</span>%(book_id)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#urls.py   </span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> book <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'book/'</span>,views.book),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输入http:/ /127.0.0.1:8000/book/? id =&lt; num &gt;即可访问。(‘&lt;&gt;’不用加，num取任意值)</p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>初学django-2</title>
    <url>/2020/06/09/%E5%88%9D%E5%AD%A6django-2/</url>
    <content><![CDATA[<p><a id="more"></a><strong>创建第一个django项目：</strong></p>
<p><strong>1、用命令行的方式：</strong></p>
<p>1).创建项目：打开终端，使用命令：django-admin startproject [项目名称] 即可创建。</p>
<p>2).创建应用(app)：一个项目类似于一个架子，但真正器起作用的是app，在终端进入项目所在的目录，执行 pytohn manage.py startapp [项目名称]。</p>
<p>3).运行项目：在终端进入到项目所在的目录，执行 python magage.py runserver即可</p>
<p><strong>2、用pycharm的方式：</strong></p>
<p>pycharm的版本必须选择专业版的，因为只有专业版的才可以进行django项目的开发</p>
<p>根据下图提示，然后点击右下角的create即可。</p>
<p><img src="/images/创建项目.png" alt></p>
<p>我们创建成功之后该项目所在文件夹会自动生成一些文件夹以及名为manage.py的文件，在自动生成的文件夹中有一个与项目同名的文件夹(即创建的应用app)，打开之后我们会看到一些自动生成的py文件.</p>
<p><img src="/images/生成的文件.png" alt></p>
<p><strong>它们的作用：</strong></p>
<p><strong>1.manage.py：</strong>以后和项目交互基本上都是基于这个文件。一般都是在终端进入到该该文件所在目录，然后输入 python manage.py runserver [子命令]。进行启动django项目。可以输入 python manage.py help 可以看下它能做大的哪些事情。</p>
<p><strong>2.setting.py：</strong>本项目的设置项，所有和项目相关的配置都在放在该文件中。</p>
<p><strong>3.urls.py：</strong>这个文件是用来配置url路由的，比如http:/ /127.0.0.1/这是某网站首页，http:/ /127.0.0.1/news是新闻页面，这个新闻页面url就是在这个文件中完成的。<em>**</em></p>
<p><strong>4.wsgi.py：</strong>项目与协议兼容的web服务器入口，部署的时候需要用到的，一般情况下是不进行修改的。</p>
<p><strong>运行django项目：</strong></p>
<p>1.在创建成功之后，可以点击右上角的绿色小箭头即可运行。</p>
<p>2.也可以在下方的Terminal中输入python manage.py runserver ，然后回车即可。</p>
<p><img src="/images/Terminal位置.png" alt></p>
<p>运行成功后，terminal显示的是这样的一串代码。</p>
<p><img src="/images/运行成功.png" alt></p>
<p>访问图片中蓝色的网址即可看倒django运行起来的状态。</p>
<p><img src="/images/运行状态.png" alt></p>
<p>这样我们的第一个django项目就成功运行起来了！！！</p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>初学django-1</title>
    <url>/2020/05/21/%E5%88%9D%E5%AD%A6django-1/</url>
    <content><![CDATA[<p><a id="more"></a>在学习django之前，要进行一些准备：</p>
<p>&emsp;编程语言：python3.7</p>
<p>&emsp;框架：django2.0.2</p>
<p>&emsp;操作系统：windows</p>
<p>&emsp;开发环境：pycharm专业版(社区版无法进行web开发)</p>
<p>为了避免学习过程中，出现各种各样的报错，最好都用相同版本的语言，框架等。</p>
<p>django版本和python对应的版本：</p>
<table>
<thead>
<tr>
<th style="text-align:left">django version</th>
<th>python version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.8</td>
<td>2.7，3.2，3.3，3.4，3.5</td>
</tr>
<tr>
<td style="text-align:left">1.9，1.10</td>
<td>2.7，3.4，3.5</td>
</tr>
<tr>
<td style="text-align:left">1.11</td>
<td>2.7，3.4，3.5，3.6</td>
</tr>
<tr>
<td style="text-align:left">2.0</td>
<td>3.4，3.5，3.6</td>
</tr>
<tr>
<td style="text-align:left">2.1</td>
<td>3.5，3.6，3.7</td>
</tr>
</tbody>
</table>
<p><strong>安装虚拟环境：</strong></p>
<p>&emsp;&emsp;在学习之前还要配置一个虚拟环境，给大家讲一下为啥要配置虚拟环境，比如说，如果老板A让你去维护一个用django1.0写个的web项目，而老板B让你维护django1.8版本的项目，而你电脑上却是django2.0版本的，因为版本不同，新旧版本不完全兼容，可能会出现各种未知报错，所以如果没有虚拟环境，还要将2.0的卸载掉，再去装1.0的去维护，然后卸载1.0的安装1.8的，而你之前电脑上有一些项目用django2.0开发的，再去维护又要折腾了，太麻烦了，恰好这个虚拟环境可以解决这种问题，可以在虚拟环境中安装1.0和1.8版本的去维护旧版本的项目，这样就不用来回卸载django了。</p>
<p>安装virtualenv:</p>
<p>pip3 install virtualenv</p>
<p><img src="/images/安装virtualenv.png" alt></p>
<p><strong>创建虚拟环境：</strong></p>
<p>virtualenv [虚拟环境名字name]</p>
<p>运行之后就会在当前文件夹自动生成一个名为name的文件夹</p>
<p><img src="/images/创建虚拟环境.png" alt></p>
<p><img src="/images/自动生成的文件夹.png" alt></p>
<p><strong>进入环境：</strong></p>
<p>虚拟环境创建好以后，就可以进入虚拟环境安装一些第三方包，进入到虚拟环境的Scripts文件夹下，然后执行activate，就进入i虚拟环境了，在虚拟环境中，进行安装三方库或卸载三方库都不会影响到外面的环境。</p>
<p><strong>退出虚拟环境：</strong></p>
<p>退出很简单，只需输入命令：deactivate</p>
<p><img src="/images/进入&amp;退出虚拟环境.png" alt></p>
<p><strong>指定python解释器进行创建虚拟环境：</strong></p>
<p>为什么要指定解释器呢？</p>
<p>因为有些项目需要用指定的解释器版本去维护项目，版本不同，他的一些功能可能维护方式不太一样，指定解释器版本可以减少一些不必要的bug</p>
<p>命令：virtualenv -p C:python37\python.exe [virtualenv]</p>
<p><strong>第二种创建虚拟环境：</strong></p>
<p>virtualenvwrapper</p>
<p><strong>安装虚拟环境：</strong></p>
<p>pip3 install virtualenvwrapper-win(同时会安装virtualenv)</p>
<p><strong>创建虚拟环境：</strong></p>
<p>mkvirtualenv [name]</p>
<p>创建成功之后会在当前目录下自动创建一个名为envs的文件夹，然后你创建的所有虚拟环境都会安装到这个目录下。</p>
<p>如果你想将所有虚拟环境放到自己指定的文件夹，可以这样操作：</p>
<p>在我的电脑—-&gt;右键—-&gt;属性—-&gt;高级系统设置—-&gt;环境变量 中添加一个参数 WORKON_HOME,然后将value值设置成你指定的文件夹路径即可。</p>
<p><strong>切换到某个虚拟环境：</strong></p>
<p>workon [name]</p>
<p><strong>退出虚拟环境：</strong></p>
<p>命令：deactivate</p>
<p><strong>删除某个虚拟环境：</strong></p>
<p>命令：rmvirtualenv [name]</p>
<p><strong>列出所有的虚拟环境：</strong></p>
<p>命令：lsvirtualenv(显示路径)</p>
<p>命令：workon(不显示路径)</p>
<p><strong>进入到虚拟环境的目录：</strong></p>
<p>命令：cdvirtualenv</p>
<p><strong>指定解释器版本创建虚拟环境：</strong></p>
<p>mkvirtual –python==C:\python37\python.exe [name]</p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7-win32安装教程</title>
    <url>/2019/12/03/MySQL5-7-win32%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>mysql是编程中比较热门的一个关系型数据库，现在版本已经更新到了8.X版本了，但是新版本更改了很多东西，不太适合新手一上来就用8.X，不是很友好，还是推荐用5.6或5.7版本的，下面教大家怎样安装5.7.19版本的mysql。<a id="more"></a></p>
<p><strong>1.下载.msi文件。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">永久链接：https://pan.baidu.com/s/1-x7ny6GayxyCYkz2pke26g </span><br><span class="line">提取码：dza1</span><br></pre></td></tr></table></figure>
<p>2.安装。</p>
<p>如果你不更改路径，就直接双击上面下载的文件，一直下一步就ok了，如果你想更该路径，想放在特定的文件夹，那就在安装过程中，有custom选项，点击然后改为自己创建好的文件夹即可。</p>
<p><strong>3.配置环境变量。</strong></p>
<p>新增系统变量：</p>
<p>键名：mysql(自己定义)</p>
<p>值：C:\Program Files\MySQL\MySQL Server 5.7(即自己的mysql安装目录)</p>
<p><img src="/images/新增环境变量.png" alt="新增环境变量"></p>
<p>然后在Path中添加：%mysql%\bin，注意Path中不同值之间的“；”符号不能省略(mysql就是刚新增的键名)</p>
<p><strong>4.配置my.ini文件</strong>。</p>
<p>因为这个版本不自动生成my.ini文件，经常有同学问根据百度某某的教程让修改my.ini文件，我的怎么没有呀，就是因为这个原因。</p>
<p>所以需要自己新建一个.</p>
<p>可以先新建一个my.txt文件，然后通过重命名修改文件后缀为.ini，以前的版本解压后或许会存在my-default.ini文件，但是5.7.19版本没有，因此要自己手动创建该文件.</p>
<p>文件的内容如下：(注意：文件夹之间用“/”而不是“\”,否则在下面的操作中可能会出错)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port = 3306</span><br><span class="line">basedir=C:/Program Files/MySQL/MySQL Server 5.7</span><br><span class="line">datadir=C:/Program Files/MySQL/MySQL Server 5.7/data</span><br><span class="line">max_connections=200</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
<p><img src="/images/pip配置.png" alt="pip配置"></p>
<p>编辑好my.ini文件之后，将my.ini文件放到C:/Program Files/MySQL/MySQL Server 5.7目录下</p>
<p><strong>5..以管理员身份打开cmd命令窗口，将目录切换到MySQL的安装目录的bin目录下。</strong></p>
<p>以管理员方式打开cmd:</p>
<p>​    点击电脑左下角的搜索，输入‘cmd’，然后会出现命令提示符程序，然后鼠标放上面—-&gt;右键—-&gt;以管理员身份进入.</p>
<p><img src="/images/cmd管理员.png" alt="cmd管理员"></p>
<p>将目录切换到MySQL的安装目录的bin目录下:</p>
<p>打开cmd之后，输入:cd C:/Program Files/MySQL/MySQL Server 5.7/bin<strong>(</strong>如果不行将’/‘ 换成 ‘\‘ <strong>)</strong></p>
<p>每次进入还要切换目录比较麻烦，另一种方式就不用每次都要进入bin目录了。</p>
<p>就是配置一下用户环境变量，将bin目录加到环境变量中即可，这样打开cmd，就可以直接进行操作了，不需要进行切换目录了.</p>
<p><img src="/images/bin添加环境变量.png" alt="bin添加环境变量"></p>
<p><strong>6.执行以下语句进行MySQL的安装。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure>
<p> 执行命令后提示：Service successfully installed. 表示安装成功</p>
<p><strong>7.执行以下语句进行MySQL的初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>
<p> 执行命令后会在MySQL的安装目录下生成data目录并创建root用户。</p>
<p> <strong>8.执行以下命令以启动mysql服务。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p> 执行后会有如下提示：<br> MySQL服务正在启动..</p>
<p> MySQL服务已经启动成功。</p>
<p><strong>9.启动MySQL之后，root用户的密码为空，设置密码。</strong></p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p password 新密码</span><br><span class="line">Enter password: 旧密码</span><br></pre></td></tr></table></figure>
<p> 需要输入旧密码时，由于旧密码为空，所以直接回车即可。</p>
<p><strong>10.安装成功！！！大功告成！！！</strong></p>
<p>最后，如果安装过程中出现任何解决不了的问题，下方留言哦。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>this licenseK71U8DBPNE has been cancelled (pycharm)</title>
    <url>/2019/10/15/this%20licenseK71U8DBPNE%20has%20been%20cancelled%20(pycharm)/</url>
    <content><![CDATA[<p>最近使用pycharm的时候，之前还好好的，突然就不行了，弹出个这个错误，’this licenseK71U8DBPNE has been cancelled’,以为只是注册码过期了，就又去找了几个注册码，发现注册码并没有过期，弹出的错误还是同样的错误，就百度了一下借鉴了一下大神的博客，原来问题在这,下面提供两种方法：<a id="more"></a></p>
<p><strong>1.</strong>找到咱们的这个host文件，一般都放在C:\Windows\System32\drivers\etc目录下，打开这个host文件,在最后加上一句代码：0.0.0.0 account.jetbrains.com,如果原文件存在这句代码，会被注释掉，把注释去掉即可，然后重启pycharm 输入激活码即可。</p>
<p>2.前两种如果还是解决不了，，那就使用最后一种一方法了，解决办法是，如果是学生，可以用学校给我们注册的个人教育邮箱去注册，如果不知道，可以问下自己的同学，实在不行，问导员，他应该是知道的，现在pycharm是对学生及老师都是免费使用的，如果你不是学生，需要注册一个edu邮箱：<a href="https://zhidao.baidu.com/question/589038064022759205.html" target="_blank" rel="noopener">点这里</a>.注册之后就可以在激活pycharm时选择buy选项，然后英文根据提示完成操作即可。</p>
<p>以上就是我给大家的对于此问题的一些解决方法，不敢保证能解决所有问题，但还是可以解决大部分人的问题的，感谢支持，如果又哪里有问题或不懂的地方，下方留言哦。</p>
]]></content>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>利用费马小定理求逆元</title>
    <url>/2019/10/13/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>费马小定理：a是不能被质数p整除的正整数，则有a^(p-1)≡ 1 (mod p)</p>
<p>推导：a^(p−1) ≡ 1 (mod p) = a*a^(p−2 )≡ 1 (mod p) ;</p>
<p>则a的逆元 为 a^(p−2)。利用费马小定理求逆元的前提强调p一定是质数。</p>
<p>说这些你可能不太明白，先看一道题就明白了，</p>
<a id="more"></a>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" target="_blank" rel="noopener">HDU1576</a></p>
<p>要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。</p>
<p>Input<br>数据的第一行是一个T，表示有T组数据。<br>每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。</p>
<p>Output<br>对应每组数据输出(A/B)%9973。</p>
<p>Sample Input<br>2<br>1000 53<br>87 123456789</p>
<p>Sample Output<br>7922<br>6060 </p>
<p>如果我们直接求肯定不行 ，所以要利用逆元求解，并且9973（即是上面的p）为质数，</p>
<p>设C是B的逆元，则有B<em>C≡1(mod P)； 推论：(A/B)mod P = (A/B)</em>1mod p = (A/B)<em>B</em>C mod p=A<em>C(mod p); 即A/B的模等于A</em>(B的逆元)的模；l利用费马小定理得出C=B^(p-2);则原式可转化为（A<em>C）%p=（A%p</em>C%p）%p；个人见解，欢迎纠错.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define mod 9973</span><br><span class="line">typedef long long ll;//对 long long重命名 </span><br><span class="line">ll DD(ll a ,ll b)//求解 a^b%mod(因为a^b太大 需利用快速幂求解) </span><br><span class="line">&#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    if(b&lt;0)</span><br><span class="line">    return 0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ll a,b,i;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);</span><br><span class="line">        i=DD(b,(mod-2));//i即为 b的逆元 </span><br><span class="line">    printf(&quot;%lld\n&quot;,(a%mod*i%mod)%mod); //A*C）%p=（A%p*C%p）%p </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python打造淘宝抢购脚本</title>
    <url>/2019/07/31/%E5%88%A9%E7%94%A8python%E6%89%93%E9%80%A0%E6%B7%98%E5%AE%9D%E6%8A%A2%E8%B4%AD%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>说这是一款自动抢购脚本是没问题的，不过其实一款半自动抢购脚本，为什么这么说呢，因为并没有达到完全自动抢购，需要扫码登陆，登陆之后就可以自动抢购了，该脚本主要依赖第三方库selenium自动打开谷歌浏览器进行模拟登陆淘宝。</p>
<p>在进行该程序之前需要做的工作是<a id="more"></a></p>
<p>1.安装谷歌浏览器，也可以用其他浏览器比如火狐等，不过我的代码是通过谷歌实现的。</p>
<p>2.安装第三方库selenium,(通过pip命令比较方便)</p>
<p>3.安装谷歌驱动chomedriver,不会的<a href="https://prestu.github.io/2019/06/04/pytohn%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">点这里</a>.</p>
<p>好了开始放代码喽</p>
<p>可能该代码有所不成熟，且注释不够完善，有空进行补充，如果有问题，请大佬指出，评论在下方，感谢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">##################################################################################################################</span></span><br><span class="line"><span class="comment"># 淘宝抢购脚本                                                                                                    #</span></span><br><span class="line"><span class="comment"># 使用方法：                                                                                                      #</span></span><br><span class="line"><span class="comment">#     1、先将需要抢购的商品放到购物车中（注意购物车中只能放需要抢购的东西，到时抢购的时候会全部提交)                   #</span></span><br><span class="line"><span class="comment">#     2、修改下本脚本中的BUY_TIME值，设定为需要抢购的时间；                                                         #</span></span><br><span class="line"><span class="comment">#     3、执行此脚本，然后等待浏览器打开弹出登陆界面，手机淘宝扫描登陆；                                              #</span></span><br><span class="line"><span class="comment">#     4、脚本开始执行后，会定时刷新防止超时退出，到了设定时间点会自动尝试提交订单                                     #</span></span><br><span class="line"><span class="comment">#     5、抢购时为了防止一次网络拥堵出问题，设置了尝试机制，会不停尝试提交订单，直到提交成功或达到最大重试次数为止       #</span></span><br><span class="line"><span class="comment">#     6、脚本只负责提交订单，之后24小时内需要自行完成付款操作。                                                      #</span></span><br><span class="line"><span class="comment">##################################################################################################################</span></span><br><span class="line">login_sucess=<span class="literal">False</span></span><br><span class="line">retry_login_time=int(<span class="number">0</span>)</span><br><span class="line">max_retry_login_time=int(<span class="number">6</span>)</span><br><span class="line">buy_time=<span class="string">"2019-07-31 20:15:00"</span></span><br><span class="line">buy_time_obj=datetime.datetime.strptime(buy_time,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">now_time=datetime.datetime.now()</span><br><span class="line"><span class="keyword">if</span>(now_time &gt; buy_time_obj):</span><br><span class="line">    print(<span class="string">'抢购时间已过，确认时间是否填写错误'</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'正在打开浏览器...'</span>)</span><br><span class="line">print(<span class="string">'正在尝试登陆...'</span>)</span><br><span class="line">driver=webdriver.Chrome()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_oprator</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> driver.find_element_by_link_text(<span class="string">"亲，请登录"</span>):</span><br><span class="line">            print(<span class="string">'未登录，请点击登录按钮'</span>)</span><br><span class="line">            driver.find_element_by_link_text(<span class="string">'亲，请登录'</span>).click()</span><br><span class="line">            print(<span class="string">'请扫描二维码进行登陆'</span>)</span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'已登录，开始进行跳转...'</span>)</span><br><span class="line">        <span class="keyword">global</span> login_sucess</span><br><span class="line">        <span class="keyword">global</span> retry_login_time</span><br><span class="line">        login_sucess=<span class="literal">True</span></span><br><span class="line">        retry_login_time=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> retry_login_time</span><br><span class="line">    <span class="keyword">while</span> retry_login_time &lt; max_retry_login_time:</span><br><span class="line">        retry_login_time+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'正在尝试登陆次数'</span>+str(retry_login_time))</span><br><span class="line">        login_oprator()</span><br><span class="line">        <span class="keyword">if</span> login_sucess:</span><br><span class="line">            print(<span class="string">'登陆成功'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'等待登陆中...'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> login_sucess:</span><br><span class="line">        print(<span class="string">'规定时间内，未完成扫码登陆，登陆失败...退出程序！！'</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    now=datetime.datetime.now()</span><br><span class="line">    print(<span class="string">'登陆成功'</span>+str(now))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">refrsh_keep_alive</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">'https://cart.taobao.com/cart.htm'</span>)</span><br><span class="line">    print(<span class="string">'刷新购物页面，防止超时...'</span>)</span><br><span class="line">    time.sleep(<span class="number">30</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep_login_and_wait</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"当前距离抢购时间点还有较长时间，开始定时刷新防止登录超时..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        current_time=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">if</span>((buy_time_obj-current_time).seconds&gt;<span class="number">180</span>):</span><br><span class="line">            refrsh_keep_alive()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'抢购时间将近，停止自动刷新，准备进入抢购阶段...'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">"https://cart.taobao.com/cart.htm"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">global</span> submit_success</span><br><span class="line">    submit_success=<span class="number">0</span></span><br><span class="line">    retry_sumit_times=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        now=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">if</span> now&gt;=buy_time_obj:</span><br><span class="line">            print(<span class="string">'到达抢购时间，开始抢购...尝试次数'</span>+str(retry_sumit_times))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> submit_success:</span><br><span class="line">                print(<span class="string">'抢购成功，无需继续抢购...'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> retry_sumit_times&gt;<span class="number">50</span>:</span><br><span class="line">                print(<span class="string">'抢购次数达到上限，停止抢购...'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            retry_sumit_times+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> (driver.find_element_by_id(<span class="string">'J_SelectAll1'</span>)):</span><br><span class="line">                    driver.find_element_by_id(<span class="string">'J_SelectAll1'</span>).click()</span><br><span class="line">                    print(<span class="string">'已选中全选按钮'</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span>(driver.find_element_by_id(<span class="string">'J_Go'</span>)):</span><br><span class="line">                    driver.find_element_by_id(<span class="string">'J_Go'</span>).click()</span><br><span class="line">                    print(<span class="string">'已经点击结算按钮...'</span>)</span><br><span class="line">                    click_button_times=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="keyword">if</span> click_button_times&lt;<span class="number">10</span> <span class="keyword">and</span> driver.find_element_by_link_text(<span class="string">'提交订单'</span>):</span><br><span class="line">                                driver.find_element_by_link_text(<span class="string">'提交订单'</span>).click()</span><br><span class="line">                                print(<span class="string">'已经点击提交订单按钮\n哈哈哈，抢购成功！！！'</span>)</span><br><span class="line">                                exit(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            print(<span class="string">'没有发现提交订单按钮，可能页面没加载出来，重试...'</span>)</span><br><span class="line">                            click_button_times+=<span class="number">1</span></span><br><span class="line">                            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                print(<span class="string">'提交订单失败'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">login()</span><br><span class="line">keep_login_and_wait()</span><br><span class="line">buy()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>统计三国演义中出场次数前十名的人物</title>
    <url>/2019/07/31/%E7%BB%9F%E8%AE%A1%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E4%B8%AD%E5%87%BA%E5%9C%BA%E6%AC%A1%E6%95%B0%E5%89%8D%E5%8D%81%E5%90%8D%E7%9A%84%E4%BA%BA%E7%89%A9/</url>
    <content><![CDATA[<p>利用第三方库jieba库，进行统计《三国演义》中出场次数前十名的任务，</p>
<p>由于较为基础，直接贴代码吧。<a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">excludes = &#123;<span class="string">"将军"</span>,<span class="string">"却说"</span>,<span class="string">"荆州"</span>,<span class="string">"二人"</span>,<span class="string">"不可"</span>,<span class="string">"不能"</span>,<span class="string">"如此"</span>,<span class="string">"商议"</span>,<span class="string">"主公"</span>,<span class="string">"如何"</span>,<span class="string">"军士"</span>,<span class="string">"左右"</span>,<span class="string">"军马"</span>,<span class="string">"引兵"</span>,<span class="string">"次日"</span>,<span class="string">"大喜"</span>,<span class="string">"天下"</span>,<span class="string">"于是"</span>,<span class="string">"东吴"</span>,<span class="string">"今日"</span>,<span class="string">"不敢"</span>,<span class="string">"魏兵"</span>,<span class="string">"陛下"</span>,<span class="string">"人马"</span>,<span class="string">"不知"</span>,<span class="string">"都督"</span>,<span class="string">"一人"</span>,<span class="string">"汉中"</span>&#125;		<span class="comment">#需要删除的无用词汇</span></span><br><span class="line">txt = open(<span class="string">"三国演义.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">'utf-8'</span>).read()<span class="comment">#打开提前下载好的txt文件</span></span><br><span class="line">words  = jieba.lcut(txt)   <span class="comment">#分词</span></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> len(word) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"诸葛亮"</span> <span class="keyword">or</span> word == <span class="string">"孔明曰"</span>:</span><br><span class="line">        rword = <span class="string">"孔明"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"关公"</span> <span class="keyword">or</span> word == <span class="string">"云长"</span>:</span><br><span class="line">        rword = <span class="string">"关羽"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"玄德"</span> <span class="keyword">or</span> word == <span class="string">"玄德曰"</span>:</span><br><span class="line">        rword = <span class="string">"刘备"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"孟德"</span> <span class="keyword">or</span> word == <span class="string">"丞相"</span>:</span><br><span class="line">        rword = <span class="string">"曹操"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rword = word</span><br><span class="line">    counts[rword] = counts.get(rword,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 如果不存在，其次数为零，否则加1</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> excludes:</span><br><span class="line">    <span class="keyword">del</span> counts[word]  <span class="comment">#删除无用词汇，意思就是我们的目的是统计人物出现次数，统计过程中会出现一些不是人物名字的大量词汇，所以要进行删除操作</span></span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)<span class="comment">#对人物次数，进行逆向排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;"</span>.format(word, count))<span class="comment">#对统计得到的前十名人物进行格式化输出</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python编写简易的名片管理系统</title>
    <url>/2019/07/31/%E5%88%A9%E7%94%A8python%E7%BC%96%E5%86%99%E7%9A%84%E7%AE%80%E6%98%93%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>利用python实现简单的名片的添加，修改，查询，删除等操作。</p>
<p>此代码仅限小白练手哦，大佬忽略就好了(因为代码太水了 23333)</p>
<p>如遇到bug或有任何疑问，在下方评论留言，感谢！<a id="more"></a></p>
<p><strong>注意：</strong></p>
<p>为了结果更清晰，下面将输出的内容进行了简单的颜色处理</p>
<p>格式：</p>
<p>​    开头部分：\033[显示方式;前景色;背景色m </p>
<p>​    结尾部分：\033[0m</p>
<p>关于字体颜色，更详细的内容请点击<a href="https://prestu.github.io/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/" target="_blank" rel="noopener">此处</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line">MingPian=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入姓名(输入0退出添加):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            print(<span class="string">'\033[0;31;1m此用户已存在，请重新输入！\033[0m'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            MingPian[name]=&#123;&#125;</span><br><span class="line">            sex = input(<span class="string">'性别:'</span>)</span><br><span class="line">            num=input(<span class="string">'联系方式:'</span>)</span><br><span class="line">            MingPian[name][<span class="string">'sex'</span>] = sex</span><br><span class="line">            MingPian[name][<span class="string">'num'</span>] = num</span><br><span class="line">            print(<span class="string">'\033[0;32;1m添加成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要删除的名字(输入0退出删除):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            <span class="keyword">del</span> MingPian[name]</span><br><span class="line">            print(<span class="string">'\033[0;32;1m删除成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你删除的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Modify</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要修改的名字(输入0退出修改):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            sex = input(<span class="string">'性别(M/F):'</span>)</span><br><span class="line">            num = input(<span class="string">'联系方式:'</span>)</span><br><span class="line">            MingPian[name][<span class="string">'sex'</span>]=sex</span><br><span class="line">            MingPian[name][<span class="string">'num'</span>]=num</span><br><span class="line">            print(<span class="string">'\033[0;32;1m修改成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你修改的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要查询的名字(输入0退出查询):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            print(<span class="string">'\033[0;35;1m'</span>)</span><br><span class="line">            print(MingPian[name])</span><br><span class="line">            print(<span class="string">'\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你查询的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Look</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> MingPian.__len__():</span><br><span class="line">        print(<span class="string">'\033[0;35;1m'</span>)</span><br><span class="line">        print(MingPian)</span><br><span class="line">        print(<span class="string">'\033[0m'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'\033[0;31;1m此管理系统已空！\033[0m'</span>)</span><br><span class="line">msg = <span class="string">'''=====名片管理系统=====</span></span><br><span class="line"><span class="string">*    1. 添加名片     *</span></span><br><span class="line"><span class="string">*    2. 删除名片     *  </span></span><br><span class="line"><span class="string">*    3. 修改名片     *</span></span><br><span class="line"><span class="string">*    4. 查询名片     * </span></span><br><span class="line"><span class="string">*    5. 查询全部信息 *</span></span><br><span class="line"><span class="string">*    6. 退出名片     *</span></span><br><span class="line"><span class="string">*********************'''</span></span><br><span class="line">print(<span class="string">'\033[0;34;1m'</span>)</span><br><span class="line">print(msg)</span><br><span class="line">print(<span class="string">'\033[0m'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msg1 = <span class="string">'''&gt;&gt;&gt;1. 添加 2. 删除  3. 修改 4. 查询 5. 查询全部 6. 退出名片&lt;&lt;&lt;'''</span></span><br><span class="line">        Input=input(<span class="string">'\033[0;30;46m请输入要操作的序号:\033[0m'</span>)</span><br><span class="line">        Input=int(Input)</span><br><span class="line">        <span class="keyword">if</span> Input==<span class="number">6</span>:</span><br><span class="line">            print(<span class="string">'[6. 退出名片]'</span>)</span><br><span class="line">            print(<span class="string">'\033[0;31;1m程序已退出...\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[1. 添加名片]\033[0m'</span>)</span><br><span class="line">            Add()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">2</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[2. 删除名片]\033[0m'</span>)</span><br><span class="line">            Delete()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">3</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[3. 修改名片]\033[0m'</span>)</span><br><span class="line">            Modify()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">4</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[4. 查询名片]\033[0m'</span>)</span><br><span class="line">            Search()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[5. 查询全部信息]\033[0m'</span>)</span><br><span class="line">            Look()</span><br><span class="line">        print(<span class="string">'\033[0;34;1m'</span>)</span><br><span class="line">        print(msg1)</span><br><span class="line">        print(<span class="string">'\033[0m'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'\033[0;31;1m输入有误!  请重新输入!\033[0m'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式的一些实例</title>
    <url>/2019/07/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>实例1.</strong></p>
<p>验证用户输入的密码是否符合要求，密码的要求是：</p>
<p>(1)不得少于8个字符.</p>
<p>(2) 只能包含大小写字母、数字和下划线.</p>
<p>(3) 大写字母、小写字母和数字这三种类型至少要包含两种.<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">print(&apos;\033[1;32;1m&apos;)</span><br><span class="line">print(&apos;请输入密码：\n1. 不得少于8个字符\n2.只能包含大小写字母，数字和下划线\n3.大写字母，小写字母和数字至少要包含两种&apos;)</span><br><span class="line">print(&apos;\033[0m&apos;) </span><br><span class="line">while True:</span><br><span class="line">    password=input(&apos;请输入:&apos;)</span><br><span class="line">    if len(password) &lt; 8:</span><br><span class="line">        print(&apos;输入错误!(不得少于8个字符)，请重新输入!&apos;)</span><br><span class="line">    else:</span><br><span class="line">        word=re.search(&apos;[\w_]+&apos;,password)</span><br><span class="line">        if word.group()==password:</span><br><span class="line">            a=b=c=int(0)</span><br><span class="line">            if re.findall(&apos;[a-z]&apos;,password) :</span><br><span class="line">                a=1</span><br><span class="line">            if re.findall(&apos;[A-Z]&apos;,password):</span><br><span class="line">                b=1</span><br><span class="line">            if re.findall(&apos;[\d]&apos;,password):</span><br><span class="line">                c=1</span><br><span class="line">            if a+b+c&gt;=2:</span><br><span class="line">                print(&apos;密码正确!程序结束!&apos;)</span><br><span class="line">                exit()</span><br><span class="line">            else:</span><br><span class="line">                print(&apos;密码有误，重新输入!&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;2密码有误，重新输入!&apos;)</span><br></pre></td></tr></table></figure>
<p>注意：\033[0m 是控制字体颜色的代码格式，详见<a href="https://prestu.github.io/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/" target="_blank" rel="noopener">点这里</a>。</p>
<p><strong>实例2.</strong></p>
<p>找出字符串”abcd123d123aad1v123“中以a开头，以123字符串结尾，但是中间不出现123这个字符串的字符串。结果应为:abcd123和ad1v123。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'abcd123d123ad1v123'</span></span><br><span class="line">x = re.compile(<span class="string">r'a.*?123'</span>)</span><br><span class="line">print(x.findall(s))</span><br></pre></td></tr></table></figure>
<p><strong>实例3.</strong></p>
<p>找出”a123abvpd123dpf12ab123sabd123f1123abc”中以123字符串开头，以ab字符串结尾，但是中间不出现123和“p”这两个字符串的子字符串。结果应为:123ab和123sab和123ab。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = re.compile(<span class="string">r'123[^p|123]*?ab'</span>)</span><br><span class="line">s = <span class="string">'a123abvpd123d“p”f12ab123sabd123f1123abc'</span></span><br><span class="line">print(x.findall(s))</span><br></pre></td></tr></table></figure>
<p><strong>实例4.</strong></p>
<p>匹配电话号码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p = re.compile(r&apos;\d&#123;3&#125;-\d&#123;6&#125;&apos;)</span><br><span class="line">print(p.findall(&apos;010-628888&apos;))</span><br></pre></td></tr></table></figure>
<p><strong>实例5.</strong></p>
<p>匹配IP.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x=re.search(r&quot;(([01]?\d?\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([01]?\d?\d|2[0-4]\d|25[0-5]\.)&quot;,&quot;192.168.1.1&quot;)</span><br><span class="line">print(x.group())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式中一些特殊构造</title>
    <url>/2019/07/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p><strong>特殊构造</strong></p>
<p>(?:…) (…)不分组版本,用于使用 | 或者后接数量词<br>(?iLmsux) iLmsux的每个字符代表一个匹配模式,只能用在正则表达式的开头,可选多个<br>(?#…) #号后的内容将作为注释<br>(?=…) 之后的字符串内容需要匹配表达式才能成功匹配<br>(?!…) 之后的字符串不匹配表达式才能成功<a id="more"></a><br>(?(?(?(id/name) yes |no) 如果编号为id/名字为name的组匹配到字符串,则需要匹配yes,否则匹配no,no可以省略</p>
<p><strong>“(?:…)” ：()里面有?:表示该()不是分组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;a(?:bc)&apos;)</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.match(&apos;abc&apos;).groups()   #显示不出分组</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p><strong>“(?=…)”：匹配…表达式，返回。对后进行匹配，总是对后面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;\w(?=\d)&apos;)  #匹配表达式\d，返回数字的前一位，\w：单词字符[A-Za-z0-9]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc1 def1 xyz1&apos;)</span><br><span class="line">[&apos;c&apos;, &apos;f&apos;, &apos;z&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;) #匹配数字的前一位，列表返回</span><br><span class="line">[&apos;y&apos;, &apos;2&apos;, &apos;0&apos;, &apos;1&apos;, &apos;3&apos;, &apos;0&apos;, &apos;6&apos;, &apos;2&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;\w+(?=\d)&apos;)</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc1,def1,xyz1&apos;)     #匹配最末数字的前字符串，列表返回</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc2&apos;, &apos;def3&apos;, &apos;xyz4&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;)</span><br><span class="line">[&apos;zhoujy2013062&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?=\d)&apos;)    #[A-Za-z],匹配字母,可以用其他的正则方法</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123&apos;) #匹配后面带有数字的字符串，列表返回</span><br><span class="line">[&apos;zhoujy&apos;, &apos;hangzhou&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?!…)” 不匹配…表达式，返回。对后进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?!\d)&apos;)    #[A-Za-z],匹配字母,可以用其他的正则方法</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;) #匹配后面不是数字的字符串，列表返回</span><br><span class="line">[&apos;zhouj&apos;, &apos;hangzho&apos;, &apos;binjian&apos;]  #有疑问不应该是zhoujy吗？，因为y后面是数字，所以匹配到j终止</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;ab&apos;, &apos;de&apos;, &apos;xy&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?&lt;=…)”：匹配…表达式，总是对前面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;=\d)[A-Za-z]+&apos;)   #匹配前面是数字的字母</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;1abc21,2def31,3xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)</span><br><span class="line">[&apos;hangzhou&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?&lt;!…)”：不匹配…表达式，总是对前面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;!\d)[A-Za-z]+&apos;)   #匹配前面不是数字的字母</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)</span><br><span class="line">[&apos;zhoujy&apos;, &apos;angzhou&apos;, &apos;binjiang&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?i)…”: …为表达式，这里就介绍下i参数：大小写区分匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?i)abc&apos;)      #(?i) 不区分大小写</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)</span><br><span class="line">[&apos;ABC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBc&apos;)</span><br><span class="line">[&apos;aBc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)</span><br><span class="line">[&apos;aBC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;abc&apos;,re.I)      #re.I 作为参数使用，推荐</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)</span><br><span class="line">[&apos;aBC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)</span><br><span class="line">[&apos;ABC&apos;]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的正则表达式re</title>
    <url>/2019/07/27/python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>，又称规则表达式<strong>。</strong>(英语:Regular Expression，在代码中常简写为regex、regexp或RE)，计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<p>​    许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在<a href="https://baike.so.com/doc/5106225-5334848.html" target="_blank" rel="noopener">Perl</a>中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件(例如sed和<a href="https://baike.so.com/doc/5454248-5692635.html" target="_blank" rel="noopener">grep</a>)普及开的。正则表达式通常缩写成”regex”，单数有regexp、regex，复数有regexps、regexes、regexen。<a id="more"></a></p>
<p>​    正则表达式是对字符串(包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为”元字符”))操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<p>正则表达式在很多语言里都支持，python也不例外，re模块就是正则表达式的应用.</p>
<p>1、正则表达式元字符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">\	转义字符，将后边紧跟着的字符变成特殊字符，或将后边的特殊字符变成普通字符</span><br><span class="line"></span><br><span class="line">如：在正则表达式中，"\n"换行符，"\\"则代表一个普通字符"\"</span><br><span class="line"></span><br><span class="line">^	匹配第一行行首，匹配多行需要传参 flags=re.MULTILINE</span><br><span class="line">$	匹配最后一行行尾，匹配多行需要传参 flags=re.MULTILINE</span><br><span class="line">.	除"\r""\n"外，匹配任意的单个字符，要使"."匹配换行符，flags=re.DOTALL或re.S</span><br><span class="line">|	或，如 "aaa|bbb|ccc"，表示"aaa","bbb","ccc"三选一</span><br><span class="line">?	匹配前边的子表达式0次或1次，等价于&#123;0,1&#125;,非贪婪模式</span><br><span class="line">+	匹配前边的子表达式1次或多次，等价于&#123;1,&#125;</span><br><span class="line">*	匹配前边的子表达式0次或多次,，等价于&#123;0,&#125;</span><br><span class="line">&#123;&#125;	&#123;n&#125;匹配前边的子表达式n次，&#123;n,&#125;匹配前边的子表达式至少n次，&#123;n,m&#125;匹配前边的子表达式n~m次</span><br><span class="line">()	分组，从1开始，从左至右数"("为第几组，下标0为全部分组</span><br><span class="line">[]	字符集匹配[]中的人一个字符，之匹配一次，如[abc]：表示"a","b","c"三选一。也可以给定范围(必须是连续的才行)，如[a-z]：表示a到z任意一个字符。</span><br><span class="line"></span><br><span class="line">还可以取反，如[^abc]：除"a","b","c"外的任意字符。注：[]中只有"^","-","\"三个特殊字符，其中"\"代表转义字符，其它的都代表原本普通的字符，如:[.]只是一个普通的点字符</span><br><span class="line">注：要使用元字符本身的普通字符，请使用转义字符转义一下，如 ："\(" 在正则表达式中代表普通给"("字符，其它的雷同</span><br></pre></td></tr></table></figure>
<p>分组的用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">(\num)	引用指定第几分组的值</span><br><span class="line">(?P<span class="tag">&lt;<span class="name">name</span>&gt;</span>)	指定分组别名"name"</span><br><span class="line">(?P=name)	引用指定别名的分组的值</span><br><span class="line">(?:)	相当于去分组化，变成"与"()子集，如:"abc(?:qqq|www)"--&gt;相当于"abcqqq|abcwww"</span><br></pre></td></tr></table></figure>
<p>2、预定义字符集</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">\b	匹配一个单词边界，也就是指单词和空格间的位置，其它特殊字符也可以是单词的边界，如"#","$","&amp;","*"等</span><br><span class="line">\B	匹配非单词边界</span><br><span class="line">\d	匹配一个数字字符。等价于[0-9]</span><br><span class="line">\D	匹配一个非数字字符。等价于[^0-9]</span><br><span class="line">\s	匹配任何不可见字符，包括空格、制表符、换页符等，等价于[ \f\n\r\t\v]</span><br><span class="line">\S	匹配任何可见字符。等价于[^ \f\n\r\t\v]</span><br><span class="line">\w	匹配包括下划线的任何单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[A-Za-z0-9_]”，还包含汉字等它国字符</span><br><span class="line">\W	匹配任何非单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[^A-Za-z0-9_]”，还包含汉字等它国字符</span><br></pre></td></tr></table></figure>
<p>3、re模块常用函数</p>
<table>
<thead>
<tr>
<th>re.A 或 re.ASCII</th>
<th>使用ASCII字符集进行匹配(不常用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I 或 re.IGNORECASE</td>
<td>忽略大小写匹配</td>
</tr>
<tr>
<td>re.L 或 re.LOCALE</td>
<td>使用当前预定字符类 \w \W \b \B \s \S 取决于当前区域设定(不常用)</td>
</tr>
<tr>
<td>re.U 或 re.UNICODE</td>
<td>使用Unicode字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性(不常用)</td>
</tr>
<tr>
<td>re.M 或 re.MULTILINE</td>
<td>多行匹配，使”^”,”$”可以在每一行中都进行匹配</td>
</tr>
<tr>
<td>re.S 或 re.DOTALL</td>
<td>使 “.” 可以匹配换行符”\r”,”\n”</td>
</tr>
<tr>
<td>re.X 或 re.VERBOSE</td>
<td>去掉正则表达式中的所有空格符(不常用)</td>
</tr>
</tbody>
</table>
<p><strong>1）re.compile(pattern, flags=0) :创建模式对象</strong></p>
<p>编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）</p>
<p>pattern: 编译时用的表达式字符串，flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等,(常用的flags即re模块常用函数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; rg = re.compile(r&quot;\d+&quot;, flags=0)</span><br><span class="line">&gt;&gt;&gt; re.findall(rg, &quot;a1bb22ccc333&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;22&apos;, &apos;333&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>2）re.findall(pattern, string, flags=0)</strong></p>
<p>re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(r"hello", "hello world hello")  # 普通匹配</span><br><span class="line">['hello', 'hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"^hello", "hello world hello")  # 匹配开头</span><br><span class="line">['hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"^hello", "hello world\nhello", flags=re.MULTILINE)  # 多行匹配开头</span><br><span class="line">['hello', 'hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"hello$", "hello world hello")  # 匹配结尾</span><br><span class="line">['hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\d+", "aaa111bbb222ccc333")  # 匹配数字</span><br><span class="line">['111', '222', '333']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\d&#123;2&#125;", "aaa111bbb222ccc333")  # 匹配两位的数字</span><br><span class="line">['11', '22', '33']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"ab|cd", "ab000cd00")  # 匹配"ab"或"cd"</span><br><span class="line">['ab', 'cd']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\(", "ab(cd"))  # 匹配"("</span><br><span class="line">['(']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"(abc)+", "abcabcabc")  # 想要匹配多个"abc"，使用分组时会优先把分组的内容返回</span><br><span class="line">['abc']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"(?:abc)+", "abcabcabc")  # 想要匹配多个"abc"，(?:)把分组去掉，变成一个普通的字符串</span><br><span class="line">['abcabcabc']</span><br></pre></td></tr></table></figure>
<p><strong>3）re.search(pattern, string, flags=0)</strong></p>
<p>在字符串中寻找模式,只要找到一个符合条件的就返回.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 5), match=&apos;hello&apos;&gt;  # 可以看到只返回了第一个&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;).group()</span><br><span class="line">&apos;hello&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(abc) \1&quot;, &quot;abc abc&quot;).group()  # \1 引用分组1的值</span><br><span class="line">&apos;abc abc&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;abc) (?P=name)&quot;, &quot;abc abc&quot;).group()  # (?P=name) 引用分组别名&quot;name&quot;的值</span><br><span class="line">&apos;abc abc&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group()</span><br><span class="line">&apos;zhansan 23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(0)  # 分组0--即匹配的结果</span><br><span class="line">&apos;zhansan 23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(1)  # 分组1的值</span><br><span class="line">&apos;zhansan&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(2)  # 分组2的值</span><br><span class="line">&apos;23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;name&quot;)  # 分组别名name的值</span><br><span class="line">&apos;zhansan&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;age&quot;)  # 分组别名age的值</span><br><span class="line">&apos;23&apos;</span><br></pre></td></tr></table></figure>
<p><strong>4）re.match(pattern, string, flags=0)</strong></p>
<p>在字符串开始处匹配模式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r"abc"</span>, <span class="string">"abcooooo"</span>).group()</span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line">&gt;&gt;&gt;m = re.search(<span class="string">'asd'</span>,<span class="string">'ASDasd'</span>)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0xb72cd6e8</span>&gt; <span class="comment">#匹配到了，返回MatchObject（True）</span></span><br><span class="line">&gt;&gt;&gt;m = re.search(<span class="string">'asd'</span>,<span class="string">'ASDASD'</span>)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line"><span class="literal">None</span>   <span class="comment">#没有匹配到，返回None（False）</span></span><br></pre></td></tr></table></figure>
<p><strong>5）re.finditer(pattern, string, flags=0)</strong></p>
<p>finditer与findall相似，只不过finditer返回一个迭代器,通过group()可以获取值,搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iter = re.finditer(<span class="string">r'\d+'</span>,<span class="string">'12 drumm44ers drumming, 11 ... 10 ...'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter:</span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">20</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    print(i.group())</span><br><span class="line">    print(i.span())</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&apos;12&apos;&gt;</span><br><span class="line">12</span><br><span class="line">(0, 2)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(8, 10), match=&apos;44&apos;&gt;</span><br><span class="line">44</span><br><span class="line">(8, 10)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(24, 26), match=&apos;11&apos;&gt;</span><br><span class="line">11</span><br><span class="line">(24, 26)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(31, 33), match=&apos;10&apos;&gt;</span><br><span class="line">10</span><br><span class="line">(31, 33)</span><br></pre></td></tr></table></figure>
<p><strong>6）re.sub(pattern, repl, string, count=0, flags=0)</strong></p>
<p>sub按照给定的规则将string字符串中的相应的片段替换为repl，count 最多替换的次数，count=0默认为全部替换，返回替换后的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r"\d+"</span>, <span class="string">"$"</span>, <span class="string">"aaa1bb2ccc333"</span>)  <span class="comment"># 将连续的数字变成"$"</span></span><br><span class="line"><span class="string">'aaa$bb$ccc$'</span></span><br></pre></td></tr></table></figure>
<p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。</p>
<p>如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</span><br><span class="line">print(re.sub(r&apos;\s+&apos;, lambda m:&apos;[&apos;+m.group(0)+&apos;]&apos;, text,0))</span><br><span class="line">执行结果如下：</span><br><span class="line">JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on...</span><br></pre></td></tr></table></figure>
<p><strong>7）re.subn(pattern, repl, string, count=0, flags=0)</strong></p>
<p>返回替换次数，与sub相似，count 最多替换的次数，count=0默认为全部替换，返回 一个元组，下标0为替换后的字符串，下标1成功替换的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaabbccc&quot;)</span><br><span class="line">2 (&apos;aaabbccc&apos;, 0)  #未出现替换</span><br><span class="line">3 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;)</span><br><span class="line">4 (&apos;aaa$bb$ccc&apos;, 2)   #成功替换了两次</span><br><span class="line">5 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 1)  # 最多替换1次</span><br><span class="line">6 (&apos;aaa$bb22ccc&apos;, 1)</span><br><span class="line">7 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 10)  # 最多替换10次</span><br><span class="line">8 (&apos;aaa$bb$ccc&apos;, 2)  # 成功替换2次</span><br></pre></td></tr></table></figure>
<p><strong>8）re.split(pattern, string, maxsplit=0, flags=0)</strong></p>
<p>通过给定规则，将string进行切割，maxsplit最多切割次数，maxsplit=0默认全部切割，返回一个列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &gt;&gt;&gt; re.split(r&quot;@&quot;, &quot;a#b#c#d#e&quot;)  # 没有找到&quot;@&quot;，不切割</span><br><span class="line">2 [&apos;a#b#c#d#e&apos;]</span><br><span class="line">3 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;)  # 按&quot;#&quot;对字符串进行切割</span><br><span class="line">4 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">5 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;, 2)  # 按&quot;#&quot;对字符串进行切割，最多切割2次</span><br><span class="line">6 [&apos;a&apos;, &apos;b&apos;, &apos;c#d#e&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>9）group：获取子模式(组)的匹配项</strong></p>
<p>match和search一旦匹配成功，就是一个match object对象，需要用group()才可以打印匹配到的字符串。</p>
<p>b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常<br>c.groups（）方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;pat = re.compile(r&apos;www\.(.*)\.(.*)&apos;)    #用()表示1个组，2个组</span><br><span class="line">&gt;&gt;&gt;m = pat.match(&apos;www.dxy.com&apos;)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line">&lt;re.Match object; span=(0, 11), match=&apos;www.dxy.com&apos;&gt;</span><br><span class="line">&gt;&gt;&gt;m.group()                 #默认为0，表示匹配整个字符串  </span><br><span class="line">&apos;www.dxy.com&apos;</span><br><span class="line">&gt;&gt;&gt;m.group(1)                 #返回给定组1匹配的子字符串</span><br><span class="line">&apos;dxy&apos;</span><br><span class="line">&gt;&gt;&gt;m.group(2)</span><br><span class="line">&apos;com&apos;</span><br><span class="line">&gt;&gt;&gt;m.groups()</span><br><span class="line">(&apos;dxy&apos;, &apos;com&apos;)</span><br><span class="line">&gt;&gt;&gt;m.start(2)                 #组2开始的索引</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt;m.end(2)                  #组2结束的索引</span><br><span class="line">11</span><br><span class="line">&gt;&gt;&gt;m.span(2)                 #组2开始、结束的索引</span><br><span class="line">(8, 11)</span><br></pre></td></tr></table></figure>
<p><strong>10)贪婪匹配与非贪婪匹配</strong></p>
<p>贪婪匹配，也就是尽可能多的匹配，后面加?号使其变成惰性匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = re.findall(r&quot;a(\d+?)&quot;,&apos;a23b&apos;)</span><br><span class="line">print(a)</span><br><span class="line">b = re.findall(r&quot;a(\d+)&quot;,&apos;a23b&apos;)</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">[&apos;2&apos;]</span><br><span class="line">[&apos;23&apos;]</span><br><span class="line">a = re.match(&apos;&lt;(.*)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()</span><br><span class="line">print(a)</span><br><span class="line">b = re.match(&apos;&lt;(.*?)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">&lt;H1&gt;title&lt;H1&gt;</span><br><span class="line">&lt;H1&gt;</span><br></pre></td></tr></table></figure>
<p><strong>最后：</strong>用flags时遇到的小坑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(re.split(&apos;a&apos;,&apos;1A1a2A3&apos;,re.I))#输出结果并未能区分大小写</span><br><span class="line">这是因为re.split(pattern，string，maxsplit,flags)默认是四个参数，</span><br><span class="line">当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用。</span><br><span class="line">如果想让这里的re.I起作用，写成flags=re.I即可。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器设置字体大小颜色</title>
    <url>/2019/07/22/Markdown%E7%BC%96%E8%BE%91%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p><strong>Markdown</strong>是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！</p>
<p>  <strong>CSDN-markdown</strong>编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、<strong>内嵌HTML</strong>等等）！对，就是<strong>内嵌HTML</strong>，接下来要讲的功能就需要使用<strong>内嵌HTML</strong>的方法来实现。<a id="more"></a></p>
<p><strong>字体，字号和颜色:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=#00ffff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>呈现效果如下：</strong></p>
<font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="7" face="黑体">color=#0099ff</font><br><font color="#00ffff" size="72">color=#00ffff</font><br><font color="gray" size="72">color=gray</font>

<p><strong>颜色对应表：</strong></p>
<table>
<thead>
<tr>
<th>颜色名</th>
<th>十六进制颜色值</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>AliceBlue</td>
<td>#F0F8FF</td>
<td>rgb(240, 248, 255)</td>
</tr>
<tr>
<td>AntiqueWhite</td>
<td>#FAEBD7</td>
<td>rgb(250, 235, 215)</td>
</tr>
<tr>
<td>Aqua</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
</tr>
<tr>
<td>Aquamarine</td>
<td>#7FFFD4</td>
<td>rgb(127, 255, 212)</td>
</tr>
<tr>
<td>Azure</td>
<td>#F0FFFF</td>
<td>rgb(240, 255, 255)</td>
</tr>
<tr>
<td>Beige</td>
<td>#F5F5DC</td>
<td>rgb(245, 245, 220)</td>
</tr>
<tr>
<td>Bisque</td>
<td>#FFE4C4</td>
<td>rgb(255, 228, 196)</td>
</tr>
<tr>
<td>Black</td>
<td>#000000</td>
<td>rgb(0, 0, 0)</td>
</tr>
<tr>
<td>BlanchedAlmond</td>
<td>#FFEBCD</td>
<td>rgb(255, 235, 205)</td>
</tr>
<tr>
<td>Blue</td>
<td>#0000FF</td>
<td>rgb(0, 0, 255)</td>
</tr>
<tr>
<td>BlueViolet</td>
<td>#8A2BE2</td>
<td>rgb(138, 43, 226)</td>
</tr>
<tr>
<td>Brown</td>
<td>#A52A2A</td>
<td>rgb(165, 42, 42)</td>
</tr>
<tr>
<td>BurlyWood</td>
<td>#DEB887</td>
<td>rgb(222, 184, 135)</td>
</tr>
<tr>
<td>CadetBlue</td>
<td>#5F9EA0</td>
<td>rgb(95, 158, 160)</td>
</tr>
<tr>
<td>Chartreuse</td>
<td>#7FFF00</td>
<td>rgb(127, 255, 0)</td>
</tr>
<tr>
<td>Chocolate</td>
<td>#D2691E</td>
<td>rgb(210, 105, 30)</td>
</tr>
<tr>
<td>Coral</td>
<td>#FF7F50</td>
<td>rgb(255, 127, 80)</td>
</tr>
<tr>
<td>CornflowerBlue</td>
<td>#6495ED</td>
<td>rgb(100, 149, 237)</td>
</tr>
<tr>
<td>Cornsilk</td>
<td>#FFF8DC</td>
<td>rgb(255, 248, 220)</td>
</tr>
<tr>
<td>Crimson</td>
<td>#DC143C</td>
<td>rgb(220, 20, 60)</td>
</tr>
<tr>
<td>Cyan</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
</tr>
<tr>
<td>DarkBlue</td>
<td>#00008B</td>
<td>rgb(0, 0, 139)</td>
</tr>
<tr>
<td>DarkCyan</td>
<td>#008B8B</td>
<td>rgb(0, 139, 139)</td>
</tr>
<tr>
<td>DarkGoldenRod</td>
<td>#B8860B</td>
<td>rgb(184, 134, 11)</td>
</tr>
<tr>
<td>DarkGray</td>
<td>#A9A9A9</td>
<td>rgb(169, 169, 169)</td>
</tr>
<tr>
<td>DarkGreen</td>
<td>#006400</td>
<td>rgb(0, 100, 0)</td>
</tr>
<tr>
<td>DarkKhaki</td>
<td>#BDB76B</td>
<td>rgb(189, 183, 107)</td>
</tr>
<tr>
<td>DarkMagenta</td>
<td>#8B008B</td>
<td>rgb(139, 0, 139)</td>
</tr>
<tr>
<td>DarkOliveGreen</td>
<td>#556B2F</td>
<td>rgb(85, 107, 47)</td>
</tr>
<tr>
<td>Darkorange</td>
<td>#FF8C00</td>
<td>rgb(255, 140, 0)</td>
</tr>
<tr>
<td>DarkOrchid</td>
<td>#9932CC</td>
<td>rgb(153, 50, 204)</td>
</tr>
<tr>
<td>DarkRed</td>
<td>#8B0000</td>
<td>rgb(139, 0, 0)</td>
</tr>
<tr>
<td>DarkSalmon</td>
<td>#E9967A</td>
<td>rgb(233, 150, 122)</td>
</tr>
<tr>
<td>DarkSeaGreen</td>
<td>#8FBC8F</td>
<td>rgb(143, 188, 143)</td>
</tr>
<tr>
<td>DarkSlateBlue</td>
<td>#483D8B</td>
<td>rgb(72, 61, 139)</td>
</tr>
<tr>
<td>DarkSlateGray</td>
<td>#2F4F4F</td>
<td>rgb(47, 79, 79)</td>
</tr>
<tr>
<td>DarkTurquoise</td>
<td>#00CED1</td>
<td>rgb(0, 206, 209)</td>
</tr>
<tr>
<td>DarkViolet</td>
<td>#9400D3</td>
<td>rgb(148, 0, 211)</td>
</tr>
<tr>
<td>DeepPink</td>
<td>#FF1493</td>
<td>rgb(255, 20, 147)</td>
</tr>
<tr>
<td>DeepSkyBlue</td>
<td>#00BFFF</td>
<td>rgb(0, 191, 255)</td>
</tr>
<tr>
<td>DimGray</td>
<td>#696969</td>
<td>rgb(105, 105, 105)</td>
</tr>
<tr>
<td>DodgerBlue</td>
<td>#1E90FF</td>
<td>rgb(30, 144, 255)</td>
</tr>
<tr>
<td>Feldspar</td>
<td>#D19275</td>
<td>rgb(209, 146, 117)</td>
</tr>
<tr>
<td>FireBrick</td>
<td>#B22222</td>
<td>rgb(178, 34, 34)</td>
</tr>
<tr>
<td>FloralWhite</td>
<td>#FFFAF0</td>
<td>rgb(255, 250, 240)</td>
</tr>
<tr>
<td>ForestGreen</td>
<td>#228B22</td>
<td>rgb(34, 139, 34)</td>
</tr>
<tr>
<td>Fuchsia</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
</tr>
<tr>
<td>Gainsboro</td>
<td>#DCDCDC</td>
<td>rgb(220, 220, 220)</td>
</tr>
<tr>
<td>GhostWhite</td>
<td>#F8F8FF</td>
<td>rgb(248, 248, 255)</td>
</tr>
<tr>
<td>Gold</td>
<td>#FFD700</td>
<td>rgb(255, 215, 0)</td>
</tr>
<tr>
<td>GoldenRod</td>
<td>#DAA520</td>
<td>rgb(218, 165, 32)</td>
</tr>
<tr>
<td>Gray</td>
<td>#808080</td>
<td>rgb(128, 128, 128)</td>
</tr>
<tr>
<td>Green</td>
<td>#008000</td>
<td>rgb(0, 128, 0)</td>
</tr>
<tr>
<td>GreenYellow</td>
<td>#ADFF2F</td>
<td>rgb(173, 255, 47)</td>
</tr>
<tr>
<td>HoneyDew</td>
<td>#F0FFF0</td>
<td>rgb(240, 255, 240)</td>
</tr>
<tr>
<td>HotPink</td>
<td>#FF69B4</td>
<td>rgb(255, 105, 180)</td>
</tr>
<tr>
<td>IndianRed</td>
<td>#CD5C5C</td>
<td>rgb(205, 92, 92)</td>
</tr>
<tr>
<td>Indigo</td>
<td>#4B0082</td>
<td>rgb(75, 0, 130)</td>
</tr>
<tr>
<td>Ivory</td>
<td>#FFFFF0</td>
<td>rgb(255, 255, 240)</td>
</tr>
<tr>
<td>Khaki</td>
<td>#F0E68C</td>
<td>rgb(240, 230, 140)</td>
</tr>
<tr>
<td>Lavender</td>
<td>#E6E6FA</td>
<td>rgb(230, 230, 250)</td>
</tr>
<tr>
<td>LavenderBlush</td>
<td>#FFF0F5</td>
<td>rgb(255, 240, 245)</td>
</tr>
<tr>
<td>LawnGreen</td>
<td>#7CFC00</td>
<td>rgb(124, 252, 0)</td>
</tr>
<tr>
<td>LemonChiffon</td>
<td>#FFFACD</td>
<td>rgb(255, 250, 205)</td>
</tr>
<tr>
<td>LightBlue</td>
<td>#ADD8E6</td>
<td>rgb(173, 216, 230)</td>
</tr>
<tr>
<td>LightCoral</td>
<td>#F08080</td>
<td>rgb(240, 128, 128)</td>
</tr>
<tr>
<td>LightCyan</td>
<td>#E0FFFF</td>
<td>rgb(224, 255, 255)</td>
</tr>
<tr>
<td>LightGoldenRodYellow</td>
<td>#FAFAD2</td>
<td>rgb(250, 250, 210)</td>
</tr>
<tr>
<td>LightGrey</td>
<td>#D3D3D3</td>
<td>rgb(211, 211, 211)</td>
</tr>
<tr>
<td>LightGreen</td>
<td>#90EE90</td>
<td>rgb(144, 238, 144)</td>
</tr>
<tr>
<td>LightPink</td>
<td>#FFB6C1</td>
<td>rgb(255, 182, 193)</td>
</tr>
<tr>
<td>LightSalmon</td>
<td>#FFA07A</td>
<td>rgb(255, 160, 122)</td>
</tr>
<tr>
<td>LightSeaGreen</td>
<td>#20B2AA</td>
<td>rgb(32, 178, 170)</td>
</tr>
<tr>
<td>LightSkyBlue</td>
<td>#87CEFA</td>
<td>rgb(135, 206, 250)</td>
</tr>
<tr>
<td>LightSlateBlue</td>
<td>#8470FF</td>
<td>rgb(132, 112, 255)</td>
</tr>
<tr>
<td>LightSlateGray</td>
<td>#778899</td>
<td>rgb(119, 136, 153)</td>
</tr>
<tr>
<td>LightSteelBlue</td>
<td>#B0C4DE</td>
<td>rgb(176, 196, 222)</td>
</tr>
<tr>
<td>LightYellow</td>
<td>#FFFFE0</td>
<td>rgb(255, 255, 224)</td>
</tr>
<tr>
<td>Lime</td>
<td>#00FF00</td>
<td>rgb(0, 255, 0)</td>
</tr>
<tr>
<td>LimeGreen</td>
<td>#32CD32</td>
<td>rgb(50, 205, 50)</td>
</tr>
<tr>
<td>Linen</td>
<td>#FAF0E6</td>
<td>rgb(250, 240, 230)</td>
</tr>
<tr>
<td>Magenta</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
</tr>
<tr>
<td>Maroon</td>
<td>#800000</td>
<td>rgb(128, 0, 0)</td>
</tr>
<tr>
<td>MediumAquaMarine</td>
<td>#66CDAA</td>
<td>rgb(102, 205, 170)</td>
</tr>
<tr>
<td>MediumBlue</td>
<td>#0000CD</td>
<td>rgb(0, 0, 205)</td>
</tr>
<tr>
<td>MediumOrchid</td>
<td>#BA55D3</td>
<td>rgb(186, 85, 211)</td>
</tr>
<tr>
<td>MediumPurple</td>
<td>#9370D8</td>
<td>rgb(147, 112, 216)</td>
</tr>
<tr>
<td>MediumSeaGreen</td>
<td>#3CB371</td>
<td>rgb(60, 179, 113)</td>
</tr>
<tr>
<td>MediumSlateBlue</td>
<td>#7B68EE</td>
<td>rgb(123, 104, 238)</td>
</tr>
<tr>
<td>MediumSpringGreen</td>
<td>#00FA9A</td>
<td>rgb(0, 250, 154)</td>
</tr>
<tr>
<td>MediumTurquoise</td>
<td>#48D1CC</td>
<td>rgb(72, 209, 204)</td>
</tr>
<tr>
<td>MediumVioletRed</td>
<td>#C71585</td>
<td>rgb(199, 21, 133)</td>
</tr>
<tr>
<td>MidnightBlue</td>
<td>#191970</td>
<td>rgb(25, 25, 112)</td>
</tr>
<tr>
<td>MintCream</td>
<td>#F5FFFA</td>
<td>rgb(245, 255, 250)</td>
</tr>
<tr>
<td>MistyRose</td>
<td>#FFE4E1</td>
<td>rgb(255, 228, 225)</td>
</tr>
<tr>
<td>Moccasin</td>
<td>#FFE4B5</td>
<td>rgb(255, 228, 181)</td>
</tr>
<tr>
<td>NavajoWhite</td>
<td>#FFDEAD</td>
<td>rgb(255, 222, 173)</td>
</tr>
<tr>
<td>Navy</td>
<td>#000080</td>
<td>rgb(0, 0, 128)</td>
</tr>
<tr>
<td>OldLace</td>
<td>#FDF5E6</td>
<td>rgb(253, 245, 230)</td>
</tr>
<tr>
<td>Olive</td>
<td>#808000</td>
<td>rgb(128, 128, 0)</td>
</tr>
<tr>
<td>OliveDrab</td>
<td>#6B8E23</td>
<td>rgb(107, 142, 35)</td>
</tr>
<tr>
<td>Orange</td>
<td>#FFA500</td>
<td>rgb(255, 165, 0)</td>
</tr>
<tr>
<td>OrangeRed</td>
<td>#FF4500</td>
<td>rgb(255, 69, 0)</td>
</tr>
<tr>
<td>Orchid</td>
<td>#DA70D6</td>
<td>rgb(218, 112, 214)</td>
</tr>
<tr>
<td>PaleGoldenRod</td>
<td>#EEE8AA</td>
<td>rgb(238, 232, 170)</td>
</tr>
<tr>
<td>PaleGreen</td>
<td>#98FB98</td>
<td>rgb(152, 251, 152)</td>
</tr>
<tr>
<td>PaleTurquoise</td>
<td>#AFEEEE</td>
<td>rgb(175, 238, 238)</td>
</tr>
<tr>
<td>PaleVioletRed</td>
<td>#D87093</td>
<td>rgb(216, 112, 147)</td>
</tr>
<tr>
<td>PapayaWhip</td>
<td>#FFEFD5</td>
<td>rgb(255, 239, 213)</td>
</tr>
<tr>
<td>PeachPuff</td>
<td>#FFDAB9</td>
<td>rgb(255, 218, 185)</td>
</tr>
<tr>
<td>Peru</td>
<td>#CD853F</td>
<td>rgb(205, 133, 63)</td>
</tr>
<tr>
<td>Pink</td>
<td>#FFC0CB</td>
<td>rgb(255, 192, 203)</td>
</tr>
<tr>
<td>Plum</td>
<td>#DDA0DD</td>
<td>rgb(221, 160, 221)</td>
</tr>
<tr>
<td>PowderBlue</td>
<td>#B0E0E6</td>
<td>rgb(176, 224, 230)</td>
</tr>
<tr>
<td>Purple</td>
<td>#800080</td>
<td>rgb(128, 0, 128)</td>
</tr>
<tr>
<td>Red</td>
<td>#FF0000</td>
<td>rgb(255, 0, 0)</td>
</tr>
<tr>
<td>RosyBrown</td>
<td>#BC8F8F</td>
<td>rgb(188, 143, 143)</td>
</tr>
<tr>
<td>RoyalBlue</td>
<td>#4169E1</td>
<td>rgb(65, 105, 225)</td>
</tr>
<tr>
<td>SaddleBrown</td>
<td>#8B4513</td>
<td>rgb(139, 69, 19)</td>
</tr>
<tr>
<td>Salmon</td>
<td>#FA8072</td>
<td>rgb(250, 128, 114)</td>
</tr>
<tr>
<td>SandyBrown</td>
<td>#F4A460</td>
<td>rgb(244, 164, 96)</td>
</tr>
<tr>
<td>SeaGreen</td>
<td>#2E8B57</td>
<td>rgb(46, 139, 87)</td>
</tr>
<tr>
<td>SeaShell</td>
<td>#FFF5EE</td>
<td>rgb(255, 245, 238)</td>
</tr>
<tr>
<td>Sienna</td>
<td>#A0522D</td>
<td>rgb(160, 82, 45)</td>
</tr>
<tr>
<td>Silver</td>
<td>#C0C0C0</td>
<td>rgb(192, 192, 192)</td>
</tr>
<tr>
<td>SkyBlue</td>
<td>#87CEEB</td>
<td>rgb(135, 206, 235)</td>
</tr>
<tr>
<td>SlateBlue</td>
<td>#6A5ACD</td>
<td>rgb(106, 90, 205)</td>
</tr>
<tr>
<td>SlateGray</td>
<td>#708090</td>
<td>rgb(112, 128, 144)</td>
</tr>
<tr>
<td>Snow</td>
<td>#FFFAFA</td>
<td>rgb(255, 250, 250)</td>
</tr>
<tr>
<td>SpringGreen</td>
<td>#00FF7F</td>
<td>rgb(0, 255, 127)</td>
</tr>
<tr>
<td>SteelBlue</td>
<td>#4682B4</td>
<td>rgb(70, 130, 180)</td>
</tr>
<tr>
<td>Tan</td>
<td>#D2B48C</td>
<td>rgb(210, 180, 140)</td>
</tr>
<tr>
<td>Teal</td>
<td>#008080</td>
<td>rgb(0, 128, 128)</td>
</tr>
<tr>
<td>Thistle</td>
<td>#D8BFD8</td>
<td>rgb(216, 191, 216)</td>
</tr>
<tr>
<td>Tomato</td>
<td>#FF6347</td>
<td>rgb(255, 99, 71)</td>
</tr>
<tr>
<td>Turquoise</td>
<td>#40E0D0</td>
<td>rgb(64, 224, 208)</td>
</tr>
<tr>
<td>Violet</td>
<td>#EE82EE</td>
<td>rgb(238, 130, 238)</td>
</tr>
<tr>
<td>VioletRed</td>
<td>#D02090</td>
<td>rgb(208, 32, 144)</td>
</tr>
<tr>
<td>Wheat</td>
<td>#F5DEB3</td>
<td>rgb(245, 222, 179)</td>
</tr>
<tr>
<td>White</td>
<td>#FFFFFF</td>
<td>rgb(255, 255, 255)</td>
</tr>
<tr>
<td>WhiteSmoke</td>
<td>#F5F5F5</td>
<td>rgb(245, 245, 245)</td>
</tr>
<tr>
<td>Yellow</td>
<td>#FFFF00</td>
<td>rgb(255, 255, 0)</td>
</tr>
<tr>
<td>YellowGreen</td>
<td>#9ACD32</td>
<td>rgb(154, 205, 50)</td>
</tr>
</tbody>
</table>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\1.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\2.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\3.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\4.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\5.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\6.png" alt="1"></p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm控制台打印带颜色</title>
    <url>/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>​    在python开发的过程中，经常会遇到需要打印各种信息。海量的信息堆砌在控制台中，就会导致信息都混在一起，降低了重要信息的可读性。这时候，如果能给重要的信息加上字体颜色，那么就会更加方便用户阅读了。 　　</p>
<p>　　当然了，控制台的展示效果有限，并不能像前段一样炫酷，只能做一些简单的设置。不过站在可读性的角度来看，已经好很多了。</p>
<p><strong>书写格式：</strong>   <a id="more"></a>  </p>
<p><strong>开头部分</strong>：\033[显示方式;前景色;背景色m +内容+ <strong>结尾部分：</strong>\033[0m</p>
<p>​     注意：开头部分的三个参数：显示方式，前景色，背景色是可选参数，可以只写其中的某一个；另外由于表示三个参数不同含义的数值都是唯一的没有重复的，所以三个参数的书写先后顺序没有固定要求，系统都能识别；但是，建议按照默认的格式规范书写。</p>
<p>​     对于结尾部分，其实也可以省略，但是为了书写规范，建议\033[***开头，\033[0m结尾。</p>
<p><strong>数值表示的参数含义：</strong></p>
<p><strong>显示方式:</strong> 0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、 5（闪烁）、25（非闪烁）、7（反显）、27（非反显）<br><strong>前景色:</strong> 30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋 红）、36（青色）、37（白色）<br><strong>背景色:</strong> 40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋 红）、46（青色）、47（白色）</p>
<p><strong>常见开头格式</strong>：<br>\033[0m            默认字体正常显示，不高亮<br>\033[32;0m       红色字体正常显示<br>\033[1;32;40m  显示方式: 高亮    字体前景色：绿色  背景色：黑色<br>\033[0;31;46m  显示方式: 正常    字体前景色：红色  背景色：青色</p>
<p>\033[1;31m  显示方式: 高亮    字体前景色：红色  背景色：无</p>
<p><strong>示例格式1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\033[1;35;0m字体变色，但无背景色 \033[0m'</span>)  <span class="comment"># 有高亮 或者 print('\033[1;35m字体有色，但无背景色 \033[0m')</span></span><br><span class="line">print(<span class="string">'\033[1;45m 字体不变色，有背景色 \033[0m'</span>)  <span class="comment"># 有高亮</span></span><br><span class="line">print(<span class="string">'\033[1;35;46m 字体有色，且有背景色 \033[0m'</span>)  <span class="comment"># 有高亮</span></span><br><span class="line">print(<span class="string">'\033[0;35;46m 字体有色，且有背景色 \033[0m'</span>)  <span class="comment"># 无高亮</span></span><br></pre></td></tr></table></figure>
<p><strong>示例格式2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\033[0;36m'</span>)</span><br><span class="line">print(<span class="string">'hello world!'</span>)</span><br><span class="line">print(<span class="string">'\033[0m'</span>)</span><br></pre></td></tr></table></figure>
<p>参考自博客[老虎死了还有狼],更多展示效果请点击<a href="https://www.cnblogs.com/daofaziran/p/9015284.html" target="_blank" rel="noopener">此处</a>.</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序初识</title>
    <url>/2019/07/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>新创建的小程序项目，会默认生成一份demo代码，用于展示代码结构.</p>
<p>新建项目已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js，app.json，app.wxss 这三个。其中js`后缀的是脚本文件json后缀的文件是配置文件，后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。<a id="more"></a></p>
<ol>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
</li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。</p>
</li>
</ol>
<p>​    注意：该文件不可添加任何注释。</p>
<ol start="3">
<li>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</li>
</ol>
<p>我们注意到，在实例程序的代码中还有2个文件夹，一个是pages，一个是utils，其中utils是放通用工具类方法的一个文件夹，pages是存放所有页面的文件夹。我们着重讲一下这个pages。</p>
<p>小程序页面文件构成</p>
<p>　　在这个示例中，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p> 每一个小程序页面是由同路径下同名的四个不同后缀文件组成的，如：index.js、index.wxml、index.wxss、index.json。.js<code>后缀的文件是脚本文件，.</code>json<code>后缀的文件是配置文件，</code>.wxss<code>后缀的是样式表文件，</code>.wxml`后缀的文件是页面结构文件。</p>
<p> index.wxml 是页面的结构文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"getUserInfo"</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"user-motto"</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本例中使用了view，image，text，button等<code>组件</code>来搭建页面结构，绑定数据和交互处理函数。</p>
<p> index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">motto: <span class="string">'Hello World'</span>,</span><br><span class="line">userInfo: &#123;&#125;,</span><br><span class="line">hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line">bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url: <span class="string">'../logs/logs'</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: app.globalData.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line"><span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line"><span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">app.userInfoReadyCallback = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: res.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">wx.getUserInfo(&#123;</span><br><span class="line">success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">app.globalData.userInfo = res.userInfo</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: res.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">getUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">app.globalData.userInfo = e.detail.userInfo</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: e.detail.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>index.wxss 是页面的样式表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line">.userinfo &#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: column;</span><br><span class="line">align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-avatar &#123;</span><br><span class="line">width: <span class="number">128</span>rpx;</span><br><span class="line">height: <span class="number">128</span>rpx;</span><br><span class="line">margin: <span class="number">20</span>rpx;</span><br><span class="line">border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-nickname &#123;</span><br><span class="line">color: <span class="meta">#aaa;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.usermotto &#123;</span><br><span class="line">margin-top: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
<p> index.json 是页面的配置文件：</p>
<p> 页面的配置文件也是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
<p> logs 的页面结构:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--logs.wxml--&gt;</span><br><span class="line">&lt;view class="container log-list"&gt;</span><br><span class="line">  &lt;block wx:for-items="&#123;&#123;logs&#125;&#125;" wx:for-item="log"&gt;</span><br><span class="line">    &lt;text class="log-item"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p> logs 页面使用 block 控制标签来组织代码，在 <code>&lt;/block&gt;</code> 上使用 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1474644083132#block-wxfor" target="_blank" rel="noopener"><code>wx:for-items</code></a> 绑定 <code>logs</code> 数据，并将 <code>logs</code> 数据循环展开节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//logs.js</span></span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'../../utils/util.js'</span>)</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    logs: []</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      logs: (wx.getStorageSync(<span class="string">'logs'</span>) || []).map(<span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> util.formatTime(<span class="keyword">new</span> <span class="built_in">Date</span>(log))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>手机预览</p>
<p>点击开发工具的顶部工具栏中的”预览”，即可生成预览二维码，用微信扫码后即可在微信客户端中预览体验</p>
<p>以上便是微信小程序前端开发的基本流程，而实际上要做一个内容可以更新的小程序，单有前端开发是远远不够的，还需要后台开发。后台开发与web开发的后台基本无异，可以选择用java、php、nodejs等任一语言，有一点需要注意的是小程序后台服务器必须是https协议的，这就要求必须购买云服务器并将后台服务器设置成https服务。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>python中列表(list)排序的一些常见操作</title>
    <url>/2019/06/18/python%E4%B8%AD%E5%88%97%E8%A1%A8-list-%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>对列表排序一般有两种操作:my_list.sort()和sorted(my_list)</strong></p>
<p><strong>1.使用sort排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">my_list.sort()</span><br><span class="line">print(my_list)</span><br><span class="line"><span class="comment">#输出[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>2.使用sorted排序</strong><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">my_list_1=sorted(my_list)</span><br><span class="line">print(my_list_1)</span><br><span class="line"><span class="comment">#输出[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>可以看出操作有所不同，使用sort()方法对list排序会修改list本身,不会返回新list，而sorted()方法不会对原list进行修改，而是返回一个新list，但是如果你不需要保留原来的list，此方法将更有效sort()。</p>
<p>另外sort()不能对dict字典进行排序，如果sort()里面不填参数，即默认升序，若要降序只需my_list.sort(reverse=True),(True降序，False升序(sorted()操作与之一样))</p>
<p><strong>3.列表里嵌套列表且里面的列表有多个值，并指定以第几个值进行排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个进行升序排序</span></span><br><span class="line">users=[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">user=sorted(users,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个升序排序，如果第二个相等，则以第一个排序</span></span><br><span class="line">user=sorted(users,key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个升序排序，如果第二个相等，则以第一降序排列</span></span><br><span class="line">s=sorted(users,key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],-x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],-x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个降序排序，如果第二个相等，则以第一升序排列</span></span><br><span class="line">s=sorted(users,key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中一些常见的问题</title>
    <url>/2019/06/04/pytohn%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1.为什么import 调用的模块 在pycharm中 会有红色的波浪线？</strong></p>
<p>是因为该模块为第三方库，你未导入，进行导入就可以了，一般用pip指令导入比较方便</p>
<p><strong>2</strong>.<strong>为什么用import 调用模块有的’import’显示灰色,有的显示高亮？</strong></p>
<p>灰色是表示没有用到这个模块里的任何一个东西，可以把这一行去掉的。</p>
<p><strong>3</strong>.<strong>selenium的使用</strong><a id="more"></a></p>
<p>   1.运行报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.chrome()</span><br><span class="line">TypeError: <span class="string">'module'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure>
<p>​    解决方案：浏览器的名称需要大写，即Chrome和Firefox</p>
<p>   2.selenium中安装chrome浏览器驱动(chomedriver)</p>
<p>​    1.下载对应版本的chromedriver 下载地址：<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">点这里</a></p>
<pre><code>选择需要的浏览器驱动版本，点击**notes.txt**可以查看当前版本支持的浏览器版本，确定是否下载。
</code></pre><p>​    2.解压复制chromedriver.exe到chrome浏览器的安装目录(C:\Program Files (x86)\Google\Chrome\Application)</p>
<p>​        如果找不到此文件夹就将此文件解压到和你py文件同一个文件夹下，正常启动即可。</p>
<p>​    3.启动脚本，浏览器正常打开</p>
<p>​    使用格式 driver = webdriver.Chrome()</p>
<p> <strong>4.try -except 异常处理：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      A</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">      B</span><br><span class="line">  <span class="keyword">except</span>会捕获所有异常，包括键盘中断和程序退出请求（用sys.exit()就无法退出程序了，因为异常被捕获了），因此慎用。</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:可以捕获除与程序退出sys.exit()相关之外的所有异常</span><br><span class="line">  老版本的Python，<span class="keyword">except</span>语句写作<span class="string">"except Exception, e"</span>，Python <span class="number">2.6</span>后应写作<span class="string">"except Exception as e"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">except</span> &lt;异常名<span class="number">1</span>,异常名<span class="number">2</span>&gt;:&lt;数据&gt;:捕获异常名<span class="number">1</span>或者异常名<span class="number">2</span>,及附加的数据库</span><br><span class="line">  例如：</span><br><span class="line">  	<span class="keyword">try</span>:</span><br><span class="line">          <span class="keyword">print</span> (<span class="number">2</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (IOError,ZeroDivisionError):</span><br><span class="line">  		print( <span class="string">'类型异常'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键字          关键字说明</span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span>           抛出/引发异常</span><br><span class="line"><span class="keyword">try</span>/<span class="keyword">except</span>      捕获异常并处理</span><br><span class="line"><span class="keyword">pass</span>            忽略异常</span><br><span class="line"><span class="keyword">as</span>              定义异常实例(<span class="keyword">except</span> IOError <span class="keyword">as</span> e)</span><br><span class="line"><span class="keyword">finally</span>         无论是否出现异常，都执行的代码</span><br><span class="line"><span class="keyword">else</span>            如果<span class="keyword">try</span>中的语句没有引发异常，则执行<span class="keyword">else</span>中的语句</span><br></pre></td></tr></table></figure>
<p>​    常用异常名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">异常名    描述</span><br><span class="line">   AttributeError 调用不存在的方法引发的异常</span><br><span class="line">   EOFError       遇到文件末尾引发的异常</span><br><span class="line">   ImportError    导入模块出错引发的异常</span><br><span class="line">   IndexError     列表越界引发的异常</span><br><span class="line">   IOError        I/O操作引发的异常，如打开文件出错等</span><br><span class="line">   KeyError       使用字典中不存在的关键字引发的异常</span><br><span class="line">   NameError      使用不存在的变量名引发的异常</span><br><span class="line">   TabError       语句块缩进不正确引发的异常</span><br><span class="line">   ValueError     搜索列表中不存在的值引发的异常</span><br><span class="line">   ZeroDivisionError   除数为零引发的异常</span><br><span class="line"></span><br><span class="line">   使用<span class="keyword">raise</span> 引发异常几种方式：</span><br><span class="line"></span><br><span class="line">   <span class="keyword">raise</span> 异常名</span><br><span class="line">   <span class="keyword">raise</span> 异常名,附加数据</span><br><span class="line">   <span class="keyword">raise</span> 类名</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> 简化了<span class="keyword">raise</span>语句：</span><br><span class="line">   需要注意的是，<span class="keyword">assert</span>语句一般用于开发时对程序条件的验证，只有当内置_debug_为<span class="literal">True</span>时，<span class="keyword">assert</span>语句才有效。当Python脚     本以-O选项编译成为字节码文件时，<span class="keyword">assert</span>语句将被移除。</span><br><span class="line">   但与<span class="keyword">raise</span>语句不同的是，<span class="keyword">assert</span>语句是在条件测试为假时，才引发异常。<span class="keyword">assert</span>语言的一般形式如下：</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span>&lt;条件测试&gt;,&lt;异常附加数据&gt;<span class="comment">#其中异常附加数据是可选的</span></span><br></pre></td></tr></table></figure>
<p><strong>5.try-finally:异常处理</strong></p>
<p>   1.无论try语句中是否抛出异常，finally中的语句一定会被执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   f = open(<span class="string">"/tmp/output"</span>, <span class="string">"w"</span>)</span><br><span class="line">   f.write(<span class="string">"hello"</span>)</span><br><span class="line">   <span class="comment">#raise Exception("something wrong")</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">   print(<span class="string">"closing file"</span>)</span><br><span class="line">   f.close()</span><br></pre></td></tr></table></figure>
<p>​    不论try中写文件的过程中是否有异常，finally中关闭文件的操作一定会执行。由于finally的这个特性，finally经常被用来做    一些清理工作。</p>
<p>   2.try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">print(func1())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">a</span><br><span class="line">A</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​    再例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">raise</span> IOError<span class="comment">#指定引发异常</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            print(<span class="string">'B'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            print(<span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    print(func1())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">b</span><br><span class="line">X</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>​    try中抛出的异常是IOError类型的，而except中定位的是IndexError类型的，try中抛出的异常没有被捕获到，所以except中    的语句没有被执行，但不论异常有没有被捕获，finally还是会执行，最终函数返回了finally中的返回值3。</p>
<p>​    这里还可以看到另外一个问题。try中抛出的异常没有被捕获到，按理说当finally执行完毕后，应该被再次抛出，但finally里    执行了return，导致异常被丢失。<br>​    可以看到在finally中使用return会导致很多问题。实际应用中，不推荐在finally中使用return返回。</p>
<p><strong>6.def函数中的一些问题</strong></p>
<p>1.返回值问题：</p>
<p>返回个数：(不涉及*args和**kwargs参数)</p>
<p>​    0：返回None</p>
<p>​    1：返回object</p>
<p>​    =&gt;2：返回tuple</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>2.形参与实参问题：</p>
<p>问题1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; &gt; &gt; &gt; &gt; &gt; <span class="function"><span class="keyword">def</span> <span class="title">text1</span><span class="params">(x,y)</span>:</span></span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt;  print(x,y)</span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt; print(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>输出结果为：1,2<br>如果这样赋值：text1(y=1,x=2)#与形参顺序无关<br>则输出结果为：2,1<br>即如果你不指定赋值，它会默认与形参一一对应<br>你也可以 text1(1,y=2)，但不可以text1(x=1,2)或text1(y=1,2).</p>
<p>问题2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2</span><span class="params">(x,y=<span class="number">2</span>)</span>:</span></span><br><span class="line">    print(x,y)</span><br></pre></td></tr></table></figure>
<p>你可以给形参赋个初值<br>你就可以这样调用text2(1),输出结果为：1,2<br>因为你给y形参已赋初值，如果你调用时未给y赋值，它会默认y=2<br>如果你这样调用 text2(1,3),则输出结果为：1,3.</p>
<p>问题3：</p>
<p>问题1与问题2都是传参个数必须与形参个数相等<br>接下来写一种个数不用相等的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#*args:把N个位置参数转化为元组的形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text3</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">text3(<span class="number">1</span>)</span><br><span class="line">text3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#或text3(*[1,2,3])</span></span><br><span class="line"><span class="comment">#则结果分别为：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)		<span class="comment">#以元组(tuple)的方式返回.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text4</span><span class="params">(x,*args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">text4(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">#则运行结果为：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>另一种方式：#**kwargs:把N个关键字参数转化为字典的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text5</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">text5(name=<span class="string">'Lihua'</span>,age=<span class="number">18</span>,sex=<span class="string">'M'</span>)</span><br><span class="line"><span class="comment">#运行结果为：</span></span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'Lihua'</span>,<span class="string">'age'</span>=<span class="number">18</span>,<span class="string">'sex'</span>=<span class="string">'M'</span>&#125;<span class="comment">#以字典的形式返回</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：args和kwargs都必须放在最后</strong></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2019蓝桥杯国赛C++B组</title>
    <url>/2019/05/27/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9BC-B%E7%BB%84/</url>
    <content><![CDATA[<p>​    比赛结束的第二天，坐标HPU，此次的蓝桥杯国赛其实收获挺多的，也是第一次来北京，还是借着公费的理由进行的旅游，哈哈哈，北京三日游很奈斯，本以为会混个国优，空手而归呢，第二天上午官网一查成绩，震惊，还混了个国三，哈哈哈，心想就做出来两个填空题，还能国三，可想蓝桥杯多水了，都说蓝桥杯是暴力杯，啊啊啊，我竟然没想到暴力，不然可能就国二了，甚至国一(国特做梦可以想想)，本来一道编程大题，可以暴力打表多混点分呢，时间都浪费在了某坑爹的用dfs跑的填空题上了 ，一直调试还是未果(浪费那么多时间做出来还好嘛，然鹅 汗，15分啊 啊啊啊)，心桑啊，不过虽然不是很理想，但对我来说已经很奈斯了.<a id="more"></a></p>
<p>​    昨天在北大体育馆举行的颁奖仪式，不过只颁发特等奖，国一二三也不知道有没有奖品，羡慕国特的华为笔记本和华为手机一部(不羡慕，不嫉妒，直接恨)。印象最深的只记得北大欠我两瓶可乐，记心里啦，进场不让带吃的喝的，安检人员说，你出来如果还有，你就拿，没有的话就不拿，我们不负责保管，然而出来去一看，果然啥都没了，啊啊啊，好气哟.不过颁奖典礼体验挺棒的 ，尤其是北大小姐姐们跳到舞蹈，哈哈哈.  奈斯到爆哦，其他不多说了，北京之旅完美谢幕，再见北京！！！</p>
<p>​    简单说一下题目，每年国赛都是六道，今年十道，大概因为是今年是蓝桥杯十周年吧，具体题目忘了，大致描述一下我会的几题吧</p>
<p>A题： 2019  x y 三个数形成等差数列，问x+y最小值为多少？我觉得这是最水的题了 利用等差数列 两项之差相等就行了代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll n=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//如果怕范围小，可以把n定义大一点</span></span><br><span class="line">        <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i*i<span class="number">-2019</span>*<span class="number">2019</span>==j*j-i*i)</span><br><span class="line">                minn=min(minn,i+j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,minn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B题：2019分成若干个两两不相等的质数和，问有多少种符合的分法？</p>
<p>据说是01背包，不会写 跳过，后续会的话再补</p>
<p>D题：应该是 求谁的约数个数等于100，例如S1=1，S2=2，S4=3，S6=4…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">1000000</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n=k;</span><br><span class="line">		<span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>)	a[s++]=i;</span><br><span class="line">		<span class="comment">//打印每个数的约数进行验证 </span></span><br><span class="line">		<span class="comment">//printf("%d: ",k);</span></span><br><span class="line">		<span class="comment">//	for(int j=0;j&lt;s;j++)</span></span><br><span class="line">		<span class="comment">//	printf("%d ",a[j]);</span></span><br><span class="line">        <span class="comment">//	puts("");</span></span><br><span class="line">		<span class="keyword">if</span>(s==<span class="number">100</span>)</span><br><span class="line">		&#123;	 </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E题：是5*5的方格从左上角出发沿边走然后回到左上角，问有多少种走法，其中步数不能超过12步，并且同一个边不能走两遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> kk,zz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>( xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">6</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">6</span>  &amp;&amp; !vis[xx][yy]  &amp;&amp;  s&lt;=<span class="number">12</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(xx!=<span class="number">0</span>||yy!=<span class="number">0</span>) vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">			s++;</span><br><span class="line">			<span class="keyword">if</span>(xx==<span class="number">0</span> &amp;&amp; yy==<span class="number">0</span>)&#123;</span><br><span class="line">				ans++;</span><br><span class="line"><span class="comment">//				printf("方案 %d:\n",ans); </span></span><br><span class="line"><span class="comment">//				for(int i=0;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					for(int j=0;j&lt;6;j++)</span></span><br><span class="line"><span class="comment">//					&#123;</span></span><br><span class="line"><span class="comment">//						printf("%d ",vis[i][j]);</span></span><br><span class="line"><span class="comment">//					&#125;</span></span><br><span class="line"><span class="comment">//					puts("");</span></span><br><span class="line"><span class="comment">//				 &#125; </span></span><br><span class="line"><span class="comment">//				 puts("");</span></span><br><span class="line">			&#125;</span><br><span class="line">			dfs(xx,yy);</span><br><span class="line">			vis[xx][yy]=<span class="number">0</span>;</span><br><span class="line">			s--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="comment">//freopen("text.txt","w",stdout);</span></span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"总方案数：%d\n"</span>,ans<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待续。。。</p>
]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否为素数，一些优化方式</title>
    <url>/2019/04/22/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>素数判断是acm及各种比赛中频繁出现的内容，也是最基础的，所以一定要完全掌握，下面就介绍几种常用的素数判断的优化方法。</p>
<p>1.(1)先说最简单的吧，复杂度o(n),也是最容易想到的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;<span class="comment">//如果flag==0则说明n是非素数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>(2)对于一般题目来说往往会超时的，所以可以将其复杂度降至o(sqrt(n))<br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3还有一种更高级优化，可以将其复杂度降至o(sqrt(n)/3),首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；</p>
<p>证明：令x≥1，将大于等于5的自然数表示如下：</p>
<p> ··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···</p>
<p>可以看到，不和6的倍数相邻的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到sqrt(n)中每6个数只判断2个，时间复杂度O(sqrt(n)/3)。</p>
<p>在(2)(3)(4)中，都是一个剪枝的思想，(3)中裁剪了不必要的偶数，(4)中裁剪了不和6</p>
<p>的倍数相邻的数，虽然都没有降低时间复杂度的阶数，但都一定程度上加快了判断的速度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>)</span><br><span class="line">		 flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=n;i+=<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.再说下打表法吧，就是你先开一个bool型数组(int型，也行，不过bool稍微快一点，数组大小须是&lt;=所求最大数的大小)，这个缺点就是数据最大不能超过数组的最大范围(一般在1e8以内) 复杂度o(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dabiao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//先初始化为false，不是素数的标为true</span></span><br><span class="line">    vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j+=i)</span><br><span class="line">				vis[j]=<span class="literal">true</span>;<span class="comment">//素数(除了本身)它的所有倍数即为非素数，然后把他的倍数全标记为true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新手上路不喜勿喷，后续如有发现错误，会及时修正的。</p>
]]></content>
      <tags>
        <tag>判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛13 I题(博弈论)</title>
    <url>/2019/04/13/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-I%E9%A2%98-%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>题目：[<a href="https://ac.nowcoder.com/acm/contest/549/I" target="_blank" rel="noopener">链接</a>]</p>
<p><strong>题目描述</strong>：</p>
<p>小A也听说了取石子这个游戏，也决定和小B一起来玩这个游戏。总共有n堆石子，双方轮流取石子，每次都可以从任意一堆中取走任意数量的石子，但是不可以不取。规定谁先取完所有的石子就获胜。但是小A实在是太想赢了，所以在游戏开始之前，小A有一次机会，可以趁小B不注意的时候选择其中一堆石子拿走其中的k个，当然小A也可以选择不拿石子。小A先手。双方都会选择最优的策略，请问在这样的情况下小A有没有必胜的策略，如果有输出YES，否则就输出NO。<a id="more"></a></p>
<p><strong>输入描述</strong>：</p>
<p>一行两个整数N,K，表示分别有N堆石子以及小A可以拿走的石子个数k。<br>接下来N个整数表示每一堆的石子个数 a[i].</p>
<p><strong>输出描述：</strong></p>
<p>一行一个结果表示小A是否有必胜策略，如果有则输出YES，否则输出NO。</p>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<p><strong>备注：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤N≤1e5，1≤a[i]≤1e5，0≤K≤1e5</span><br></pre></td></tr></table></figure>
<p>经过分析很容易发现此题是Nim游戏，也是经典的博弈论，关于Nim游戏详解[<a href="https://www.cnblogs.com/exponent/articles/2141477.html" target="_blank" rel="noopener">点这里</a>]，对于此题，先不考虑K，将所有的a[i]异或，如果a[i]的异或值非0，则小A有必胜的策略，否则小B有必胜的策略，此题在于怎样处理K，K的意思就是小A可以比小B多操作一次，可以从任意一堆拿走k个，或选择不拿，所以有两种情况，拿或不拿，对于所有a[i]进行遍历，就看这两种情况，哪一种情况异或值是非零，如果出现非零，则小A必胜，遍历结束，仍未出现非零，则小B必胜.</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100003</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum^=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum!=<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum^=a[i];<span class="comment">//例如a[0]^a[1]^a[2]=sum,则a[1]^a[2]=sum^a[0]</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=k)<span class="comment">//判断k能不能拿，能拿的话，是否能出现想要的结果</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum^=(a[i]-k);</span><br><span class="line">			<span class="keyword">if</span>(sum!=<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛13 D题(位运算)</title>
    <url>/2019/04/13/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-D%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>题目：[<a href="https://ac.nowcoder.com/acm/contest/549/D" target="_blank" rel="noopener">链接</a>]</p>
<p><strong>题目描述：</strong>  </p>
<p>位运算是一个非常重要的东西。而小A最近在学习位运算，小A看到了一道很简单的例题，是说从N个数里面选出N-1个数要让它们或起来的值最大，小A想知道这个答案是多少。你可以帮帮他吗？</p>
<p><strong>输入描述：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN</span><br></pre></td></tr></table></figure>
<p><strong>输出描述：</strong><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行输出个结果代表最大值一行输出个结果代表最大值</span><br></pre></td></tr></table></figure>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 8 16</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择2,4,8,16或的和是最大的，没有比这个更大的方案。</span><br><span class="line"></span><br><span class="line">1≤N≤5e6，1≤Ai≤longlong</span><br></pre></td></tr></table></figure>
<p>第一次看到题，直接上去sort排序，从第二个开始或运算和(贼尴尬啊)，肯定秒WA啊，原来没想象的那么水哇，这题恶心就恶心到n个数就让你或运算n-1个(或运算n个就多好)，后来通过大神室友的指点，略懂一二，我试着解释解释吧，或运算 1|1=1，1|0=1,0|0=0，此题就是每个数值位1，0之间的或运算(<strong>最下面有后续</strong>)</p>
<p>此题思路就是，将每数位1的个数记录下来</p>
<p>比如 n个数每个位上的1的总个数为 </p>
<p>4  2  5  1  3  1</p>
<p>对a[i]进行遍历，</p>
<p>例如a[0]=5转化为二进制</p>
<p>0  0  0  1  0  1</p>
<p>对应位上减掉1的个数</p>
<p>则变成</p>
<p>4  2  5  0  3  0</p>
<p>则此时最大值即是</p>
<p>1  1  1  0  1  0 (即是各位置剩余1的个数&gt;=1 即对应的值为1)此时的十进制为2^5+2^4+2^3+2^1 将此时的最大值保存下来</p>
<p>然后继续对a[i]重复进行上面的操作，每次保存下来最大值</p>
<p>遍历结束</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll a[<span class="number">500003</span>];</span><br><span class="line"><span class="keyword">int</span> bits[<span class="number">64</span>],c[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	ll maxx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)<span class="comment">//题上范围long long 最大2^63-1，所以定义64，也可以先求出a[i]的最大值，来获得最高位</span></span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">				bits[j]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));<span class="comment">//c数组用来存放当前最大或值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(bits[j]<span class="number">-1</span>&gt;=<span class="number">1</span>) </span><br><span class="line">					c[j]=<span class="number">1</span>;	</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(bits[j]&gt;=<span class="number">1</span>) 	</span><br><span class="line">					c[j]=<span class="number">1</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">		ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">64</span>;x++)</span><br><span class="line">			sum+=c[x]*<span class="built_in">pow</span>(<span class="number">2</span>,x);</span><br><span class="line">		maxx=max(maxx,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后续补充：</strong></p>
<p>无意中看到大佬利用前缀和与后缀和求的，思路比这个清晰，简单(还是自己太菜，当时没想到)，下面就简单分享下思路，</p>
<p>先用一个数组保存下所有的或前缀和，再用另一个数组保存所有的或后缀和，然后保存前缀和与后缀和或的最大值即可 ，</p>
<p>pre[i] | suf[i+2]，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll a[<span class="number">500003</span>];</span><br><span class="line">ll pre[<span class="number">500003</span>],suf[<span class="number">500003</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	ll maxx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">	<span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="keyword">sizeof</span>(suf));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">		pre[i]=pre[i<span class="number">-1</span>]|a[i];<span class="comment">//求或的前缀和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		suf[i]=suf[i+<span class="number">1</span>]|a[i];<span class="comment">//求或的后缀和</span></span><br><span class="line">	maxx=suf[<span class="number">2</span>];<span class="comment">//先把第一个元素不取的或的和赋值给maxx</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">		maxx=max(maxx,pre[i]|suf[i+<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//由题意知取n-1个元素，所以每次取前缀和然后隔一个元素的后缀和的或值，然后最大值保存在maxx中</span></span><br><span class="line">	maxx=max(maxx,pre[n<span class="number">-1</span>]);<span class="comment">//pre[n-1]即是最后一个元素不取的或值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>阶乘(factorial) 牛客小白月赛5</title>
    <url>/2019/04/12/%E9%98%B6%E4%B9%98-factorial-%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B5/</url>
    <content><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/135/D?&amp;headNav=www" target="_blank" rel="noopener">阶乘(factorial)</a></p>
<p><strong>问题描述：</strong>   1! 2! 3! …n! 阶乘相乘的末尾零的个数</p>
<p><strong>输入描述：</strong></p>
<p>输入数据共一行，一个正整数n，意义如“问题描述”。<br><strong>输出描述：</strong><a id="more"></a></p>
<p>输出一行描述答案：</p>
<p>一个正整数k，表示S的末尾有k个0</p>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>对于100%的数据，1&lt;=n&lt;=1e8</p>
<p>题目让求阶乘最后有几个0，即为该表达式的最后结果含有10的几次方的因子，直接求的话，不太好求 不妨转化一下思路，容易发现10的几次方都有一个通性：质因子只有2和5，</p>
<p>显然，阶乘中 质因子2的个数比5多。所以这个题可以转换为 求 因子5的个数，5的个数即是所求末尾0的个数，那么此题就迎刃而解了</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t = i;</span><br><span class="line">        <span class="keyword">while</span>(t%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1285(拓扑排序模板)</title>
    <url>/2019/04/12/HDU-1285-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">HDU1285</a></p>
<p>Problem Description</p>
<p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p>
<p>Input<a id="more"></a></p>
<p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p>
<p>Output</p>
<p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<p><code>Sample Output</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure>
<p>此题就是拓扑排序的模板题，关系中不能出现环,跑一边模板即可,既然没有环，那肯定有入度为零的点，</p>
<p>1.首先找到入度为零的点，然后将他的所有出边减掉，</p>
<p>2.然后在找下一个入度为零的点，同样将其所有的出边减掉，直到遍历完所有的点。</p>
<p>注意每找到一个入度为零的点就把它输出来，当然也可以保存到数组里，等遍历完所有点，再输出也行，要注意行末空格的处理</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">503</span>][<span class="number">503</span>],vis[<span class="number">503</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuopu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]==<span class="number">0</span>)<span class="comment">//寻找入度为0的点</span></span><br><span class="line">			&#123;</span><br><span class="line">				res=j;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">if</span>(ans==<span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,res);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,res);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[res]=<span class="number">-1</span>;<span class="comment">//等于-1说明已被访问过了</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[res][k]==<span class="number">1</span>)vis[k]--;<span class="comment">//将入度为0的点它的出边剪掉</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,u,v;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">			<span class="keyword">if</span>(pre[u][v]==<span class="number">0</span>)<span class="comment">//防止出现重边 </span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[u][v]=<span class="number">1</span>;</span><br><span class="line">				vis[v]++;<span class="comment">//记录点V的入度个数</span></span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		tuopu(n);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1962-洛谷-斐波那契数列</title>
    <url>/2019/04/12/P1962-%E6%B4%9B%E8%B0%B7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>题目：<a href="https://www.luogu.org/problemnew/show/P1962" target="_blank" rel="noopener">P1962</a></p>
<p><strong>题目背景</strong></p>
<p>大家都知道，斐波那契数列是满足如下性质的一个数列：</p>
<p>• f(1) = 1 ， f(2) = 1 ， f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数)</p>
<p><strong>输入格式：</strong> 第 1 行：一个整数 n<a id="more"></a></p>
<p><strong>输出格式：</strong> 第 1 行： f(n) mod 1000000007 的值</p>
<p>输入样例#1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>输出样例#1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>输入样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>输出样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure>
<p>说明<br> 对于 60% 的数据： n ≤ 92<br> 对于 100% 的数据： n在long long(INT64)范围内<br> ​</p>
<p>根据数据范围这个题用打表或递归方法显然是超时的，所以就用到了矩阵快速幂，这一题难点就在于怎样构造矩阵，关于矩阵快速幂可以参考上篇博客<a href="https://prestu.github.io/2019/04/11/%E6%B4%9B%E8%B0%B7P3390-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" target="_blank" rel="noopener">矩阵快速幂纯模板</a>这次主要讲述怎样构造矩阵，</p>
<p>对于 f(n)=f(n-1)+f(n-2)…这道题目的关键之处在于构造初始矩阵，矩阵快速幂是核心所在。</p>
<p>如何构造：<a href="https://blog.csdn.net/FlushHip/article/details/80068888" target="_blank" rel="noopener">各种构造方法点此处</a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span>&#123;</span></span><br><span class="line">	ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">st <span class="title">Martrix</span><span class="params">(st x,st y)</span></span>&#123;</span><br><span class="line">	st ans;</span><br><span class="line">	<span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.a));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">st <span class="title">fast_power</span><span class="params">(st s,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) res.a[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> res.a[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=Martrix(res,s);</span><br><span class="line">		s=Martrix(s,s);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	st s;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(s.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(s.a));</span><br><span class="line">		s.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;s.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;s.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		s=fast_power(s,n<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(s.a[<span class="number">0</span>][<span class="number">0</span>]+s.a[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>斐波那契</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3390(矩阵快速幂)</title>
    <url>/2019/04/11/%E6%B4%9B%E8%B0%B7P3390-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目：<a href="https://www.luogu.org/problemnew/show/P3390" target="_blank" rel="noopener">P3390</a></p>
<p>题目描述：给定n*n的矩阵A，求A^k</p>
<p><strong>输入格式：</strong>第一行，n,k第2至n+1行，每行n个数，第i+1行第j个数表示矩阵第i行第j列的元素</p>
<a id="more"></a>
<p><strong>输出格式：</strong>输出A^k共n行，每行n个数，第i行第j个数表示矩阵第i行第j列的元素，每个元素模10^9+7</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p>快速矩阵模板题，直接套用模板即可</p>
<p>矩阵乘法不懂的同学<a href="https://wenku.baidu.com/view/e3842cc42cc58bd63186bdeb.html" target="_blank" rel="noopener">点这里</a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll  a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">Matrix</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node s;</span><br><span class="line">	<span class="built_in">memset</span>(s.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(s.a));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;n;z++)</span><br><span class="line">				s.a[i][j]=(s.a[i][j]+x.a[i][z]*y.a[z][j])%mod;<span class="comment">//矩阵乘法计算</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">fast_power</span><span class="params">(node x,ll k)</span><span class="comment">//快速幂运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node res;</span><br><span class="line">	<span class="built_in">memset</span>(res.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(i==j) res.a[i][j]=<span class="number">1</span>;<span class="comment">//res为单位矩阵</span></span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)	res=Matrix(res,x);</span><br><span class="line">		x=Matrix(x,x);</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll k;</span><br><span class="line">	node pre;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pre.a[i][j]);</span><br><span class="line">	pre=fast_power(pre,k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,pre.a[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pre.a[i][n<span class="number">-1</span>]);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1094(拓扑排序)</title>
    <url>/2019/04/11/poj-1094-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：<a href="http://poj.org/problem?id=1094" target="_blank" rel="noopener">POJ1094</a></p>
<p>大致题意就是多组输入，输入n，m（可以视为n个点，有m个关系）m个关系在字母A-Z范围内，给你一些关系比如A&lt;B，就认为A到B之间有条有向路，可以分三种情况：</p>
<p>1.当出现了一组关系使图出现了环，则输出“Inconsistency found after K1 relations”  其中的K1就是在第几个关系出现了环，后面的关系就可以忽略不处理了<a id="more"></a></p>
<p>2.当还未输入完给的关系就确定了，n个点的关系，则后面的关系就不用处理了，直接输出“Sorted sequence determined after K2 relations: （点关系的顺序）.” K2是此时确定关系的点的个数；</p>
<p>3.当输入完给的关系，还未确定n个点的关系，则输出“Sorted sequence cannot be determined.”</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">300</span>][<span class="number">300</span>];<span class="comment">//存放村庄之间的关系 1即相通（单向）0即无路</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1000</span>],b[<span class="number">1000</span>],c[<span class="number">1000</span>];<span class="comment">//vis记录通向该点的关系数（即入度）c[]存放确定关系的点</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tuopu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rem,FLAG=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		b[i]=vis[i];</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">0</span>;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				res++;</span><br><span class="line">				rem=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;<span class="number">1</span>) <span class="comment">//说明多个入度为零的点 即n个点的顺序不确定</span></span><br><span class="line">		&#123;</span><br><span class="line">			FLAG=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//无入度为零的点 即出现环</span></span><br><span class="line">		b[rem]=<span class="number">-1</span>;<span class="comment">//把找到的入度为零的点 标记为-1 表示访问过了</span></span><br><span class="line">		c[g++]=rem;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">			<span class="keyword">if</span>(pre[rem][k])	b[k]--;	<span class="comment">//把入度为零的点 它的出边去掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FLAG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;(n+m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">			<span class="keyword">if</span>(ans) <span class="keyword">continue</span>;<span class="comment">//ans 如果是1 则说明已经出结果了，下面的关系就不用处理了。直接跳过即可</span></span><br><span class="line">			<span class="keyword">if</span>(pre[a[<span class="number">0</span>]-<span class="string">'A'</span>][a[<span class="number">2</span>]-<span class="string">'A'</span>]==<span class="number">0</span>)<span class="comment">//防止重边</span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[a[<span class="number">0</span>]-<span class="string">'A'</span>][a[<span class="number">2</span>]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">				vis[a[<span class="number">2</span>]-<span class="string">'A'</span>]++;<span class="comment">//记录 a[2]点的入度个数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> s=tuopu();</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="number">-2</span>)<span class="comment">//即出现环了</span></span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>,i+<span class="number">1</span>);<span class="comment">//即输出第几个关系出现了环</span></span><br><span class="line">				ans=<span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>,i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%c"</span>,c[i]+<span class="string">'A'</span>);</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line">				ans=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ans)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2631 树的直径</title>
    <url>/2019/03/31/Poj2631-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>题目：<a href="http://poj.org/problem?id=2631" target="_blank" rel="noopener">POJ2631</a></p>
<p>题意：    大致就是村庄之间修路，从一个村庄到另一个村庄只有一条路，而不经过其他一些村庄两次。有若干村庄和道路，其中任何村庄都可以通过公路从任何其他村庄到达。就是让找出该地区两个最偏远村庄之间的公路距离。这些村庄从1开始编号。</p>
<p>题解：    这个就是求树的直径的模板题，两遍BFS即可，第一遍，从任意一个点遍历，记录最远的那个村庄，然后<a id="more"></a>第二遍从第一遍找到的那个最远村庄为起点进行遍历，这样得到的就是两个最偏远地区的距离，即树的直径，本来想用邻接矩阵(浪费空间)存图，题目提到有多达1万条路，所以我选择了邻接表存数据。如果是初学者话，估计这个邻接表不太好理解，我尽可能用通俗的语言让大家理解</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w,next;<span class="comment">//u,v是两个村庄；w是u,v两个村庄的距离;next 是记录此条路上一次存表的编号</span></span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10001</span>]；<span class="comment">//vis是遍历时记录该条路是否被访问</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">10001</span>]；<span class="comment">//d是记录最远距离，遍历过程中不断更新</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">10001</span>];<span class="comment">//head是记录每条路的头结点</span></span><br><span class="line"><span class="keyword">int</span> cnt,j,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><span class="comment">//邻接表的创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].u=u;</span><br><span class="line">	edge[cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];<span class="comment">//next指向上一次该路存表的编号，</span></span><br><span class="line">	head[u]=cnt++;<span class="comment">//将该条路的编号赋值给head</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">	que.push(x);</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> xx=que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[xx];i!=<span class="number">-1</span>;i=edge[i].next)<span class="comment">//遍历与xx相连的所有村庄，i=-1即与xx相连的村庄遍历完了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> vv=edge[i].v;</span><br><span class="line">			<span class="keyword">if</span>(!vis[vv]&amp;&amp;d[vv]&lt;d[xx]+edge[i].w)<span class="comment">//不断维护最远距离</span></span><br><span class="line">			&#123;</span><br><span class="line">				vis[vv]=<span class="number">1</span>;</span><br><span class="line">				d[vv]=d[xx]+edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(d[vv]&gt;ans)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=d[vv];<span class="comment">//ans是记录最远距离</span></span><br><span class="line">					j=vv;<span class="comment">//j是记录最偏远的村庄编号</span></span><br><span class="line">				&#125;</span><br><span class="line">				que.push(vv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w))</span><br><span class="line">	&#123;</span><br><span class="line">		add(u,v,w);add(v,u,w);<span class="comment">//因为路是双向的，这也是可以用两遍BFS的原因</span></span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	bfs(j);<span class="comment">//j是第一遍BFS找到的最远村庄的编号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>邻接表</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1232畅通工程（并查集)</title>
    <url>/2019/03/27/HDU1232%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86)/</url>
    <content><![CDATA[<p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">HDU1232</a></p>
<p>题意：    某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后</p>
<a id="more"></a>
<p>的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。<br>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。<br>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0<br>Sample Output<br>1<br>0<br>2<br>998</p>
<p>这是并查集的模板题，直接套模板即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pre[x]==x?x:pre[x]=find(pre[x]);<span class="comment">//利用递归将所有他的子节点指向父节点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//将两个集合连接成一个集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx=find(x),yy=find(y);<span class="comment">//xx是x的父节点，yy是y的父节点</span></span><br><span class="line">	<span class="keyword">if</span>(xx!=yy)<span class="comment">//如果x，y的父节点不是同一个，则将他们的父节点相连，使他们成为一个集合</span></span><br><span class="line">    &#123;		</span><br><span class="line">		<span class="keyword">if</span>(yy&lt;xx)</span><br><span class="line">			pre[xx]=yy;<span class="comment">//为了方便，将编号小的视为父节点</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pre[yy]=xx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,s,a,b;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;n)&#123;</span><br><span class="line">		s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			pre[i]=i;<span class="comment">//初始化，先将所有的点指向本身，即先让每一个点都是孤立的点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			Union(a,b);<span class="comment">//让a和b连通</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[i]==i)<span class="comment">//有几个指向本身的点，就有几个集合，</span></span><br><span class="line">			s++;<span class="comment">//s是集合个数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s<span class="number">-1</span>);<span class="comment">//要想让所有的集合连成一个集合，则最少需要 s-1边（例如有两个集合，则变成一个集合只需一条边即可）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>2019蓝桥杯-E题:迷宫</title>
    <url>/2019/03/25/2019%E8%93%9D%E6%A1%A5%E6%9D%AF-E%E9%A2%98%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<p>试题 E: 迷宫<br>本题总分：15 分<br>【问题描述】<br>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可<br>以通行的地方。<br>010000<br>000100<br>001001<br>110000<br>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这</p>
<a id="more"></a>
<p>个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可</p>
<p>以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别</p>
<p>表示向下、向上、向左、向右走。对于下面这个更复杂的迷宫（30 行 50 列），</p>
<p>请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，</p>
<p>请找出字典序最小的一个作为答案。请注意在字典序中D&lt;L&lt;R&lt;U。</p>
<p>01010101001011001001010110010110100100001000101010<br>00001000100000101010010000100000001001100110100101<br>01111011010010001000001101001011100011000000010000<br>01000000001010100011010000101000001010101011001011<br>00011111000000101000010010100010100000101100000000<br>11001000110101000010101100011010011010101011110111<br>00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010<br>00111000001010100001100010000001000101001100001001<br>11000110100001110010001001010101010101010001101000<br>00010000100100000101001010101110100010101010000101<br>11100100101001001000010000010101010100100100010100<br>00000010000000101011001111010001100000101010100011<br>10101010011100001000011000010110011110110100001000<br>10101010100001101010100101000010100000111011101001<br>10000000101100010000101100101101001011100000000100<br>10101001000000010100100001000100000100011110101001<br>00101001010101101001010100011010101101110000110101<br>11001010000100001100000010100101000001000111000010<br>00001000110000110101101000000100101001001000011101<br>10100101000101000000001110110010110101101010100001<br>00101000010000110101010000100010001001000100010101<br>10100001000110010001000010101001010101011111010010<br>00000100101000000110010100101001000001000000000010<br>11010000001001110111001001000011101001011011101000<br>00000110100010001000100000001000011101000000110011<br>10101000101000100010001111100010101001010000001000<br>10000010100101001010110000000100101010001011101000<br>00111100001000010000000110111000000001000000001011<br>10000001100111010111010001000110111010101101111000<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一<br>个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填<br>写多余的内容将无法得分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//D&lt;L&lt;R&lt;U,这样初始化,为了保证输出的路径是最小字典序 </span></span><br><span class="line"><span class="keyword">int</span> ans[MAXN][MAXN];<span class="comment">//记录是否被访问 </span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN],path[MAXN][MAXN];<span class="comment">//dis记录步数 ，数组path记录路径</span></span><br><span class="line"><span class="keyword">char</span> a[MAXN][MAXN];<span class="comment">//数组a是存迷宫</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	st s,ss;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">	<span class="built_in">queue</span>&lt;st&gt;que;</span><br><span class="line">	ans[x][y]=<span class="number">1</span>;</span><br><span class="line">	s.x=x; s.y=y;</span><br><span class="line">	que.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		s=que.front();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> xx=s.x+dx[i];</span><br><span class="line">			<span class="keyword">int</span> yy=s.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;m&amp;&amp;ans[xx][yy]==<span class="number">0</span>&amp;&amp;a[xx][yy]==<span class="string">'0'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[xx][yy]=dis[s.x][s.y]+<span class="number">1</span>;<span class="comment">//记录步数 </span></span><br><span class="line">				path[xx][yy]=i+<span class="number">1</span>;<span class="comment">//记录上一步从哪过来的 </span></span><br><span class="line">				ans[xx][yy]=<span class="number">1</span>;</span><br><span class="line">				ss.x=xx,ss.y=yy;</span><br><span class="line">				que.push(ss);</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">		que.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[n<span class="number">-1</span>][m<span class="number">-1</span>]);<span class="comment">//输出z走到终点a[n-1][m-1]的最少步数 (题上没要求) </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y)</span><span class="comment">//利用递归输出路径 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">		print(x<span class="number">-1</span>,y);<span class="built_in">cout</span>&lt;&lt;<span class="string">"D"</span>; <span class="comment">//等于1，即上一步向下走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">2</span>)&#123;</span><br><span class="line">		print(x,y+<span class="number">1</span>);<span class="built_in">cout</span>&lt;&lt;<span class="string">"L"</span>;<span class="comment">//等于2，即上一步向左走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">		print(x,y<span class="number">-1</span>);<span class="built_in">cout</span>&lt;&lt;<span class="string">"R"</span>;<span class="comment">//等于3，即上一步向右走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">4</span>)&#123;</span><br><span class="line">		print(x+<span class="number">1</span>,y);<span class="built_in">cout</span>&lt;&lt;<span class="string">"U"</span>;<span class="comment">//等于4，即上一步向上走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]); </span><br><span class="line">	bfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	print(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最短步数为：186</span><br><span class="line">DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>bfs</tag>
        <tag>记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/03/15/hello-world/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">welcome to my blog!</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
