<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[华驰寒假工]]></title>
    <url>%2F2019%2F11%2F03%2F%E5%8D%8E%E9%A9%B0%E5%AF%92%E5%81%87%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[华驰团队欢迎您！ ——–你是否还在为每月的生活费向父母开口而感到一丝羞愧？你是否还在因没有任何工作经验而为毕业后的前途担忧？你是否还在为了自己的恋爱经费节衣缩食？你是否又对一件自己非常喜欢的东西因其昂贵的价格望而却步？——–那么，你找到我就对了，这是一个千载难逢的机会啊(装个逼装个逼，哈哈哈)。——–用自己的努力让父母少流些汗水，用自己的双手铺垫自己的前途，用自己的心血让你的她拥有更多甜蜜，让你喜欢的东西安稳在你的怀里。——–我们常年与上海，深圳，昆山，杭州等大都市的正规公司合作，多次顺利进行暑假工和寒假工的输送，待遇优厚，且不收取任何中介费用，保证学生利益，让学生的利益最大化，也绝对会保证学生的安全，只要你敢相信我，那么你一定可以得到你想要的。——–我们为什么主打餐饮呢，因为餐饮并不比进厂工资低，甚至比你进厂还要高，最主要是餐饮工作环境好，伙食好，一般都是管吃管住的，并且没有进厂那么累，还有就是，在大城市这些高档餐厅好多都是“大人物”来吃饭，在你工作时可能遇见像马云这样的“大人物”，慧眼识人才，可能就让你跟着他混了，哈哈哈，开个玩笑(也有可能之真的哦)，当然这只是题外话，既然选择了跟着我们，就一定要踏踏实实的去干，加油，你是最棒的! ! ! 如果有意向随时骚扰我联系人：计算机1703范成恒联系方式：QQ：1932460873手机号：18737045137(微信同) 下面是餐饮的一些宣传页，可以进行参考参考。 如果你想进电子厂，那么也可以的，下面我放一些我们长期合作的电子厂的宣传页吧，供大家参考 寒假工宣传页 针对大家可能遇见的一些问题我们总结了一份寒假工问题集，供大家参考，希望对你们有所帮助： 2019寒假工问题集 如果还有什么不明白的随时联系我最后：祝大家学业有成，前程似锦！！！]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电子厂宣传册]]></title>
    <url>%2F2019%2F11%2F02%2F%E5%AF%92%E5%81%87%E5%B7%A5%E5%AE%A3%E4%BC%A0%E5%86%8C%2F</url>
    <content type="text"><![CDATA[我们常年合作的一些知名的部分电子厂，主要集中在上海，江苏，深圳等地。]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019寒假工问题集]]></title>
    <url>%2F2019%2F11%2F01%2F2019%E5%AF%92%E5%81%87%E5%B7%A5%E9%97%AE%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019寒假工问题集 1.问：寒假工期限是多长时间？ 答：从你们放假到你们学校开学之前一个星期左右，一般工期都在1个月以上，短期用工合同不会出现开学了不让回校上学。 2.问：工作期内学生可以回家吗？ 答：原则上是不可以的，但如果是个别现象可以协调一下。 3.问：我们要去哪个厂？现在可以确定下来吗？ 答：可以列举几个例：主要输送方向：长三角：上海昌硕、英华达、日铭、达丰等 苏州华硕、瑞仪、京东方等；昆山仁宝、世硕、纬创、富港等； 无锡绿点、健鼎、夏普等；常熟新世，常熟达富等南京英华达、华宝等， 珠三角： 深圳比亚迪、伟创力、卓翼、创维、TCL、普联中兴、昊阳天宇等；东莞德普特、东莞富港、OPP、王氏港建等；惠州比亚迪、长城、光弘、惠州海格等；广州广宝，中山微创，珠海伟创力等；郑州、淮安、廊坊、太原富士康等全国各地的500强企业！但现在确定不了哪一个厂，因为我们着手范围比较广，现在到底能组织多少人，还估算不出来，所以我们没办法统筹安排。学校还没确定下来放假时间，等确定下来我们会根据各个企业需求和时间具体统筹安排！统计好名单报备企业，大概发车前一周即可确定。做到让同学们进入满意的企业寒假工实习！ 4.问：我们的工资大概是多少？ 答：不同的地方工资存在差异，不同的部门和岗位也有相差，具体的计算方法是：（例如：新进员工底薪2100元/月；加班费按劳勤法计算 （1930/2290÷21.75÷8×系数×加班时数）。系数为平时加班的1.5倍、周六周日为2倍、国定假日为3倍，平均4000—6500元/月），这个是按劳动法计算方式的计算结果，结束了每个人都有工资单，实际上工资你自己可以算出来的；部分企业为小时工操作，12-15元/小时不等。小时工工资一般是15元左右,工资一般在4000~6000寒假工比暑假工工资高些 5．问：什么时候发工资？ 答：发放时间根据厂方的规定时间发放（比如：每月的10号、15号、25号），学生在发工资之前返回的，工资到时间全额达到学生工资卡上; 离职当天会签考勤表，有问题反馈给企业，正常离职工资都会按时发放（只要不自离） 6．问：工资是你们公司代发还是由厂方发放？ 答：工资是由厂方核算由厂方直接打到学生工资卡上！不会经过任何劳务中介，工资会有每个人的工时单，大家可以放心的核对自己的工资！ 7．问：学生发生的意外情况谁来负责任？ 答：这一块看具体情况而定，一般分为这样几种情况：1.上车之前有学生自己负责2.在我们包的车上有我们的车队来负责3.在厂里出现意外按工伤处理由厂方负责4.在宿舍由厂方或者派遣公司负责5.工休期间有学生自己负责 8．问：食宿这一块怎么说？ 答：吃饭这一块是工作餐（两餐：中餐和晚餐）也就是只要你工作就有免费的饭吃，不工作就没有饭吃，早餐一般在早上5：30开饭，是为上夜班的准备，如果你想吃的话就五点半之前赶到厂里，有的厂子是一日三餐全免，这样的厂主要在常州地区；住宿是有偿宿舍，住宿费30-100元/月不等，个别需要交宿舍押金，离职退还 9．问：一天大概工作多长时间？ 答：一般是两班倒早八点到晚八点，晚八点到早八点，包括吃饭和休息时间，一般按10.5小时计算工资。 10．问：有没有白班和夜班之分？ 答：有，夜班有夜班津贴一般在5-20元/班不等。 11．问：学生辞职手续怎么办理？ 答：不需要学生操心，到时候自动解除，会统一办手续。均有我们安排的驻厂老师，统一安排！ 12．问：学生什么时候体检？ 答：学生一到目的地就要体检，这就要求学生在到达目的地之前的5个小时内不得吃东西或者喝水，也有企业不需要体检，只需要买一张体检单。 13．问：学生去的话需要交纳多少钱？ 答：一般长三角江苏上海地区车费（150元/人）体检费（50元/人） ​ 珠三角广东地区车费（200元/人）体检费（50元/人） 14．问：我们招到的学生送不出怎么办？ 答：这一点你不用担心，我是有把握全送出去的，我们现在缺的是人不是岗位，要不然我们也不会同时在全国范围内的各大高中院校开展暑假工、实习生的招募工作了。 15.学生出发需要带什么东西？ 答： 褥子、衣物、洗漱等生活用品。一寸照片3张，身份证复印件3张，身份证原件！ 16：工作环境及有没有危害？ 答：工作环境都是24小时恒温作业，无毒无害没有气味，都是一些未成品也没有辐射，手机拆开会有辐射吗？外面谣传的辐射都是一些化工厂或者一些金属重工业，我们做的企业都是一些生产电子企业的厂子，学生工安排的岗位都是简单岗位！ 17：企业管吃住吗？ 答：免费提供工作餐及加班餐，都是标准的工作餐，四菜一汤，米饭，面饭都有，早餐2元就解决了，也有部分企业提供免费的3餐，或者是每一个月餐补几百块，住宿4/8人间，独立卫生间，空调，热水，个人橱衣柜都有，一起去的可以住一个宿舍！ 18：外出打工安全不安全？ 答：厂里，宿舍区安保比学校好，只要没事别出去乱跑不会出现安全问题，企业宿舍都是有几十个保安全天24小时值班，到处都有监控摄像头，进出长门刷卡，进宿舍也要刷卡！闲杂人等进不去厂区宿舍区 19：出发及入职离职安排 依各大高校放假时间、公司安全大巴车在学校大门口接，直达厂区门口，下车后分宿舍，办理入职手续，培训1到2天 进车间工作，开始三天有老员工带着不用担心不会做或者做不好，工作都很简单 ​ 2019寒假工，期待你的加入！！！]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm教育版永久破解]]></title>
    <url>%2F2019%2F10%2F22%2Fpycharm%E6%95%99%E8%82%B2%E7%89%88%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[pycharm教育版，是python常用的一种开发工具，能大大提高我们的编程效率，因为他功能强大，并且有自动补全的功能，但教育版的收费，网上应该有很多破解的方法，接下来就给大家提供一种永久破解的方法，但不一定都能破解成功，如果可以就给个好评，如果不可以的话，就在找其他的破解方法。 1.首先下载jar包 下载地址: https://pan.baidu.com/s/1Ug644fHbvoXukoD93si4qg, 提取码：1m8d 2.然后将该文件(jetbrains-agent.jar)解压到pycahrm的bin目录下 3.修改pycharm64.exe.vmoptions 文件 在文件的最后加上：-javaagent:该文件路径\bin\jetbrains-agent.jar 4.启动pycharm，选择license server激活方式，地址填入：http://jetbrains-license-server (应该会自动填充)，或者点击按钮：’Discover Server’ 来自动填充地址，完成激活。 5.进入pycharm，查看激活状态： 点击help–&gt;About,上面没有显示到期日期时间，就是永久激活了。 6.大功告成。]]></content>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this licenseK71U8DBPNE has been cancelled (pycharm)]]></title>
    <url>%2F2019%2F10%2F15%2Fthis%20licenseK71U8DBPNE%20has%20been%20cancelled%20(pycharm)%2F</url>
    <content type="text"><![CDATA[最近使用pycharm的时候，之前还好好的，突然就不行了，弹出个这个错误，’this licenseK71U8DBPNE has been cancelled’,以为只是注册码过期了，就又去找了几个注册码，发现注册码并没有过期，弹出的错误还是同样的错误，就百度了一下借鉴了一下大神的博客，原来问题在这,下面提供三种方法： 1.找到咱们的这个host文件，一般都放在C:\Windows\System32\drivers\etc目录下，打开这个host文件,在最后加上一句代码：0.0.0.0 account.jetbrains.com,如果原文件存在这句代码，会被注释掉，把注释去掉即可，然后重启pycharm 输入激活码即可。 2.传送门：专业版pycharm永久破解 3.前两种如果还是解决不了，，那就使用最后一种一方法了，解决办法是，如果是学生，可以用学校给我们注册的个人教育邮箱去注册，如果不知道，可以问下自己的同学，实在不行，问导员，他应该是知道的，现在pycharm是对学生及老师都是免费使用的，如果你不是学生，需要注册一个edu邮箱：点这里.注册之后就可以在激活pycharm时选择buy选项，然后英文根据提示完成操作即可。 以上就是我给大家的对于此问题的一些解决方法，不敢保证能解决所有问题，但还是可以解决大部分人的问题的，感谢支持，如果又哪里有问题或不懂的地方，下方留言哦。]]></content>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用费马小定理求逆元]]></title>
    <url>%2F2019%2F10%2F13%2F%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[费马小定理：a是不能被质数p整除的正整数，则有a^(p-1)≡ 1 (mod p) 推导：a^(p−1) ≡ 1 (mod p) = a*a^(p−2 )≡ 1 (mod p) ; 则a的逆元 为 a^(p−2)。利用费马小定理求逆元的前提强调p一定是质数。 说这些你可能不太明白，先看一道题就明白了， HDU1576 要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。 Input数据的第一行是一个T，表示有T组数据。每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。 Output对应每组数据输出(A/B)%9973。 Sample Input21000 5387 123456789 Sample Output79226060 如果我们直接求肯定不行 ，所以要利用逆元求解，并且9973（即是上面的p）为质数， 设C是B的逆元，则有BC≡1(mod P)； 推论：(A/B)mod P = (A/B)1mod p = (A/B)BC mod p=AC(mod p); 即A/B的模等于A(B的逆元)的模；l利用费马小定理得出C=B^(p-2);则原式可转化为（AC）%p=（A%pC%p）%p；个人见解，欢迎纠错. 代码：12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define mod 9973typedef long long ll;//对 long long重命名 ll DD(ll a ,ll b)//求解 a^b%mod(因为a^b太大 需利用快速幂求解) &#123; ll res=1; if(b&lt;0) return 0; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll a,b,i; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b); i=DD(b,(mod-2));//i即为 b的逆元 printf(&quot;%lld\n&quot;,(a%mod*i%mod)%mod); //A*C）%p=（A%p*C%p）%p &#125; return 0;&#125;]]></content>
      <tags>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python打造淘宝抢购脚本]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%88%A9%E7%94%A8python%E6%89%93%E9%80%A0%E6%B7%98%E5%AE%9D%E6%8A%A2%E8%B4%AD%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[说这是一款自动抢购脚本是没问题的，不过其实一款半自动抢购脚本，为什么这么说呢，因为并没有达到完全自动抢购，需要扫码登陆，登陆之后就可以自动抢购了，该脚本主要依赖第三方库selenium自动打开谷歌浏览器进行模拟登陆淘宝。 在进行该程序之前需要做的工作是 1.安装谷歌浏览器，也可以用其他浏览器比如火狐等，不过我的代码是通过谷歌实现的。 2.安装第三方库selenium,(通过pip命令比较方便) 3.安装谷歌驱动chomedriver,不会的点这里. 好了开始放代码喽 可能该代码有所不成熟，且注释不够完善，有空进行补充，如果有问题，请大佬指出，评论在下方，感谢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import timeimport datetimefrom selenium import webdriver################################################################################################################### 淘宝抢购脚本 ## 使用方法： ## 1、先将需要抢购的商品放到购物车中（注意购物车中只能放需要抢购的东西，到时抢购的时候会全部提交) ## 2、修改下本脚本中的BUY_TIME值，设定为需要抢购的时间； ## 3、执行此脚本，然后等待浏览器打开弹出登陆界面，手机淘宝扫描登陆； ## 4、脚本开始执行后，会定时刷新防止超时退出，到了设定时间点会自动尝试提交订单 ## 5、抢购时为了防止一次网络拥堵出问题，设置了尝试机制，会不停尝试提交订单，直到提交成功或达到最大重试次数为止 ## 6、脚本只负责提交订单，之后24小时内需要自行完成付款操作。 ###################################################################################################################login_sucess=Falseretry_login_time=int(0)max_retry_login_time=int(6)buy_time="2019-07-31 20:15:00"buy_time_obj=datetime.datetime.strptime(buy_time,"%Y-%m-%d %H:%M:%S")now_time=datetime.datetime.now()if(now_time &gt; buy_time_obj): print('抢购时间已过，确认时间是否填写错误') exit(0)print('正在打开浏览器...')print('正在尝试登陆...')driver=webdriver.Chrome()def login_oprator(): driver.get('https://www.taobao.com') try: if driver.find_element_by_link_text("亲，请登录"): print('未登录，请点击登录按钮') driver.find_element_by_link_text('亲，请登录').click() print('请扫描二维码进行登陆') time.sleep(10) except: print('已登录，开始进行跳转...') global login_sucess global retry_login_time login_sucess=True retry_login_time=0def login(): global retry_login_time while retry_login_time &lt; max_retry_login_time: retry_login_time+=1 print('正在尝试登陆次数'+str(retry_login_time)) login_oprator() if login_sucess: print('登陆成功') break else: print('等待登陆中...') if not login_sucess: print('规定时间内，未完成扫码登陆，登陆失败...退出程序！！') exit(0) now=datetime.datetime.now() print('登陆成功'+str(now))def refrsh_keep_alive(): driver.get('https://cart.taobao.com/cart.htm') print('刷新购物页面，防止超时...') time.sleep(30)def keep_login_and_wait(): print("当前距离抢购时间点还有较长时间，开始定时刷新防止登录超时...") while True: current_time=datetime.datetime.now() if((buy_time_obj-current_time).seconds&gt;180): refrsh_keep_alive() else: print('抢购时间将近，停止自动刷新，准备进入抢购阶段...') breakdef buy(): driver.get("https://cart.taobao.com/cart.htm") time.sleep(3) global submit_success submit_success=0 retry_sumit_times=0 while True: now=datetime.datetime.now() if now&gt;=buy_time_obj: print('到达抢购时间，开始抢购...尝试次数'+str(retry_sumit_times)) if submit_success: print('抢购成功，无需继续抢购...') break if retry_sumit_times&gt;50: print('抢购次数达到上限，停止抢购...') break retry_sumit_times+=1 while True: if (driver.find_element_by_id('J_SelectAll1')): driver.find_element_by_id('J_SelectAll1').click() print('已选中全选按钮') break else: time.sleep(0.1) pass try: if(driver.find_element_by_id('J_Go')): driver.find_element_by_id('J_Go').click() print('已经点击结算按钮...') click_button_times=0 while True: try: if click_button_times&lt;10 and driver.find_element_by_link_text('提交订单'): driver.find_element_by_link_text('提交订单').click() print('已经点击提交订单按钮\n哈哈哈，抢购成功！！！') exit(0) except Exception as e: print('没有发现提交订单按钮，可能页面没加载出来，重试...') click_button_times+=1 time.sleep(0.1) except Exception as e: print(e) print('提交订单失败') time.sleep(0.1)login()keep_login_and_wait()buy()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计三国演义中出场次数前十名的人物]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%BB%9F%E8%AE%A1%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E4%B8%AD%E5%87%BA%E5%9C%BA%E6%AC%A1%E6%95%B0%E5%89%8D%E5%8D%81%E5%90%8D%E7%9A%84%E4%BA%BA%E7%89%A9%2F</url>
    <content type="text"><![CDATA[利用第三方库jieba库，进行统计《三国演义》中出场次数前十名的任务， 由于较为基础，直接贴代码吧。 1234567891011121314151617181920212223242526import jiebaexcludes = &#123;"将军","却说","荆州","二人","不可","不能","如此","商议","主公","如何","军士","左右","军马","引兵","次日","大喜","天下","于是","东吴","今日","不敢","魏兵","陛下","人马","不知","都督","一人","汉中"&#125; #需要删除的无用词汇txt = open("三国演义.txt", "r", encoding='utf-8').read()#打开提前下载好的txt文件words = jieba.lcut(txt) #分词counts = &#123;&#125;for word in words: if len(word) == 1: continue elif word == "诸葛亮" or word == "孔明曰": rword = "孔明" elif word == "关公" or word == "云长": rword = "关羽" elif word == "玄德" or word == "玄德曰": rword = "刘备" elif word == "孟德" or word == "丞相": rword = "曹操" else: rword = word counts[rword] = counts.get(rword,0) + 1 # 如果不存在，其次数为零，否则加1for word in excludes: del counts[word] #删除无用词汇，意思就是我们的目的是统计人物出现次数，统计过程中会出现一些不是人物名字的大量词汇，所以要进行删除操作items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True)#对人物次数，进行逆向排序for i in range(10): word, count = items[i] print ("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word, count))#对统计得到的前十名人物进行格式化输出]]></content>
      <tags>
        <tag>python</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python编写简易的名片管理系统]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%88%A9%E7%94%A8python%E7%BC%96%E5%86%99%E7%9A%84%E7%AE%80%E6%98%93%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[利用python实现简单的名片的添加，修改，查询，删除等操作。 此代码仅限小白练手哦，大佬忽略就好了(因为代码太水了 23333) 如遇到bug或有任何疑问，在下方评论留言，感谢！ 注意： 为了结果更清晰，下面将输出的内容进行了简单的颜色处理 格式： ​ 开头部分：\033[显示方式;前景色;背景色m ​ 结尾部分：\033[0m 关于字体颜色，更详细的内容请点击此处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#!/usr/bin/env python# _*_ coding:utf-8 _*_MingPian=&#123;&#125;def Add(): while True: name=input('请输入姓名(输入0退出添加):') if name=='0': break if MingPian.get(name): print('\033[0;31;1m此用户已存在，请重新输入！\033[0m') else: MingPian[name]=&#123;&#125; sex = input('性别:') num=input('联系方式:') MingPian[name]['sex'] = sex MingPian[name]['num'] = num print('\033[0;32;1m添加成功！\033[0m') breakdef Delete(): while True: name=input('请输入要删除的名字(输入0退出删除):') if name=='0': break if MingPian.get(name): del MingPian[name] print('\033[0;32;1m删除成功！\033[0m') break else: print('\033[0;31;1m你删除的名字不存在，或已被删除，请重新输入！\033[0m')def Modify(): while True: name=input('请输入要修改的名字(输入0退出修改):') if name=='0': break if MingPian.get(name): sex = input('性别(M/F):') num = input('联系方式:') MingPian[name]['sex']=sex MingPian[name]['num']=num print('\033[0;32;1m修改成功！\033[0m') break else: print('\033[0;31;1m你修改的名字不存在，或已被删除，请重新输入！\033[0m')def Search(): while True: name=input('请输入要查询的名字(输入0退出查询):') if name=='0': break if MingPian.get(name): print('\033[0;35;1m') print(MingPian[name]) print('\033[0m') break else: print('\033[0;31;1m你查询的名字不存在，或已被删除，请重新输入！\033[0m')def Look(): if MingPian.__len__(): print('\033[0;35;1m') print(MingPian) print('\033[0m') else: print('\033[0;31;1m此管理系统已空！\033[0m')msg = '''=====名片管理系统=====* 1. 添加名片 ** 2. 删除名片 * * 3. 修改名片 ** 4. 查询名片 * * 5. 查询全部信息 ** 6. 退出名片 **********************'''print('\033[0;34;1m')print(msg)print('\033[0m')while True: try: msg1 = '''&gt;&gt;&gt;1. 添加 2. 删除 3. 修改 4. 查询 5. 查询全部 6. 退出名片&lt;&lt;&lt;''' Input=input('\033[0;30;46m请输入要操作的序号:\033[0m') Input=int(Input) if Input==6: print('[6. 退出名片]') print('\033[0;31;1m程序已退出...\033[0m') break elif Input==1: print('\033[0;34;1m[1. 添加名片]\033[0m') Add() elif Input==2: print('\033[0;34;1m[2. 删除名片]\033[0m') Delete() elif Input==3: print('\033[0;34;1m[3. 修改名片]\033[0m') Modify() elif Input==4: print('\033[0;34;1m[4. 查询名片]\033[0m') Search() else: print('\033[0;34;1m[5. 查询全部信息]\033[0m') Look() print('\033[0;34;1m') print(msg1) print('\033[0m') except: print('\033[0;31;1m输入有误! 请重新输入!\033[0m') continue]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的一些实例]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[实例1. 验证用户输入的密码是否符合要求，密码的要求是： (1)不得少于8个字符. (2) 只能包含大小写字母、数字和下划线. (3) 大写字母、小写字母和数字这三种类型至少要包含两种. 12345678910111213141516171819202122232425import reprint(&apos;\033[1;32;1m&apos;)print(&apos;请输入密码：\n1. 不得少于8个字符\n2.只能包含大小写字母，数字和下划线\n3.大写字母，小写字母和数字至少要包含两种&apos;)print(&apos;\033[0m&apos;) while True: password=input(&apos;请输入:&apos;) if len(password) &lt; 8: print(&apos;输入错误!(不得少于8个字符)，请重新输入!&apos;) else: word=re.search(&apos;[\w_]+&apos;,password) if word.group()==password: a=b=c=int(0) if re.findall(&apos;[a-z]&apos;,password) : a=1 if re.findall(&apos;[A-Z]&apos;,password): b=1 if re.findall(&apos;[\d]&apos;,password): c=1 if a+b+c&gt;=2: print(&apos;密码正确!程序结束!&apos;) exit() else: print(&apos;密码有误，重新输入!&apos;) else: print(&apos;2密码有误，重新输入!&apos;) 注意：\033[0m 是控制字体颜色的代码格式，详见点这里。 实例2. 找出字符串”abcd123d123aad1v123“中以a开头，以123字符串结尾，但是中间不出现123这个字符串的字符串。结果应为:abcd123和ad1v123。 1234import res = 'abcd123d123ad1v123'x = re.compile(r'a.*?123')print(x.findall(s)) 实例3. 找出”a123abvpd123dpf12ab123sabd123f1123abc”中以123字符串开头，以ab字符串结尾，但是中间不出现123和“p”这两个字符串的子字符串。结果应为:123ab和123sab和123ab。 1234import rex = re.compile(r'123[^p|123]*?ab')s = 'a123abvpd123d“p”f12ab123sabd123f1123abc'print(x.findall(s)) 实例4. 匹配电话号码. 12p = re.compile(r&apos;\d&#123;3&#125;-\d&#123;6&#125;&apos;)print(p.findall(&apos;010-628888&apos;)) 实例5. 匹配IP. 12x=re.search(r&quot;(([01]?\d?\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([01]?\d?\d|2[0-4]\d|25[0-5]\.)&quot;,&quot;192.168.1.1&quot;)print(x.group())]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中一些特殊构造]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[特殊构造 (?:…) (…)不分组版本,用于使用 | 或者后接数量词(?iLmsux) iLmsux的每个字符代表一个匹配模式,只能用在正则表达式的开头,可选多个(?#…) #号后的内容将作为注释(?=…) 之后的字符串内容需要匹配表达式才能成功匹配(?!…) 之后的字符串不匹配表达式才能成功(?(?(?(id/name) yes |no) 如果编号为id/名字为name的组匹配到字符串,则需要匹配yes,否则匹配no,no可以省略 “(?:…)” ：()里面有?:表示该()不是分组 12345&gt;&gt;&gt; pat=re.compile(r&apos;a(?:bc)&apos;)&gt;&gt;&gt; pat.findall(&apos;abc&apos;)[&apos;abc&apos;]&gt;&gt;&gt; pat.match(&apos;abc&apos;).groups() #显示不出分组() “(?=…)”：匹配…表达式，返回。对后进行匹配，总是对后面进行匹配 1234567891011121314151617&gt;&gt;&gt; pat=re.compile(r&apos;\w(?=\d)&apos;) #匹配表达式\d，返回数字的前一位，\w：单词字符[A-Za-z0-9]&gt;&gt;&gt; pat.findall(&apos;abc1 def1 xyz1&apos;)[&apos;c&apos;, &apos;f&apos;, &apos;z&apos;]&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;) #匹配数字的前一位，列表返回[&apos;y&apos;, &apos;2&apos;, &apos;0&apos;, &apos;1&apos;, &apos;3&apos;, &apos;0&apos;, &apos;6&apos;, &apos;2&apos;]&gt;&gt;&gt; pat=re.compile(r&apos;\w+(?=\d)&apos;)&gt;&gt;&gt; pat.findall(&apos;abc1,def1,xyz1&apos;) #匹配最末数字的前字符串，列表返回[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)[&apos;abc2&apos;, &apos;def3&apos;, &apos;xyz4&apos;]&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;)[&apos;zhoujy2013062&apos;]&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?=\d)&apos;) #[A-Za-z],匹配字母,可以用其他的正则方法&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123&apos;) #匹配后面带有数字的字符串，列表返回[&apos;zhoujy&apos;, &apos;hangzhou&apos;]&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;] “(?!…)” 不匹配…表达式，返回。对后进行匹配 12345&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?!\d)&apos;) #[A-Za-z],匹配字母,可以用其他的正则方法&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;) #匹配后面不是数字的字符串，列表返回[&apos;zhouj&apos;, &apos;hangzho&apos;, &apos;binjian&apos;] #有疑问不应该是zhoujy吗？，因为y后面是数字，所以匹配到j终止&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)[&apos;ab&apos;, &apos;de&apos;, &apos;xy&apos;] “(?&lt;=…)”：匹配…表达式，总是对前面进行匹配 1234567&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;=\d)[A-Za-z]+&apos;) #匹配前面是数字的字母&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)[]&gt;&gt;&gt; pat.findall(&apos;1abc21,2def31,3xyz41&apos;)[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)[&apos;hangzhou&apos;] “(?&lt;!…)”：不匹配…表达式，总是对前面进行匹配 12345&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;!\d)[A-Za-z]+&apos;) #匹配前面不是数字的字母&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)[&apos;zhoujy&apos;, &apos;angzhou&apos;, &apos;binjiang&apos;] “(?i)…”: …为表达式，这里就介绍下i参数：大小写区分匹配 12345678910111213141516&gt;&gt;&gt; pat=re.compile(r&apos;(?i)abc&apos;) #(?i) 不区分大小写&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)[&apos;ABC&apos;]&gt;&gt;&gt; pat.findall(&apos;abc&apos;)[&apos;abc&apos;]&gt;&gt;&gt; pat.findall(&apos;aBc&apos;)[&apos;aBc&apos;]&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)[&apos;aBC&apos;]&gt;&gt;&gt; pat=re.compile(r&apos;abc&apos;,re.I) #re.I 作为参数使用，推荐&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)[&apos;aBC&apos;]&gt;&gt;&gt; pat.findall(&apos;abc&apos;)[&apos;abc&apos;]&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)[&apos;ABC&apos;]]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的正则表达式re]]></title>
    <url>%2F2019%2F07%2F27%2Fpython%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。(英语:Regular Expression，在代码中常简写为regex、regexp或RE)，计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 ​ 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件(例如sed和grep)普及开的。正则表达式通常缩写成”regex”，单数有regexp、regex，复数有regexps、regexes、regexen。 ​ 正则表达式是对字符串(包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为”元字符”))操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式在很多语言里都支持，python也不例外，re模块就是正则表达式的应用. 1、正则表达式元字符 1234567891011121314151617\ 转义字符，将后边紧跟着的字符变成特殊字符，或将后边的特殊字符变成普通字符如：在正则表达式中，"\n"换行符，"\\"则代表一个普通字符"\"^ 匹配第一行行首，匹配多行需要传参 flags=re.MULTILINE$ 匹配最后一行行尾，匹配多行需要传参 flags=re.MULTILINE. 除"\r""\n"外，匹配任意的单个字符，要使"."匹配换行符，flags=re.DOTALL或re.S| 或，如 "aaa|bbb|ccc"，表示"aaa","bbb","ccc"三选一? 匹配前边的子表达式0次或1次，等价于&#123;0,1&#125;,非贪婪模式+ 匹配前边的子表达式1次或多次，等价于&#123;1,&#125;* 匹配前边的子表达式0次或多次,，等价于&#123;0,&#125;&#123;&#125; &#123;n&#125;匹配前边的子表达式n次，&#123;n,&#125;匹配前边的子表达式至少n次，&#123;n,m&#125;匹配前边的子表达式n~m次() 分组，从1开始，从左至右数"("为第几组，下标0为全部分组[] 字符集匹配[]中的人一个字符，之匹配一次，如[abc]：表示"a","b","c"三选一。也可以给定范围(必须是连续的才行)，如[a-z]：表示a到z任意一个字符。还可以取反，如[^abc]：除"a","b","c"外的任意字符。注：[]中只有"^","-","\"三个特殊字符，其中"\"代表转义字符，其它的都代表原本普通的字符，如:[.]只是一个普通的点字符注：要使用元字符本身的普通字符，请使用转义字符转义一下，如 ："\(" 在正则表达式中代表普通给"("字符，其它的雷同 分组的用法： 1234(\num) 引用指定第几分组的值(?P&lt;name&gt;) 指定分组别名"name"(?P=name) 引用指定别名的分组的值(?:) 相当于去分组化，变成"与"()子集，如:"abc(?:qqq|www)"--&gt;相当于"abcqqq|abcwww" 2、预定义字符集 12345678\b 匹配一个单词边界，也就是指单词和空格间的位置，其它特殊字符也可以是单词的边界，如"#","$","&amp;","*"等\B 匹配非单词边界\d 匹配一个数字字符。等价于[0-9]\D 匹配一个非数字字符。等价于[^0-9]\s 匹配任何不可见字符，包括空格、制表符、换页符等，等价于[ \f\n\r\t\v]\S 匹配任何可见字符。等价于[^ \f\n\r\t\v]\w 匹配包括下划线的任何单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[A-Za-z0-9_]”，还包含汉字等它国字符\W 匹配任何非单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[^A-Za-z0-9_]”，还包含汉字等它国字符 3、re模块常用函数 re.A 或 re.ASCII 使用ASCII字符集进行匹配(不常用) re.I 或 re.IGNORECASE 忽略大小写匹配 re.L 或 re.LOCALE 使用当前预定字符类 \w \W \b \B \s \S 取决于当前区域设定(不常用) re.U 或 re.UNICODE 使用Unicode字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性(不常用) re.M 或 re.MULTILINE 多行匹配，使”^”,”$”可以在每一行中都进行匹配 re.S 或 re.DOTALL 使 “.” 可以匹配换行符”\r”,”\n” re.X 或 re.VERBOSE 去掉正则表达式中的所有空格符(不常用) 1）re.compile(pattern, flags=0) :创建模式对象 编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。） pattern: 编译时用的表达式字符串，flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等,(常用的flags即re模块常用函数) 123&gt;&gt;&gt; rg = re.compile(r&quot;\d+&quot;, flags=0)&gt;&gt;&gt; re.findall(rg, &quot;a1bb22ccc333&quot;)[&apos;1&apos;, &apos;22&apos;, &apos;333&apos;] 2）re.findall(pattern, string, flags=0) re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。 1234567891011121314151617181920&gt;&gt;&gt; re.findall(r"hello", "hello world hello") # 普通匹配['hello', 'hello']&gt;&gt;&gt; re.findall(r"^hello", "hello world hello") # 匹配开头['hello']&gt;&gt;&gt; re.findall(r"^hello", "hello world\nhello", flags=re.MULTILINE) # 多行匹配开头['hello', 'hello']&gt;&gt;&gt; re.findall(r"hello$", "hello world hello") # 匹配结尾['hello']&gt;&gt;&gt; re.findall(r"\d+", "aaa111bbb222ccc333") # 匹配数字['111', '222', '333']&gt;&gt;&gt; re.findall(r"\d&#123;2&#125;", "aaa111bbb222ccc333") # 匹配两位的数字['11', '22', '33']&gt;&gt;&gt; re.findall(r"ab|cd", "ab000cd00") # 匹配"ab"或"cd"['ab', 'cd']&gt;&gt;&gt; re.findall(r"\(", "ab(cd")) # 匹配"("['(']&gt;&gt;&gt; re.findall(r"(abc)+", "abcabcabc") # 想要匹配多个"abc"，使用分组时会优先把分组的内容返回['abc']&gt;&gt;&gt; re.findall(r"(?:abc)+", "abcabcabc") # 想要匹配多个"abc"，(?:)把分组去掉，变成一个普通的字符串['abcabcabc'] 3）re.search(pattern, string, flags=0) 在字符串中寻找模式,只要找到一个符合条件的就返回. 1234567891011121314151617181920&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;)&lt;_sre.SRE_Match object; span=(0, 5), match=&apos;hello&apos;&gt; # 可以看到只返回了第一个&quot;hello&quot;&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;).group()&apos;hello&apos;&gt;&gt;&gt; re.search(r&quot;(abc) \1&quot;, &quot;abc abc&quot;).group() # \1 引用分组1的值&apos;abc abc&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;abc) (?P=name)&quot;, &quot;abc abc&quot;).group() # (?P=name) 引用分组别名&quot;name&quot;的值&apos;abc abc&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group()&apos;zhansan 23&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(0) # 分组0--即匹配的结果&apos;zhansan 23&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(1) # 分组1的值&apos;zhansan&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(2) # 分组2的值&apos;23&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;name&quot;) # 分组别名name的值&apos;zhansan&apos;&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;age&quot;) # 分组别名age的值&apos;23&apos; 4）re.match(pattern, string, flags=0) 在字符串开始处匹配模式. 12345678&gt;&gt;&gt; re.match(r"abc", "abcooooo").group()'abc'&gt;&gt;&gt;m = re.search('asd','ASDasd')&gt;&gt;&gt;m&lt;_sre.SRE_Match object at 0xb72cd6e8&gt; #匹配到了，返回MatchObject（True）&gt;&gt;&gt;m = re.search('asd','ASDASD')&gt;&gt;&gt;mNone #没有匹配到，返回None（False） 5）re.finditer(pattern, string, flags=0) finditer与findall相似，只不过finditer返回一个迭代器,通过group()可以获取值,搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。 123456iter = re.finditer(r'\d+','12 drumm44ers drumming, 11 ... 10 ...')for i in iter: print('*'*20) print(i) print(i.group()) print(i.span()) 执行结果如下： 12345678910111213141516********************&lt;re.Match object; span=(0, 2), match=&apos;12&apos;&gt;12(0, 2)********************&lt;re.Match object; span=(8, 10), match=&apos;44&apos;&gt;44(8, 10)********************&lt;re.Match object; span=(24, 26), match=&apos;11&apos;&gt;11(24, 26)********************&lt;re.Match object; span=(31, 33), match=&apos;10&apos;&gt;10(31, 33) 6）re.sub(pattern, repl, string, count=0, flags=0) sub按照给定的规则将string字符串中的相应的片段替换为repl，count 最多替换的次数，count=0默认为全部替换，返回替换后的字符串 12&gt;&gt;&gt; re.sub(r"\d+", "$", "aaa1bb2ccc333") # 将连续的数字变成"$"'aaa$bb$ccc$' re.sub还允许使用函数对匹配项的替换进行复杂的处理。 如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。 12345import retext = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;print(re.sub(r&apos;\s+&apos;, lambda m:&apos;[&apos;+m.group(0)+&apos;]&apos;, text,0))执行结果如下：JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on... 7）re.subn(pattern, repl, string, count=0, flags=0) 返回替换次数，与sub相似，count 最多替换的次数，count=0默认为全部替换，返回 一个元组，下标0为替换后的字符串，下标1成功替换的次数 123456781 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaabbccc&quot;)2 (&apos;aaabbccc&apos;, 0) #未出现替换3 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;)4 (&apos;aaa$bb$ccc&apos;, 2) #成功替换了两次5 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 1) # 最多替换1次6 (&apos;aaa$bb22ccc&apos;, 1)7 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 10) # 最多替换10次8 (&apos;aaa$bb$ccc&apos;, 2) # 成功替换2次 8）re.split(pattern, string, maxsplit=0, flags=0) 通过给定规则，将string进行切割，maxsplit最多切割次数，maxsplit=0默认全部切割，返回一个列表 1234561 &gt;&gt;&gt; re.split(r&quot;@&quot;, &quot;a#b#c#d#e&quot;) # 没有找到&quot;@&quot;，不切割2 [&apos;a#b#c#d#e&apos;]3 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;) # 按&quot;#&quot;对字符串进行切割4 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]5 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;, 2) # 按&quot;#&quot;对字符串进行切割，最多切割2次6 [&apos;a&apos;, &apos;b&apos;, &apos;c#d#e&apos;] 9）group：获取子模式(组)的匹配项 match和search一旦匹配成功，就是一个match object对象，需要用group()才可以打印匹配到的字符串。 b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常c.groups（）方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 123456789101112131415161718&gt;&gt;&gt;pat = re.compile(r&apos;www\.(.*)\.(.*)&apos;) #用()表示1个组，2个组&gt;&gt;&gt;m = pat.match(&apos;www.dxy.com&apos;)&gt;&gt;&gt;m&lt;re.Match object; span=(0, 11), match=&apos;www.dxy.com&apos;&gt;&gt;&gt;&gt;m.group() #默认为0，表示匹配整个字符串 &apos;www.dxy.com&apos;&gt;&gt;&gt;m.group(1) #返回给定组1匹配的子字符串&apos;dxy&apos;&gt;&gt;&gt;m.group(2)&apos;com&apos;&gt;&gt;&gt;m.groups()(&apos;dxy&apos;, &apos;com&apos;)&gt;&gt;&gt;m.start(2) #组2开始的索引8&gt;&gt;&gt;m.end(2) #组2结束的索引11&gt;&gt;&gt;m.span(2) #组2开始、结束的索引(8, 11) 10)贪婪匹配与非贪婪匹配 贪婪匹配，也就是尽可能多的匹配，后面加?号使其变成惰性匹配 1234567891011121314a = re.findall(r&quot;a(\d+?)&quot;,&apos;a23b&apos;)print(a)b = re.findall(r&quot;a(\d+)&quot;,&apos;a23b&apos;)print(b)执行结果：[&apos;2&apos;][&apos;23&apos;]a = re.match(&apos;&lt;(.*)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()print(a)b = re.match(&apos;&lt;(.*?)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()print(b)执行结果：&lt;H1&gt;title&lt;H1&gt;&lt;H1&gt; 最后：用flags时遇到的小坑 1234print(re.split(&apos;a&apos;,&apos;1A1a2A3&apos;,re.I))#输出结果并未能区分大小写这是因为re.split(pattern，string，maxsplit,flags)默认是四个参数，当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用。如果想让这里的re.I起作用，写成flags=re.I即可。]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器设置字体大小颜色]]></title>
    <url>%2F2019%2F07%2F22%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。 字体，字号和颜色: 123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 呈现效果如下： 我是黑体字我是微软雅黑我是华文彩云color=#0099ffcolor=#00ffffcolor=gray 颜色对应表： 颜色名 十六进制颜色值 颜色 AliceBlue #F0F8FF rgb(240, 248, 255) AntiqueWhite #FAEBD7 rgb(250, 235, 215) Aqua #00FFFF rgb(0, 255, 255) Aquamarine #7FFFD4 rgb(127, 255, 212) Azure #F0FFFF rgb(240, 255, 255) Beige #F5F5DC rgb(245, 245, 220) Bisque #FFE4C4 rgb(255, 228, 196) Black #000000 rgb(0, 0, 0) BlanchedAlmond #FFEBCD rgb(255, 235, 205) Blue #0000FF rgb(0, 0, 255) BlueViolet #8A2BE2 rgb(138, 43, 226) Brown #A52A2A rgb(165, 42, 42) BurlyWood #DEB887 rgb(222, 184, 135) CadetBlue #5F9EA0 rgb(95, 158, 160) Chartreuse #7FFF00 rgb(127, 255, 0) Chocolate #D2691E rgb(210, 105, 30) Coral #FF7F50 rgb(255, 127, 80) CornflowerBlue #6495ED rgb(100, 149, 237) Cornsilk #FFF8DC rgb(255, 248, 220) Crimson #DC143C rgb(220, 20, 60) Cyan #00FFFF rgb(0, 255, 255) DarkBlue #00008B rgb(0, 0, 139) DarkCyan #008B8B rgb(0, 139, 139) DarkGoldenRod #B8860B rgb(184, 134, 11) DarkGray #A9A9A9 rgb(169, 169, 169) DarkGreen #006400 rgb(0, 100, 0) DarkKhaki #BDB76B rgb(189, 183, 107) DarkMagenta #8B008B rgb(139, 0, 139) DarkOliveGreen #556B2F rgb(85, 107, 47) Darkorange #FF8C00 rgb(255, 140, 0) DarkOrchid #9932CC rgb(153, 50, 204) DarkRed #8B0000 rgb(139, 0, 0) DarkSalmon #E9967A rgb(233, 150, 122) DarkSeaGreen #8FBC8F rgb(143, 188, 143) DarkSlateBlue #483D8B rgb(72, 61, 139) DarkSlateGray #2F4F4F rgb(47, 79, 79) DarkTurquoise #00CED1 rgb(0, 206, 209) DarkViolet #9400D3 rgb(148, 0, 211) DeepPink #FF1493 rgb(255, 20, 147) DeepSkyBlue #00BFFF rgb(0, 191, 255) DimGray #696969 rgb(105, 105, 105) DodgerBlue #1E90FF rgb(30, 144, 255) Feldspar #D19275 rgb(209, 146, 117) FireBrick #B22222 rgb(178, 34, 34) FloralWhite #FFFAF0 rgb(255, 250, 240) ForestGreen #228B22 rgb(34, 139, 34) Fuchsia #FF00FF rgb(255, 0, 255) Gainsboro #DCDCDC rgb(220, 220, 220) GhostWhite #F8F8FF rgb(248, 248, 255) Gold #FFD700 rgb(255, 215, 0) GoldenRod #DAA520 rgb(218, 165, 32) Gray #808080 rgb(128, 128, 128) Green #008000 rgb(0, 128, 0) GreenYellow #ADFF2F rgb(173, 255, 47) HoneyDew #F0FFF0 rgb(240, 255, 240) HotPink #FF69B4 rgb(255, 105, 180) IndianRed #CD5C5C rgb(205, 92, 92) Indigo #4B0082 rgb(75, 0, 130) Ivory #FFFFF0 rgb(255, 255, 240) Khaki #F0E68C rgb(240, 230, 140) Lavender #E6E6FA rgb(230, 230, 250) LavenderBlush #FFF0F5 rgb(255, 240, 245) LawnGreen #7CFC00 rgb(124, 252, 0) LemonChiffon #FFFACD rgb(255, 250, 205) LightBlue #ADD8E6 rgb(173, 216, 230) LightCoral #F08080 rgb(240, 128, 128) LightCyan #E0FFFF rgb(224, 255, 255) LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210) LightGrey #D3D3D3 rgb(211, 211, 211) LightGreen #90EE90 rgb(144, 238, 144) LightPink #FFB6C1 rgb(255, 182, 193) LightSalmon #FFA07A rgb(255, 160, 122) LightSeaGreen #20B2AA rgb(32, 178, 170) LightSkyBlue #87CEFA rgb(135, 206, 250) LightSlateBlue #8470FF rgb(132, 112, 255) LightSlateGray #778899 rgb(119, 136, 153) LightSteelBlue #B0C4DE rgb(176, 196, 222) LightYellow #FFFFE0 rgb(255, 255, 224) Lime #00FF00 rgb(0, 255, 0) LimeGreen #32CD32 rgb(50, 205, 50) Linen #FAF0E6 rgb(250, 240, 230) Magenta #FF00FF rgb(255, 0, 255) Maroon #800000 rgb(128, 0, 0) MediumAquaMarine #66CDAA rgb(102, 205, 170) MediumBlue #0000CD rgb(0, 0, 205) MediumOrchid #BA55D3 rgb(186, 85, 211) MediumPurple #9370D8 rgb(147, 112, 216) MediumSeaGreen #3CB371 rgb(60, 179, 113) MediumSlateBlue #7B68EE rgb(123, 104, 238) MediumSpringGreen #00FA9A rgb(0, 250, 154) MediumTurquoise #48D1CC rgb(72, 209, 204) MediumVioletRed #C71585 rgb(199, 21, 133) MidnightBlue #191970 rgb(25, 25, 112) MintCream #F5FFFA rgb(245, 255, 250) MistyRose #FFE4E1 rgb(255, 228, 225) Moccasin #FFE4B5 rgb(255, 228, 181) NavajoWhite #FFDEAD rgb(255, 222, 173) Navy #000080 rgb(0, 0, 128) OldLace #FDF5E6 rgb(253, 245, 230) Olive #808000 rgb(128, 128, 0) OliveDrab #6B8E23 rgb(107, 142, 35) Orange #FFA500 rgb(255, 165, 0) OrangeRed #FF4500 rgb(255, 69, 0) Orchid #DA70D6 rgb(218, 112, 214) PaleGoldenRod #EEE8AA rgb(238, 232, 170) PaleGreen #98FB98 rgb(152, 251, 152) PaleTurquoise #AFEEEE rgb(175, 238, 238) PaleVioletRed #D87093 rgb(216, 112, 147) PapayaWhip #FFEFD5 rgb(255, 239, 213) PeachPuff #FFDAB9 rgb(255, 218, 185) Peru #CD853F rgb(205, 133, 63) Pink #FFC0CB rgb(255, 192, 203) Plum #DDA0DD rgb(221, 160, 221) PowderBlue #B0E0E6 rgb(176, 224, 230) Purple #800080 rgb(128, 0, 128) Red #FF0000 rgb(255, 0, 0) RosyBrown #BC8F8F rgb(188, 143, 143) RoyalBlue #4169E1 rgb(65, 105, 225) SaddleBrown #8B4513 rgb(139, 69, 19) Salmon #FA8072 rgb(250, 128, 114) SandyBrown #F4A460 rgb(244, 164, 96) SeaGreen #2E8B57 rgb(46, 139, 87) SeaShell #FFF5EE rgb(255, 245, 238) Sienna #A0522D rgb(160, 82, 45) Silver #C0C0C0 rgb(192, 192, 192) SkyBlue #87CEEB rgb(135, 206, 235) SlateBlue #6A5ACD rgb(106, 90, 205) SlateGray #708090 rgb(112, 128, 144) Snow #FFFAFA rgb(255, 250, 250) SpringGreen #00FF7F rgb(0, 255, 127) SteelBlue #4682B4 rgb(70, 130, 180) Tan #D2B48C rgb(210, 180, 140) Teal #008080 rgb(0, 128, 128) Thistle #D8BFD8 rgb(216, 191, 216) Tomato #FF6347 rgb(255, 99, 71) Turquoise #40E0D0 rgb(64, 224, 208) Violet #EE82EE rgb(238, 130, 238) VioletRed #D02090 rgb(208, 32, 144) Wheat #F5DEB3 rgb(245, 222, 179) White #FFFFFF rgb(255, 255, 255) WhiteSmoke #F5F5F5 rgb(245, 245, 245) Yellow #FFFF00 rgb(255, 255, 0) YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm控制台打印带颜色]]></title>
    <url>%2F2019%2F07%2F22%2Fpycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[​ 在python开发的过程中，经常会遇到需要打印各种信息。海量的信息堆砌在控制台中，就会导致信息都混在一起，降低了重要信息的可读性。这时候，如果能给重要的信息加上字体颜色，那么就会更加方便用户阅读了。 当然了，控制台的展示效果有限，并不能像前段一样炫酷，只能做一些简单的设置。不过站在可读性的角度来看，已经好很多了。 书写格式： 开头部分：\033[显示方式;前景色;背景色m +内容+ 结尾部分：\033[0m ​ 注意：开头部分的三个参数：显示方式，前景色，背景色是可选参数，可以只写其中的某一个；另外由于表示三个参数不同含义的数值都是唯一的没有重复的，所以三个参数的书写先后顺序没有固定要求，系统都能识别；但是，建议按照默认的格式规范书写。 ​ 对于结尾部分，其实也可以省略，但是为了书写规范，建议\033[***开头，\033[0m结尾。 数值表示的参数含义： 显示方式: 0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、 5（闪烁）、25（非闪烁）、7（反显）、27（非反显）前景色: 30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋 红）、36（青色）、37（白色）背景色: 40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋 红）、46（青色）、47（白色） 常见开头格式：\033[0m 默认字体正常显示，不高亮\033[32;0m 红色字体正常显示\033[1;32;40m 显示方式: 高亮 字体前景色：绿色 背景色：黑色\033[0;31;46m 显示方式: 正常 字体前景色：红色 背景色：青色 \033[1;31m 显示方式: 高亮 字体前景色：红色 背景色：无 示例格式1： 1234print('\033[1;35;0m字体变色，但无背景色 \033[0m') # 有高亮 或者 print('\033[1;35m字体有色，但无背景色 \033[0m')print('\033[1;45m 字体不变色，有背景色 \033[0m') # 有高亮print('\033[1;35;46m 字体有色，且有背景色 \033[0m') # 有高亮print('\033[0;35;46m 字体有色，且有背景色 \033[0m') # 无高亮 示例格式2： 123print('\033[0;36m')print('hello world!')print('\033[0m') 参考自博客[老虎死了还有狼],更多展示效果请点击此处.]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序初识]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[新创建的小程序项目，会默认生成一份demo代码，用于展示代码结构. 新建项目已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。 下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。 1、app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 2、 app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 3、app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 我们注意到，在实例程序的代码中还有2个文件夹，一个是pages,一个是utils,其中utils是放通用工具类方法的一个文件夹，pages是存放所有页面的文件夹。我们着重讲一下这个pages. 第五步：小程序页面文件构成 在这个示例中，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。 每一个小程序页面是由同路径下同名的四个不同后缀文件组成的，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。 index.wxml 是页面的结构文件： 12345678910111213&lt;!--index.wxml--&gt;&lt;view class="container"&gt;&lt;view class="userinfo"&gt;&lt;button wx:if="&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; 获取头像昵称 &lt;/button&gt;&lt;block wx:else&gt;&lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" mode="cover"&gt;&lt;/image&gt;&lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;&lt;/block&gt;&lt;/view&gt;&lt;view class="usermotto"&gt;&lt;text class="user-motto"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;/view&gt; 本例中使用了view,image,text、button等组件来搭建页面结构，绑定数据和交互处理函数。 index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//index.js//获取应用实例const app = getApp()Page(&#123;data: &#123;motto: 'Hello World',userInfo: &#123;&#125;,hasUserInfo: false,canIUse: wx.canIUse('button.open-type.getUserInfo')&#125;,//事件处理函数bindViewTap: function() &#123;wx.navigateTo(&#123;url: '../logs/logs'&#125;)&#125;,onLoad: function () &#123;if (app.globalData.userInfo) &#123;this.setData(&#123;userInfo: app.globalData.userInfo,hasUserInfo: true&#125;)&#125; else if (this.data.canIUse)&#123;// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回// 所以此处加入 callback 以防止这种情况app.userInfoReadyCallback = res =&gt; &#123;this.setData(&#123;userInfo: res.userInfo,hasUserInfo: true&#125;)&#125;&#125; else &#123;// 在没有 open-type=getUserInfo 版本的兼容处理wx.getUserInfo(&#123;success: res =&gt; &#123;app.globalData.userInfo = res.userInfothis.setData(&#123;userInfo: res.userInfo,hasUserInfo: true&#125;)&#125;&#125;)&#125;&#125;,getUserInfo: function(e) &#123;console.log(e)app.globalData.userInfo = e.detail.userInfothis.setData(&#123;userInfo: e.detail.userInfo,hasUserInfo: true&#125;)&#125;&#125;) index.wxss 是页面的样式表： 123456789101112131415161718192021/**index.wxss**/.userinfo &#123;display: flex;flex-direction: column;align-items: center;&#125;.userinfo-avatar &#123;width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;&#125;.userinfo-nickname &#123;color: #aaa;&#125;.usermotto &#123;margin-top: 200px;&#125; 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。 index.json 是页面的配置文件： 页面的配置文件也是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。 logs 的页面结构: 123456&lt;!--logs.wxml--&gt;&lt;view class="container log-list"&gt; &lt;block wx:for-items="&#123;&#123;logs&#125;&#125;" wx:for-item="log"&gt; &lt;text class="log-item"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt; &lt;/block&gt;&lt;/view&gt; logs 页面使用 block 控制标签来组织代码，在 &lt;/block&gt; 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点 1234567891011121314//logs.jsvar util = require('../../utils/util.js')Page(&#123; data: &#123; logs: [] &#125;, onLoad: function () &#123; this.setData(&#123; logs: (wx.getStorageSync('logs') || []).map(function (log) &#123; return util.formatTime(new Date(log)) &#125;) &#125;) &#125;&#125;) 第五步：手机预览 点击开发工具的顶部工具栏中的”预览”，即可生成预览二维码，用微信扫码后即可在微信客户端中预览体验 以上便是微信小程序前端开发的基本流程，而实际上要做一个内容可以更新的小程序，单有前端开发是远远不够的，还需要后台开发。后台开发与web开发的后台基本无异，可以选择用java、php、nodejs等任一语言，有一点需要注意的是小程序后台服务器必须是https协议的，这就要求必须购买云服务器并将后台服务器设置成https服务。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中列表(list)排序的一些常见操作]]></title>
    <url>%2F2019%2F06%2F18%2Fpython%E4%B8%AD%E5%88%97%E8%A1%A8-list-%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[对列表排序一般有两种操作:my_list.sort()和sorted(my_list) 1.使用sort排序 1234my_list = [3, 5, 1, 4, 2]my_list.sort()print(my_list)#输出[1,2,3,4,5] 2.使用sorted排序 1234my_list = [3, 5, 1, 4, 2]my_list_1=sorted(my_list)print(my_list_1)#输出[1,2,3,4,5] 可以看出操作有所不同，使用sort()方法对list排序会修改list本身,不会返回新list，而sorted()方法不会对原list进行修改，而是返回一个新list，但是如果你不需要保留原来的list，此方法将更有效sort()。 另外sort()不能对dict字典进行排序，如果sort()里面不填参数，即默认升序，若要降序只需my_list.sort(reverse=True),(True降序，False升序(sorted()操作与之一样)) 3.列表里嵌套列表且里面的列表有多个值，并指定以第几个值进行排序 1234#指定第二个进行升序排序users=[[1,4],[5,6],[4,6]]user=sorted(users,key=lambda x:x[1])users.sort(key=lambda x:x[1]) 123#指定第二个升序排序，如果第二个相等，则以第一个排序user=sorted(users,key=lambda x:(x[1],x[0]))users.sort(key=lambda x:(x[1],x[0]) 123#指定第二个升序排序，如果第二个相等，则以第一降序排列s=sorted(users,key=lambda x:(x[1],-x[0]))users.sort(key=lambda x:(x[1],-x[0]) 123#指定第二个降序排序，如果第二个相等，则以第一升序排列s=sorted(users,key=lambda x:(-x[1],x[0]))users.sort(key=lambda x:(-x[1],x[0])]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中一些常见的问题]]></title>
    <url>%2F2019%2F06%2F04%2Fpytohn%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.为什么import 调用的模块 在pycharm中 会有红色的波浪线？ 是因为该模块为第三方库，你未导入，进行导入就可以了，一般用pip指令导入比较方便 2.为什么用import 调用模块有的’import’显示灰色,有的显示高亮？ 灰色是表示没有用到这个模块里的任何一个东西，可以把这一行去掉的。 3.selenium的使用 1.运行报错： 12driver = webdriver.chrome()TypeError: 'module' object is not callable ​ 解决方案：浏览器的名称需要大写，即Chrome和Firefox 2.selenium中安装chrome浏览器驱动(chomedriver) ​ 1.下载对应版本的chromedriver 下载地址：点这里 选择需要的浏览器驱动版本，点击**notes.txt**可以查看当前版本支持的浏览器版本，确定是否下载。 ​ 2.解压复制chromedriver.exe到chrome浏览器的安装目录(C:\Program Files (x86)\Google\Chrome\Application) ​ 如果找不到此文件夹就将此文件解压到和你py文件同一个文件夹下，正常启动即可。 ​ 3.启动脚本，浏览器正常打开 ​ 使用格式 driver = webdriver.Chrome() 4.try -except 异常处理： 123456789101112131415 try: A except: B except会捕获所有异常，包括键盘中断和程序退出请求（用sys.exit()就无法退出程序了，因为异常被捕获了），因此慎用。 except Exception as e:可以捕获除与程序退出sys.exit()相关之外的所有异常 老版本的Python，except语句写作"except Exception, e"，Python 2.6后应写作"except Exception as e", except &lt;异常名1,异常名2&gt;:&lt;数据&gt;:捕获异常名1或者异常名2,及附加的数据库 例如： try: print (2/0)except (IOError,ZeroDivisionError): print( '类型异常') 12345678关键字 关键字说明raise 抛出/引发异常try/except 捕获异常并处理pass 忽略异常as 定义异常实例(except IOError as e)finally 无论是否出现异常，都执行的代码else 如果try中的语句没有引发异常，则执行else中的语句 ​ 常用异常名： 1234567891011121314151617181920212223异常名 描述 AttributeError 调用不存在的方法引发的异常 EOFError 遇到文件末尾引发的异常 ImportError 导入模块出错引发的异常 IndexError 列表越界引发的异常 IOError I/O操作引发的异常，如打开文件出错等 KeyError 使用字典中不存在的关键字引发的异常 NameError 使用不存在的变量名引发的异常 TabError 语句块缩进不正确引发的异常 ValueError 搜索列表中不存在的值引发的异常 ZeroDivisionError 除数为零引发的异常 使用raise 引发异常几种方式： raise 异常名 raise 异常名,附加数据 raise 类名 assert 简化了raise语句： 需要注意的是，assert语句一般用于开发时对程序条件的验证，只有当内置_debug_为True时，assert语句才有效。当Python脚 本以-O选项编译成为字节码文件时，assert语句将被移除。 但与raise语句不同的是，assert语句是在条件测试为假时，才引发异常。assert语言的一般形式如下： assert&lt;条件测试&gt;,&lt;异常附加数据&gt;#其中异常附加数据是可选的 5.try-finally:异常处理 1.无论try语句中是否抛出异常，finally中的语句一定会被执行 12345678try: f = open("/tmp/output", "w") f.write("hello") #raise Exception("something wrong")finally: print("closing file") f.close() ​ 不论try中写文件的过程中是否有异常，finally中关闭文件的操作一定会执行。由于finally的这个特性，finally经常被用来做 一些清理工作。 2.try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行。 12345678def func1(): try: print('a') return 1 finally: print('A') return 2print(func1()) 1234运行结果为：aA2 ​ 再例如： 1234567891011def func2(): try: print('b') raise IOError#指定引发异常 except IndexError: print('B') return 1 finally: print('X') return 3 print(func1()) 1234运行结果为：bX3 ​ try中抛出的异常是IOError类型的，而except中定位的是IndexError类型的，try中抛出的异常没有被捕获到，所以except中 的语句没有被执行，但不论异常有没有被捕获，finally还是会执行，最终函数返回了finally中的返回值3。 ​ 这里还可以看到另外一个问题。try中抛出的异常没有被捕获到，按理说当finally执行完毕后，应该被再次抛出，但finally里 执行了return，导致异常被丢失。​ 可以看到在finally中使用return会导致很多问题。实际应用中，不推荐在finally中使用return返回。 6.def函数中的一些问题 1.返回值问题： 返回个数：(不涉及*args和**kwargs参数) ​ 0：返回None ​ 1：返回object ​ =&gt;2：返回tuple 2.形参与实参问题： 问题1： 1234&gt; &gt; &gt; &gt; &gt; &gt; def text1(x,y):&gt; &gt; &gt; &gt; &gt; &gt; print(x,y)&gt; &gt; &gt; &gt; &gt; &gt; print(1,2)&gt; &gt; &gt; &gt; &gt; &gt; 输出结果为：1,2如果这样赋值：text1(y=1,x=2)#与形参顺序无关则输出结果为：2,1即如果你不指定赋值，它会默认与形参一一对应你也可以 text1(1,y=2)，但不可以text1(x=1,2)或text1(y=1,2). 问题2： 12def text2(x,y=2): print(x,y) 你可以给形参赋个初值你就可以这样调用text2(1),输出结果为：1,2因为你给y形参已赋初值，如果你调用时未给y赋值，它会默认y=2如果你这样调用 text2(1,3),则输出结果为：1,3. 问题3： 问题1与问题2都是传参个数必须与形参个数相等接下来写一种个数不用相等的方式 12345678#*args:把N个位置参数转化为元组的形式def text3(*args): print(args)text3(1)text3(1,2,3)#或text3(*[1,2,3])#则结果分别为：1(1,2,3) #以元组(tuple)的方式返回. 1234567def text4(x,*args): print(x) print(args)text4(1,2,3,4,5)#则运行结果为：1(2,3,4,5) 另一种方式：#**kwargs:把N个关键字参数转化为字典的形式 12345def text5(**kwargs): print(kwargs)text5(name='Lihua',age=18,sex='M')#运行结果为：&#123;'name':'Lihua','age'=18,'sex'='M'&#125;#以字典的形式返回 注意：args和kwargs都必须放在最后]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019蓝桥杯国赛C++B组]]></title>
    <url>%2F2019%2F05%2F27%2F2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9BC-B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[​ 比赛结束的第二天，坐标HPU，此次的蓝桥杯国赛其实收获挺多的，也是第一次来北京，还是借着公费的理由进行的旅游，哈哈哈，北京三日游很奈斯，本以为会混个国优，空手而归呢，第二天上午官网一查成绩，震惊，还混了个国三，哈哈哈，心想就做出来两个填空题，还能国三，可想蓝桥杯多水了，都说蓝桥杯是暴力杯，啊啊啊，我竟然没想到暴力，不然可能就国二了，甚至国一(国特做梦可以想想)，本来一道编程大题，可以暴力打表多混点分呢，时间都浪费在了某坑爹的用dfs跑的填空题上了 ，一直调试还是未果(浪费那么多时间做出来还好嘛，然鹅 汗，15分啊 啊啊啊)，心桑啊，不过虽然不是很理想，但对我来说已经很奈斯了. ​ 昨天在北大体育馆举行的颁奖仪式，不过只颁发特等奖，国一二三也不知道有没有奖品，羡慕国特的华为笔记本和华为手机一部(不羡慕，不嫉妒，直接恨)。印象最深的只记得北大欠我两瓶可乐，记心里啦，进场不让带吃的喝的，安检人员说，你出来如果还有，你就拿，没有的话就不拿，我们不负责保管，然而出来去一看，果然啥都没了，啊啊啊，好气哟.不过颁奖典礼体验挺棒的 ，尤其是北大小姐姐们跳到舞蹈，哈哈哈. 奈斯到爆哦，其他不多说了，北京之旅完美谢幕，再见北京！！！ ​ 简单说一下题目，每年国赛都是六道，今年十道，大概因为是今年是蓝桥杯十周年吧，具体题目忘了，大致描述一下我会的几题吧 A题： 2019 x y 三个数形成等差数列，问x+y最小值为多少？我觉得这是最水的题了 利用等差数列 两项之差相等就行了代码如下： 1234567891011121314#include&lt;bits/stdc++.h&gt;typedef long long ll;ll minn = 0x3f3f3f3f;ll n=10000;using namespace std;int main()&#123; for(ll i=0;i&lt;=n;i++)//如果怕范围小，可以把n定义大一点 for(ll j=i+1;j&lt;=n;j++) if(i*i-2019*2019==j*j-i*i) minn=min(minn,i+j); printf("%lld\n",minn); return 0;&#125; B题：2019分成若干个两两不相等的质数和，问有多少种符合的分法？ 据说是01背包，不会写 跳过，后续会的话再补 D题：应该是 求谁的约数个数等于100，例如S1=1，S2=2，S4=3，S6=4… 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[10000];int main()&#123; for(int k=1;k&lt;=1000000;k++) &#123; int n=k; int s=1; a[0]=1; for(int i=2;i&lt;=k;i++) if(n%i==0) a[s++]=i; //打印每个数的约数进行验证 //printf("%d: ",k); // for(int j=0;j&lt;s;j++) // printf("%d ",a[j]); // puts(""); if(s==100) &#123; printf("%d\n",k); break; &#125; &#125; return 0;&#125; E题：是5*5的方格从左上角出发沿边走然后回到左上角，问有多少种走法，其中步数不能超过12步，并且同一个边不能走两遍 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int dx[4]=&#123;1,0,0,-1&#125;,dy[4]=&#123;0,1,-1,0&#125;;int vis[10][10];int a[10][10];int s=0,ans=0;int kk,zz;void dfs(int x,int y)&#123; for(int i=0;i&lt;4;i++)&#123; int xx=x+dx[i]; int yy=y+dy[i]; if( xx&gt;=0&amp;&amp;xx&lt;6&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;6 &amp;&amp; !vis[xx][yy] &amp;&amp; s&lt;=12)&#123; if(xx!=0||yy!=0) vis[xx][yy]=1; s++; if(xx==0 &amp;&amp; yy==0)&#123; ans++;// printf("方案 %d:\n",ans); // for(int i=0;i&lt;6;i++)// &#123;// for(int j=0;j&lt;6;j++)// &#123;// printf("%d ",vis[i][j]);// &#125;// puts("");// &#125; // puts(""); &#125; dfs(xx,yy); vis[xx][yy]=0; s--; &#125; &#125;&#125;int main()&#123; memset(vis,0,sizeof(vis)); //freopen("text.txt","w",stdout); dfs(0,0); printf("总方案数：%d\n",ans-2); return 0;&#125; 待续。。。]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断是否为素数，一些优化方式]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[素数判断是acm及各种比赛中频繁出现的内容，也是最基础的，所以一定要完全掌握，下面就介绍几种常用的素数判断的优化方法。 1.(1)先说最简单的吧，复杂度o(n),也是最容易想到的 1234567int flag=1;for(int i=2;i&lt;n;i++)&#123; if(n%i==0)&#123; flag=0;//如果flag==0则说明n是非素数 break; &#125;&#125; (2)对于一般题目来说往往会超时的，所以可以将其复杂度降至o(sqrt(n))123456for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; flag=0; break; &#125;&#125; (3还有一种更高级优化，可以将其复杂度降至o(sqrt(n)/3),首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等； 证明：令x≥1，将大于等于5的自然数表示如下： ··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ··· 可以看到，不和6的倍数相邻的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到sqrt(n)中每6个数只判断2个，时间复杂度O(sqrt(n)/3)。 在(2)(3)(4)中，都是一个剪枝的思想，(3)中裁剪了不必要的偶数，(4)中裁剪了不和6 的倍数相邻的数，虽然都没有降低时间复杂度的阶数，但都一定程度上加快了判断的速度。 123456789if(n%6!=1&amp;&amp;n%6!=5) flag=0;for(int i=5;i*i&lt;=n;i+=6)&#123; if(n%i==0||n%(i+2)==0) &#123; flag=0;break; &#125;&#125; 2.再说下打表法吧，就是你先开一个bool型数组(int型，也行，不过bool稍微快一点，数组大小须是&lt;=所求最大数的大小)，这个缺点就是数据最大不能超过数组的最大范围(一般在1e8以内) 复杂度o(nlogn) 12345678910111213void dabiao()&#123; memset(vis,false,sizeof(vis));//先初始化为false，不是素数的标为true vis[0]=vis[1]=true; for(int i=2;i*i&lt;=n;i++) &#123; if(!vis[i]) &#123; for(int j=i*i;j&lt;=n;j+=i) vis[j]=true;//素数(除了本身)它的所有倍数即为非素数，然后把他的倍数全标记为true &#125; &#125; &#125; 新手上路不喜勿喷，后续如有发现错误，会及时修正的。]]></content>
      <tags>
        <tag>判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛13 I题(博弈论)]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-I%E9%A2%98-%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[题目：[链接] 题目描述： 小A也听说了取石子这个游戏，也决定和小B一起来玩这个游戏。总共有n堆石子，双方轮流取石子，每次都可以从任意一堆中取走任意数量的石子，但是不可以不取。规定谁先取完所有的石子就获胜。但是小A实在是太想赢了，所以在游戏开始之前，小A有一次机会，可以趁小B不注意的时候选择其中一堆石子拿走其中的k个，当然小A也可以选择不拿石子。小A先手。双方都会选择最优的策略，请问在这样的情况下小A有没有必胜的策略，如果有输出YES，否则就输出NO。 输入描述： 一行两个整数N,K，表示分别有N堆石子以及小A可以拿走的石子个数k。接下来N个整数表示每一堆的石子个数 a[i]. 输出描述： 一行一个结果表示小A是否有必胜策略，如果有则输出YES，否则输出NO。 输入： 123 21 1 1 输出： 1YES 备注： 11≤N≤1e5，1≤a[i]≤1e5，0≤K≤1e5 经过分析很容易发现此题是Nim游戏，也是经典的博弈论，关于Nim游戏详解[点这里]，对于此题，先不考虑K，将所有的a[i]异或，如果a[i]的异或值非0，则小A有必胜的策略，否则小B有必胜的策略，此题在于怎样处理K，K的意思就是小A可以比小B多操作一次，可以从任意一堆拿走k个，或选择不拿，所以有两种情况，拿或不拿，对于所有a[i]进行遍历，就看这两种情况，哪一种情况异或值是非零，如果出现非零，则小A必胜，遍历结束，仍未出现非零，则小B必胜. AC代码如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;typedef long long ll;const int mod=1e9+7;using namespace std;int a[100003];int main() &#123; int n,k; int sum=0,flag=0; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); sum^=a[i]; &#125; if(sum!=0)flag=1; for(int i=0;i&lt;n;i++) &#123; sum^=a[i];//例如a[0]^a[1]^a[2]=sum,则a[1]^a[2]=sum^a[0] if(a[i]&gt;=k)//判断k能不能拿，能拿的话，是否能出现想要的结果 &#123; sum^=(a[i]-k); if(sum!=0)flag=1; &#125; &#125; if(flag) puts("YES"); else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛13 D题(位运算)]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-D%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目：[链接] 题目描述： 位运算是一个非常重要的东西。而小A最近在学习位运算，小A看到了一道很简单的例题，是说从N个数里面选出N-1个数要让它们或起来的值最大，小A想知道这个答案是多少。你可以帮帮他吗？ 输入描述： 1第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN 输出描述： 1一行输出个结果代表最大值一行输出个结果代表最大值 输入： 1251 2 4 8 16 输出： 130 说明： 123选择2,4,8,16或的和是最大的，没有比这个更大的方案。1≤N≤5e6，1≤Ai≤longlong 第一次看到题，直接上去sort排序，从第二个开始或运算和(贼尴尬啊)，肯定秒WA啊，原来没想象的那么水哇，这题恶心就恶心到n个数就让你或运算n-1个(或运算n个就多好)，后来通过大神室友的指点，略懂一二，我试着解释解释吧，或运算 1|1=1，1|0=1,0|0=0，此题就是每个数值位1，0之间的或运算(最下面有后续) 此题思路就是，将每数位1的个数记录下来 比如 n个数每个位上的1的总个数为 4 2 5 1 3 1 对a[i]进行遍历， 例如a[0]=5转化为二进制 0 0 0 1 0 1 对应位上减掉1的个数 则变成 4 2 5 0 3 0 则此时最大值即是 1 1 1 0 1 0 (即是各位置剩余1的个数&gt;=1 即对应的值为1)此时的十进制为2^5+2^4+2^3+2^1 将此时的最大值保存下来 然后继续对a[i]重复进行上面的操作，每次保存下来最大值 遍历结束 AC代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef long long ll;const int mod=1e9+7;using namespace std;ll a[500003];int bits[64],c[64];int main() &#123; int n; ll maxx=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%lld",&amp;a[i]); for(int j=0;j&lt;64;j++)//题上范围long long 最大2^63-1，所以定义64，也可以先求出a[i]的最大值，来获得最高位 if(a[i]&gt;&gt;j&amp;1) bits[j]++; &#125; for(int i=0;i&lt;n;i++) &#123; memset(c,0,sizeof(c));//c数组用来存放当前最大或值 for(int j=0;j&lt;64;j++) &#123; if(a[i]&gt;&gt;j&amp;1) &#123; if(bits[j]-1&gt;=1) c[j]=1; &#125; else &#123; if(bits[j]&gt;=1) c[j]=1; &#125; &#125; ll sum=0; for(int x=0;x&lt;64;x++) sum+=c[x]*pow(2,x); maxx=max(maxx,sum); &#125; printf("%lld\n",maxx); return 0;&#125; 后续补充： 无意中看到大佬利用前缀和与后缀和求的，思路比这个清晰，简单(还是自己太菜，当时没想到)，下面就简单分享下思路， 先用一个数组保存下所有的或前缀和，再用另一个数组保存所有的或后缀和，然后保存前缀和与后缀和或的最大值即可 ， pre[i] | suf[i+2]，具体代码如下： 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;typedef long long ll;const int mod=1e9+7;using namespace std;ll a[500003];ll pre[500003],suf[500003];int main() &#123; int n; ll maxx=0; scanf("%d",&amp;n); memset(pre,0,sizeof(pre)); memset(suf,0,sizeof(suf)); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); pre[i]=pre[i-1]|a[i];//求或的前缀和 &#125; for(int i=n;i&gt;=1;i--) suf[i]=suf[i+1]|a[i];//求或的后缀和 maxx=suf[2];//先把第一个元素不取的或的和赋值给maxx for(int i=1;i&lt;=n-2;i++) maxx=max(maxx,pre[i]|suf[i+2]); //由题意知取n-1个元素，所以每次取前缀和然后隔一个元素的后缀和的或值，然后最大值保存在maxx中 maxx=max(maxx,pre[n-1]);//pre[n-1]即是最后一个元素不取的或值 printf("%lld\n",maxx); return 0;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶乘(factorial) 牛客小白月赛5]]></title>
    <url>%2F2019%2F04%2F12%2F%E9%98%B6%E4%B9%98-factorial-%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B5%2F</url>
    <content type="text"><![CDATA[题目链接：阶乘(factorial) 问题描述： 1! 2! 3! …n! 阶乘相乘的末尾零的个数 输入描述： 输入数据共一行，一个正整数n，意义如“问题描述”。输出描述： 输出一行描述答案： 一个正整数k，表示S的末尾有k个0 输入： 110 输出： 17 说明： 对于100%的数据，1&lt;=n&lt;=1e8 题目让求阶乘最后有几个0，即为该表达式的最后结果含有10的几次方的因子，直接求的话，不太好求 不妨转化一下思路，容易发现10的几次方都有一个通性：质因子只有2和5， 显然，阶乘中 质因子2的个数比5多。所以这个题可以转换为 求 因子5的个数，5的个数即是所求末尾0的个数，那么此题就迎刃而解了 AC代码如下： 1234567891011121314151617181920#include&lt;iostream&gt;typedef long long ll;using namespace std;int main()&#123; ll n, sum = 0, cnt = 0; cin &gt;&gt; n; for(int i = 5;i &lt;= n;i ++) &#123; ll t = i; while(t%5==0) &#123; cnt++; t /= 5; &#125; sum += cnt; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1285(拓扑排序模板)]]></title>
    <url>%2F2019%2F04%2F12%2FHDU-1285-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：HDU1285 Problem Description 有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。 Input 输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。 Output 给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。 Sample Input 12344 31 22 34 3 Sample Output 11 2 4 3 此题就是拓扑排序的模板题，关系中不能出现环,跑一边模板即可,既然没有环，那肯定有入度为零的点， 1.首先找到入度为零的点，然后将他的所有出边减掉， 2.然后在找下一个入度为零的点，同样将其所有的出边减掉，直到遍历完所有的点。 注意每找到一个入度为零的点就把它输出来，当然也可以保存到数组里，等遍历完所有点，再输出也行，要注意行末空格的处理 AC代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int pre[503][503],vis[503];void tuopu(int n)&#123; int ans=0,res; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0)//寻找入度为0的点 &#123; res=j; ans++; if(ans==1) printf("%d",res); else printf(" %d",res); break; &#125; &#125; vis[res]=-1;//等于-1说明已被访问过了 for(int k=0;k&lt;=n;k++) &#123; if(pre[res][k]==1)vis[k]--;//将入度为0的点它的出边剪掉 &#125; &#125;&#125;int main()&#123; int n,m,u,v; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; memset(pre,0,sizeof(pre)); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;u,&amp;v); if(pre[u][v]==0)//防止出现重边 &#123; pre[u][v]=1; vis[v]++;//记录点V的入度个数 &#125; &#125; tuopu(n); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1962-洛谷-斐波那契数列]]></title>
    <url>%2F2019%2F04%2F12%2FP1962-%E6%B4%9B%E8%B0%B7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：P1962 题目背景 大家都知道，斐波那契数列是满足如下性质的一个数列： • f(1) = 1 ， f(2) = 1 ， f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 输入格式： 第 1 行：一个整数 n 输出格式： 第 1 行： f(n) mod 1000000007 的值 输入样例#1: 15 输出样例#1： 15 输入样例#2： 110 输出样例#2： 155 说明 对于 60% 的数据： n ≤ 92 对于 100% 的数据： n在long long(INT64)范围内 ​ 根据数据范围这个题用打表或递归方法显然是超时的，所以就用到了矩阵快速幂，这一题难点就在于怎样构造矩阵，关于矩阵快速幂可以参考上篇博客矩阵快速幂纯模板这次主要讲述怎样构造矩阵， 对于 f(n)=f(n-1)+f(n-2)…这道题目的关键之处在于构造初始矩阵，矩阵快速幂是核心所在。 如何构造：各种构造方法点此处 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;struct st&#123; ll a[3][3];&#125;;st Martrix(st x,st y)&#123; st ans; memset(ans.a,0,sizeof(ans.a)); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) &#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%mod; &#125; return ans;&#125;st fast_power(st s,ll n)&#123; st res; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) &#123; if(i==j) res.a[i][j]=1; else res.a[i][j]=0; &#125; while(n) &#123; if(n&amp;1) res=Martrix(res,s); s=Martrix(s,s); n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll n; st s; scanf("%lld",&amp;n); if(n==1||n==2)puts("1"); else &#123; memset(s.a,0,sizeof(s.a)); s.a[0][0]=1;s.a[0][1]=1;s.a[1][0]=1; s=fast_power(s,n-2); printf("%lld\n",(s.a[0][0]+s.a[0][1])%mod); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>斐波那契</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3390(矩阵快速幂)]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%B4%9B%E8%B0%B7P3390-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[题目：P3390 题目描述：给定n*n的矩阵A，求A^k 输入格式：第一行，n,k第2至n+1行，每行n个数，第i+1行第j个数表示矩阵第i行第j列的元素 输出格式：输出A^k共n行，每行n个数，第i行第j个数表示矩阵第i行第j列的元素，每个元素模10^9+7 输入样例： 1232 11 11 1 输出样例： 121 11 1 快速矩阵模板题，直接套用模板即可 矩阵乘法不懂的同学点这里 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;typedef long long ll;const int mod=1e9+7;using namespace std;ll n;struct node&#123; ll a[101][101];&#125;;node Matrix(node x,node y)&#123; node s; memset(s.a,0,sizeof(s.a)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int z=0;z&lt;n;z++) s.a[i][j]=(s.a[i][j]+x.a[i][z]*y.a[z][j])%mod;//矩阵乘法计算 return s;&#125;node fast_power(node x,ll k)//快速幂运算&#123; node res; memset(res.a,0,sizeof(res)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(i==j) res.a[i][j]=1;//res为单位矩阵 while(k) &#123; if(k&amp;1) res=Matrix(res,x); x=Matrix(x,x); k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ll k; node pre; scanf("%lld%lld",&amp;n,&amp;k); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;pre.a[i][j]); pre=fast_power(pre,k); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-1;j++) printf("%d ",pre.a[i][j]); printf("%d\n",pre.a[i][n-1]); &#125; return 0; &#125;]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1094(拓扑排序)]]></title>
    <url>%2F2019%2F04%2F11%2Fpoj-1094-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：POJ1094 大致题意就是多组输入，输入n，m（可以视为n个点，有m个关系）m个关系在字母A-Z范围内，给你一些关系比如A&lt;B，就认为A到B之间有条有向路，可以分三种情况： 1.当出现了一组关系使图出现了环，则输出“Inconsistency found after K1 relations” 其中的K1就是在第几个关系出现了环，后面的关系就可以忽略不处理了 2.当还未输入完给的关系就确定了，n个点的关系，则后面的关系就不用处理了，直接输出“Sorted sequence determined after K2 relations: （点关系的顺序）.” K2是此时确定关系的点的个数； 3.当输入完给的关系，还未确定n个点的关系，则输出“Sorted sequence cannot be determined.” 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;string.h&gt;char a[5];int pre[300][300];//存放村庄之间的关系 1即相通（单向）0即无路int vis[1000],b[1000],c[1000];//vis记录通向该点的关系数（即入度）c[]存放确定关系的点int n,m;int tuopu()&#123; int rem,FLAG=1; for(int i=0;i&lt;n;i++) b[i]=vis[i]; int g=0; for(int i=0;i&lt;n;i++) &#123; int res=0; for(int j=0;j&lt;n;j++) &#123; if(b[j]==0)&#123; res++; rem=j; &#125; &#125; if(res&gt;1) //说明多个入度为零的点 即n个点的顺序不确定 &#123; FLAG=-1; &#125; if(res==0) return -2;//无入度为零的点 即出现环 b[rem]=-1;//把找到的入度为零的点 标记为-1 表示访问过了 c[g++]=rem; for(int k=0;k&lt;n;k++) if(pre[rem][k]) b[k]--; //把入度为零的点 它的出边去掉 &#125; return FLAG;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n+m)) &#123; memset(vis,0,sizeof(vis)); memset(pre,0,sizeof(pre)); int ans=0; for(int i=0;i&lt;m;i++) &#123; scanf("%s",a); if(ans) continue;//ans 如果是1 则说明已经出结果了，下面的关系就不用处理了。直接跳过即可 if(pre[a[0]-'A'][a[2]-'A']==0)//防止重边 &#123; pre[a[0]-'A'][a[2]-'A']=1; vis[a[2]-'A']++;//记录 a[2]点的入度个数 &#125; int s=tuopu(); if(s==-2)//即出现环了 &#123; printf("Inconsistency found after %d relations.\n",i+1);//即输出第几个关系出现了环 ans=1; &#125; if(s==1) &#123; printf("Sorted sequence determined after %d relations: ",i+1); for(int i=0;i&lt;n;i++) printf("%c",c[i]+'A'); puts("."); ans=1; &#125; &#125; if(!ans) printf("Sorted sequence cannot be determined.\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2631 树的直径]]></title>
    <url>%2F2019%2F03%2F31%2FPoj2631-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：POJ2631 题意： 大致就是村庄之间修路，从一个村庄到另一个村庄只有一条路，而不经过其他一些村庄两次。有若干村庄和道路，其中任何村庄都可以通过公路从任何其他村庄到达。就是让找出该地区两个最偏远村庄之间的公路距离。这些村庄从1开始编号。 题解： 这个就是求树的直径的模板题，两遍BFS即可，第一遍，从任意一个点遍历，记录最远的那个村庄，然后第二遍从第一遍找到的那个最远村庄为起点进行遍历，这样得到的就是两个最偏远地区的距离，即树的直径，本来想用邻接矩阵(浪费空间)存图，题目提到有多达1万条路，所以我选择了邻接表存数据。如果是初学者话，估计这个邻接表不太好理解，我尽可能用通俗的语言让大家理解 AC代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;struct &#123; int u,v,w,next;//u,v是两个村庄；w是u,v两个村庄的距离;next 是记录此条路上一次存表的编号&#125;edge[10001];int vis[10001]；//vis是遍历时记录该条路是否被访问int d[10001]；//d是记录最远距离，遍历过程中不断更新int head[10001];//head是记录每条路的头结点int cnt,j,ans;void add(int u,int v,int w)//邻接表的创建&#123; edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; edge[cnt].next=head[u];//next指向上一次该路存表的编号， head[u]=cnt++;//将该条路的编号赋值给head &#125;void bfs(int x)&#123; memset(d,0,sizeof(d)); memset(vis,0,sizeof(vis)); vis[x]=1; queue&lt;int&gt;que; que.push(x); while(!que.empty()) &#123; int xx=que.front(); que.pop(); for(int i=head[xx];i!=-1;i=edge[i].next)//遍历与xx相连的所有村庄，i=-1即与xx相连的村庄遍历完了 &#123; int vv=edge[i].v; if(!vis[vv]&amp;&amp;d[vv]&lt;d[xx]+edge[i].w)//不断维护最远距离 &#123; vis[vv]=1; d[vv]=d[xx]+edge[i].w; if(d[vv]&gt;ans) &#123; ans=d[vv];//ans是记录最远距离 j=vv;//j是记录最偏远的村庄编号 &#125; que.push(vv); &#125; &#125; &#125;&#125;int main()&#123; int u,v,w; memset(head,-1,sizeof(head)); while(~scanf("%d%d%d",&amp;u,&amp;v,&amp;w)) &#123; add(u,v,w);add(v,u,w);//因为路是双向的，这也是可以用两遍BFS的原因 &#125; ans=0,cnt=0; bfs(1); bfs(j);//j是第一遍BFS找到的最远村庄的编号 printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>邻接表</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1232畅通工程（并查集)]]></title>
    <url>%2F2019%2F03%2F27%2FHDU1232%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86)%2F</url>
    <content type="text"><![CDATA[题目：HDU1232 题意： 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后 的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。Output对每个测试用例，在1行里输出最少还需要建设的道路数目。Sample Input4 21 34 33 31 21 32 35 21 23 5999 00Sample Output102998 这是并查集的模板题，直接套模板即可 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int pre[10000];int find(int x)&#123; return pre[x]==x?x:pre[x]=find(pre[x]);//利用递归将所有他的子节点指向父节点&#125; void Union(int x,int y)//将两个集合连接成一个集合&#123; int xx=find(x),yy=find(y);//xx是x的父节点，yy是y的父节点 if(xx!=yy)//如果x，y的父节点不是同一个，则将他们的父节点相连，使他们成为一个集合 &#123; if(yy&lt;xx) pre[xx]=yy;//为了方便，将编号小的视为父节点 else pre[yy]=xx; &#125;&#125; int main()&#123; int n,m,s,a,b; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n)&#123; s=0; for(int i=1;i&lt;=n;i++) pre[i]=i;//初始化，先将所有的点指向本身，即先让每一个点都是孤立的点 for(int i=0;i&lt;m;i++) &#123; scanf("%d%d",&amp;a,&amp;b); Union(a,b);//让a和b连通 &#125; for(int i=1;i&lt;=n;i++) &#123; if(pre[i]==i)//有几个指向本身的点，就有几个集合， s++;//s是集合个数 &#125; printf("%d\n",s-1);//要想让所有的集合连成一个集合，则最少需要 s-1边（例如有两个集合，则变成一个集合只需一条边即可） &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019蓝桥杯-E题:迷宫]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[试题 E: 迷宫本题总分：15 分【问题描述】下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。010000000100001001110000迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可 以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别 表示向下、向上、向左、向右走。对于下面这个更复杂的迷宫（30 行 50 列）， 请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下， 请找出字典序最小的一个作为答案。请注意在字典序中D&lt;L&lt;R&lt;U。 010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000【答案提交】这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填写多余的内容将无法得分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt; #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int inf=0x3f3f3f3f;const int MAXN=1000+5;int n,m;int dx[4]=&#123;1,0,0,-1&#125;,dy[4]=&#123;0,-1,1,0&#125;;//D&lt;L&lt;R&lt;U,这样初始化,为了保证输出的路径是最小字典序 int ans[MAXN][MAXN];//记录是否被访问 int dis[MAXN][MAXN],path[MAXN][MAXN];//dis记录步数 ，数组path记录路径char a[MAXN][MAXN];//数组a是存迷宫struct st&#123; int x,y;&#125;; void bfs(int x,int y)&#123; st s,ss; memset(ans,0,sizeof(ans)); memset(dis,0,sizeof(dis)); memset(path,0,sizeof(path)); queue&lt;st&gt;que; ans[x][y]=1; s.x=x; s.y=y; que.push(s); while(!que.empty()) &#123; s=que.front(); for(int i=0;i&lt;4;i++) &#123; int xx=s.x+dx[i]; int yy=s.y+dy[i]; if(xx&gt;=0&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;m&amp;&amp;ans[xx][yy]==0&amp;&amp;a[xx][yy]=='0') &#123; dis[xx][yy]=dis[s.x][s.y]+1;//记录步数 path[xx][yy]=i+1;//记录上一步从哪过来的 ans[xx][yy]=1; ss.x=xx,ss.y=yy; que.push(ss); &#125; &#125; que.pop(); &#125; printf("%d\n",dis[n-1][m-1]);//输出z走到终点a[n-1][m-1]的最少步数 (题上没要求) &#125;void print(int x ,int y)//利用递归输出路径 &#123; if(x==0&amp;&amp;y==0) return ; else if(path[x][y]==1)&#123; print(x-1,y);cout&lt;&lt;"D"; //等于1，即上一步向下走一步得到的 &#125; else if(path[x][y]==2)&#123; print(x,y+1);cout&lt;&lt;"L";//等于2，即上一步向左走一步得到的 &#125; else if(path[x][y]==3)&#123; print(x,y-1);cout&lt;&lt;"R";//等于3，即上一步向右走一步得到的 &#125; else if(path[x][y]==4)&#123; print(x+1,y);cout&lt;&lt;"U";//等于4，即上一步向上走一步得到的 &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",a[i]); bfs(0,0); print(n-1,m-1); return 0; &#125; 运行结果为 12最短步数为：186DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR]]></content>
      <tags>
        <tag>bfs</tag>
        <tag>记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2019%2F03%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1welcome to my blog!]]></content>
  </entry>
</search>
