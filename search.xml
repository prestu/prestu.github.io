<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL5.7-win32安装教程</title>
    <url>/2019/12/03/MySQL5-7-win32%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>mysql是编程中比较热门的一个关系型数据库，现在版本已经更新到了8.X版本了，但是新版本更改了很多东西，不太适合新手一上来就用8.X，不是很友好，还是推荐用5.6或5.7版本的，下面教大家怎样安装5.7.19版本的mysql<a id="more"></a></p>
<p><strong>1.下载.msi文件。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">永久链接：https://pan.baidu.com/s/1-x7ny6GayxyCYkz2pke26g </span><br><span class="line">提取码：dza1</span><br></pre></td></tr></table></figure>
<p>2.安装。</p>
<p>如果你不更改路径，就直接双击上面下载的文件，一直下一步就ok了，如果你想更该路径，想放在特定的文件夹，那就在安装过程中，有custom选项，点击然后改为自己创建好的文件夹即可。</p>
<p><strong>3.配置环境变量。</strong></p>
<p>新增系统变量：</p>
<p>键名：mysql(自己定义)</p>
<p>值：C:\Program Files\MySQL\MySQL Server 5.7(即自己的mysql安装目录)</p>
<p><img src="/images/新增环境变量.png" alt="新增环境变量"></p>
<p>然后在Path中添加：%mysql%\bin，注意Path中不同值之间的“；”符号不能省略(mysql就是刚新增的键名)</p>
<p><strong>4.配置my.ini文件</strong>。</p>
<p>因为这个版本不自动生成my.ini文件，经常有同学问根据百度某某的教程让修改my.ini文件，我的怎么没有呀，就是因为这个原因。</p>
<p>所以需要自己新建一个.</p>
<p>可以先新建一个my.txt文件，然后通过重命名修改文件后缀为.ini，以前的版本解压后或许会存在my-default.ini文件，但是5.7.19版本没有，因此要自己手动创建该文件.</p>
<p>文件的内容如下：(注意：文件夹之间用“/”而不是“\”,否则在下面的操作中可能会出错)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port = 3306</span><br><span class="line">basedir=C:/Program Files/MySQL/MySQL Server 5.7</span><br><span class="line">datadir=C:/Program Files/MySQL/MySQL Server 5.7/data</span><br><span class="line">max_connections=200</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
<p><img src="/images/pip配置.png" alt="pip配置"></p>
<p>编辑好my.ini文件之后，将my.ini文件放到C:/Program Files/MySQL/MySQL Server 5.7目录下</p>
<p><strong>5..以管理员身份打开cmd命令窗口，将目录切换到MySQL的安装目录的bin目录下。</strong></p>
<p>以管理员方式打开cmd:</p>
<p>​    点击电脑左下角的搜索，输入‘cmd’，然后会出现命令提示符程序，然后鼠标放上面—-&gt;右键—-&gt;以管理员身份进入.</p>
<p><img src="/images/cmd管理员.png" alt="cmd管理员"></p>
<p>将目录切换到MySQL的安装目录的bin目录下:</p>
<p>打开cmd之后，输入:cd C:/Program Files/MySQL/MySQL Server 5.7/bin<strong>(</strong>如果不行将’/‘ 换成 ‘\‘ <strong>)</strong></p>
<p>每次进入还要切换目录比较麻烦，另一种方式就不用每次都要进入bin目录了。</p>
<p>就是配置一下用户环境变量，将bin目录加到环境变量中即可，这样打开cmd，就可以直接进行操作了，不需要进行切换目录了.</p>
<p><img src="/images/bin添加环境变量.png" alt="bin添加环境变量"></p>
<p><strong>6.执行以下语句进行MySQL的安装。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure>
<p> 执行命令后提示：Service successfully installed. 表示安装成功</p>
<p><strong>7.执行以下语句进行MySQL的初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>
<p> 执行命令后会在MySQL的安装目录下生成data目录并创建root用户。</p>
<p> <strong>8.执行以下命令以启动mysql服务。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p> 执行后会有如下提示：<br> MySQL服务正在启动..</p>
<p> MySQL服务已经启动成功。</p>
<p><strong>9.启动MySQL之后，root用户的密码为空，设置密码。</strong></p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p password 新密码</span><br><span class="line">Enter password: 旧密码</span><br></pre></td></tr></table></figure>
<p> 需要输入旧密码时，由于旧密码为空，所以直接回车即可。</p>
<p><strong>10.安装成功！！！大功告成！！！</strong></p>
<p>最后，如果安装过程中出现任何解决不了的问题，下方留言哦。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假工宣传</title>
    <url>/2019/11/03/%E5%AF%92%E5%81%87%E5%B7%A5%E5%AE%A3%E4%BC%A0/</url>
    <content><![CDATA[<font color="Tomato" size="6" face="黑体"><center><strong>欢迎您的加入！</strong></center></font> <a id="more"></a><font color="Black" size="4">——–<strong>你是否还在为每月的生活费向父母开口而感到一丝羞愧？你是否还在因没有任何工作经验而为毕业后的前途担忧？你是否还在为了自己的恋爱经费节衣缩食？你是否又对一件自己非常喜欢的东西因其昂贵的价格望而却步？<br>——–那么，你找到我就对了，这是一个千载难逢的机会啊(装个逼装个逼，哈哈哈)。<br>——–用自己的努力让父母少流些汗水，用自己的双手铺垫自己的前途，用自己的心血让你的她拥有更多甜蜜，让你喜欢的东西安稳在你的怀里。<br>——–我们常年与上海，深圳，昆山，杭州等大都市的正规公司合作，多次顺利进行暑假工和寒假工的输送，待遇优厚，且不收取任何中介费用，保证学生利益，让学生的利益最大化，也绝对会保证学生的安全，只要你敢相信我，那么你一定可以得到你想要的。<br>——–我们为什么主打餐饮呢，因为餐饮并不比进厂工资低，甚至比你进厂还要高，最主要是餐饮工作环境好，伙食好，一般都是管吃管住的，并且没有进厂那么累，还有就是，在大城市这些高档餐厅好多都是“大人物”来吃饭，在你工作时可能遇见像马云这样的“大人物”，慧眼识人才，可能就让你跟着他混了，哈哈哈，开个玩笑(也有可能之真的哦)，当然这只是题外话，既然选择了跟着我们，就一定要踏踏实实的去干，加油，你是最棒的! ! !<br></strong></font>

<font color="#0099ff" size="4">如果有意向随时骚扰我<br>联系人：计算机1703范成恒<br>联系方式：<br>QQ：1932460873<br>手机号：18737045137(微信同)</font>

<p><strong>下面是餐饮的一些宣传页，可以进行参考参考</strong>。</p>
<p><img src="/images/1.png" alt="1"></p>
<p><img src="/images/2.png" alt="1"></p>
<p><img src="/images/3.png" alt="1"></p>
<p><img src="/images/4.png" alt="1"></p>
<p><img src="/images/5.png" alt="1"></p>
<p><img src="/images/6.png" alt="1"></p>
<p><img src="/images/7.png" alt="1"></p>
<p><img src="/images/8.png" alt="1"></p>
<p><img src="/images/9.png" alt="1"></p>
<p>如果你想进电子厂，那么也可以的，下面我放一些我们长期合作的电子厂的宣传页吧，供大家参考</p>
<p><a href="http://117.78.0.41/2019/11/02/%E5%AF%92%E5%81%87%E5%B7%A5%E5%AE%A3%E4%BC%A0%E5%86%8C/#more" target="_blank" rel="noopener">寒假工宣传页</a></p>
<p>针对大家可能遇见的一些问题我们总结了一份寒假工问题集，供大家参考，希望对你们有所帮助：</p>
<p><a href="http://117.78.0.41/2019/11/01/2019%E5%AF%92%E5%81%87%E5%B7%A5%E9%97%AE%E9%A2%98%E9%9B%86" target="_blank" rel="noopener">2019寒假工问题集</a></p>
<p>如果还有什么不明白的随时联系我<br>最后：<br><font color="Fuchsia" size="6" face="黑体"><strong>祝大家学业有成，前程似锦！！！</strong></font> </p>
]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title>电子厂宣传册</title>
    <url>/2019/11/02/%E5%AF%92%E5%81%87%E5%B7%A5%E5%AE%A3%E4%BC%A0%E5%86%8C/</url>
    <content><![CDATA[<p><strong>我们常年合作的一些知名的部分电子厂，主要集中在上海，江苏，深圳等地。</strong><a id="more"></a></p>
<p><img src="/images/10.png" alt></p>
<p><img src="/images/11.png" alt></p>
<p><img src="/images/12.png" alt></p>
<p><img src="/images/13.png" alt></p>
<p><img src="/images/14.png" alt></p>
<p><img src="/images/15.png" alt></p>
<p><img src="/images/16.png" alt></p>
<p><img src="/images/17.png" alt></p>
<p><img src="/images/18.png" alt></p>
<p><img src="/images/19.png" alt></p>
<p><img src="/images/20.png" alt></p>
<p><img src="/images/21.png" alt></p>
<p><img src="/images/22.png" alt></p>
<p><img src="/images/23.png" alt></p>
<p><img src="/images/24.png" alt></p>
<p><img src="/images/25.png" alt></p>
<p><img src="/images/26.png" alt></p>
<p><img src="/images/27.png" alt></p>
<p><img src="/images/28.png" alt></p>
<p><img src="/images/29.png" alt></p>
]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title>2019寒假工问题集</title>
    <url>/2019/11/01/2019%E5%AF%92%E5%81%87%E5%B7%A5%E9%97%AE%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<p><font color="Black" size="4" face="黑体"><strong>2019寒假工问题集</strong></font> <a id="more"></a></p>
<p><strong>1.问：寒假工期限是多长时间？</strong></p>
<p>答：从你们放假到你们学校开学之前一个星期左右，一般工期都在1个月以上，短期用工合同不会出现开学了不让回校上学。</p>
<p><strong>2.问：工作期内学生可以回家吗？</strong></p>
<p>答：原则上是不可以的，但如果是个别现象可以协调一下。</p>
<p><strong>3.问：我们要去哪个厂？现在可以确定下来吗？</strong></p>
<p>答：可以列举几个例：主要输送方向：长三角：上海昌硕、英华达、日铭、达丰等</p>
<p>苏州华硕、瑞仪、京东方等；昆山仁宝、世硕、纬创、富港等；</p>
<p>无锡绿点、健鼎、夏普等；常熟新世，常熟达富等南京英华达、华宝等，</p>
<p>珠三角：</p>
<p>深圳比亚迪、伟创力、卓翼、创维、TCL、普联中兴、昊阳天宇等；东莞德普特、东莞富港、OPP、王氏港建等；惠州比亚迪、长城、光弘、惠州海格等；广州广宝，中山微创，珠海伟创力等；郑州、淮安、廊坊、太原富士康等全国各地的500强企业！但现在确定不了哪一个厂，因为我们着手范围比较广，现在到底能组织多少人，还估算不出来，所以我们没办法统筹安排。学校还没确定下来放假时间，等确定下来我们会根据各个企业需求和时间具体统筹安排！统计好名单报备企业，大概发车前一周即可确定。做到让同学们进入满意的企业寒假工实习！</p>
<p><strong>4.问：我们的工资大概是多少？</strong></p>
<p>答：不同的地方工资存在差异，不同的部门和岗位也有相差，具体的计算方法是：（例如：新进员工底薪2100元/月；加班费按劳勤法计算   （1930/2290÷21.75÷8×系数×加班时数）。系数为平时加班的1.5倍、周六周日为2倍、国定假日为3倍，平均4000—6500元/月），这个是按劳动法计算方式的计算结果，结束了每个人都有工资单，实际上工资你自己可以算出来的；部分企业为小时工操作，12-15元/小时不等。小时工工资一般是15元左右,工资一般在4000~6000寒假工比暑假工工资高些</p>
<p><strong>5．问：什么时候发工资？</strong></p>
<p>答：发放时间根据厂方的规定时间发放（比如：每月的10号、15号、25号），学生在发工资之前返回的，工资到时间全额达到学生工资卡上; 离职当天会签考勤表，有问题反馈给企业，正常离职工资都会按时发放（只要不自离）</p>
<p><strong>6．问：工资是你们公司代发还是由厂方发放？</strong></p>
<p>答：工资是由厂方核算由厂方直接打到学生工资卡上！不会经过任何劳务中介，工资会有每个人的工时单，大家可以放心的核对自己的工资！</p>
<p><strong>7．问：学生发生的意外情况谁来负责任？</strong></p>
<p>  答：这一块看具体情况而定，一般分为这样几种情况：1.上车之前有学生自己负责2.在我们包的车上有我们的车队来负责3.在厂里出现意外按工伤处理由厂方负责4.在宿舍由厂方或者派遣公司负责5.工休期间有学生自己负责</p>
<p><strong>8．问：食宿这一块怎么说？</strong></p>
<p>   答：吃饭这一块是工作餐（两餐：中餐和晚餐）也就是只要你工作就有免费的饭吃，不工作就没有饭吃，早餐一般在早上5：30开饭，是为上夜班的准备，如果你想吃的话就五点半之前赶到厂里，有的厂子是一日三餐全免，这样的厂主要在常州地区；住宿是有偿宿舍，住宿费30-100元/月不等，个别需要交宿舍押金，离职退还</p>
<p><strong>9．问：一天大概工作多长时间？</strong></p>
<p>  答：一般是两班倒早八点到晚八点，晚八点到早八点，包括吃饭和休息时间，一般按10.5小时计算工资。</p>
<p><strong>10．问：有没有白班和夜班之分？</strong></p>
<p>答：有，夜班有夜班津贴一般在5-20元/班不等。</p>
<p><strong>11．问：学生辞职手续怎么办理？</strong></p>
<p>答：不需要学生操心，到时候自动解除，会统一办手续。均有我们安排的驻厂老师，统一安排！</p>
<p><strong>12</strong>．<strong>问：学生什么时候体检？</strong></p>
<p>答：学生一到目的地就要体检，这就要求学生在到达目的地之前的5个小时内不得吃东西或者喝水，也有企业不需要体检，只需要买一张体检单。</p>
<p><strong>13</strong>．<strong>问：学生去的话需要交纳多少钱？</strong></p>
<p>答：一般长三角江苏上海地区车费（150元/人）体检费（50元/人）</p>
<p>​    珠三角广东地区车费（200元/人）体检费（50元/人）</p>
<p><strong>14</strong>．<strong>问：我们招到的学生送不出怎么办？</strong></p>
<p>   答：这一点你不用担心，我是有把握全送出去的，我们现在缺的是人不是岗位，要不然我们也不会同时在全国范围内的各大高中院校开展暑假工、实习生的招募工作了。</p>
<p><strong>15</strong>.<strong>学生出发需要带什么东西？</strong></p>
<p>  答： 褥子、衣物、洗漱等生活用品。一寸照片3张，身份证复印件3张，身份证原件！</p>
<p><strong>16</strong>：<strong>工作环境及有没有危害？</strong></p>
<p>   答：工作环境都是24小时恒温作业，无毒无害没有气味，都是一些未成品也没有辐射，手机拆开会有辐射吗？外面谣传的辐射都是一些化工厂或者一些金属重工业，我们做的企业都是一些生产电子企业的厂子，学生工安排的岗位都是简单岗位！</p>
<p><strong>17</strong>：<strong>企业管吃住吗？</strong></p>
<p>   答：免费提供工作餐及加班餐，都是标准的工作餐，四菜一汤，米饭，面饭都有，早餐2元就解决了，也有部分企业提供免费的3餐，或者是每一个月餐补几百块，住宿4/8人间，独立卫生间，空调，热水，个人橱衣柜都有，一起去的可以住一个宿舍！</p>
<p><strong>18</strong>：<strong>外出打工安全不安全？</strong></p>
<p>   答：厂里，宿舍区安保比学校好，只要没事别出去乱跑不会出现安全问题，企业宿舍都是有几十个保安全天24小时值班，到处都有监控摄像头，进出长门刷卡，进宿舍也要刷卡！闲杂人等进不去厂区宿舍区</p>
<p> <strong>19</strong>：<strong>出发及入职离职安排</strong></p>
<p>依各大高校放假时间、公司安全大巴车在学校大门口接，直达厂区门口，下车后分宿舍，办理入职手续，培训1到2天 进车间工作，开始三天有老员工带着不用担心不会做或者做不好，工作都很简单</p>
<p>​      <strong>2019寒假工，期待你的加入！！！</strong></p>
]]></content>
      <categories>
        <category>寒假工</category>
      </categories>
      <tags>
        <tag>寒假工</tag>
      </tags>
  </entry>
  <entry>
    <title>this licenseK71U8DBPNE has been cancelled (pycharm)</title>
    <url>/2019/10/15/this%20licenseK71U8DBPNE%20has%20been%20cancelled%20(pycharm)/</url>
    <content><![CDATA[<p>最近使用pycharm的时候，之前还好好的，突然就不行了，弹出个这个错误，’this licenseK71U8DBPNE has been cancelled’,以为只是注册码过期了，就又去找了几个注册码，发现注册码并没有过期，弹出的错误还是同样的错误，就百度了一下借鉴了一下大神的博客，原来问题在这,下面提供两种方法：<a id="more"></a></p>
<p><strong>1.</strong>找到咱们的这个host文件，一般都放在C:\Windows\System32\drivers\etc目录下，打开这个host文件,在最后加上一句代码：0.0.0.0 account.jetbrains.com,如果原文件存在这句代码，会被注释掉，把注释去掉即可，然后重启pycharm 输入激活码即可。</p>
<p>2.前两种如果还是解决不了，，那就使用最后一种一方法了，解决办法是，如果是学生，可以用学校给我们注册的个人教育邮箱去注册，如果不知道，可以问下自己的同学，实在不行，问导员，他应该是知道的，现在pycharm是对学生及老师都是免费使用的，如果你不是学生，需要注册一个edu邮箱：<a href="https://zhidao.baidu.com/question/589038064022759205.html" target="_blank" rel="noopener">点这里</a>.注册之后就可以在激活pycharm时选择buy选项，然后英文根据提示完成操作即可。</p>
<p>以上就是我给大家的对于此问题的一些解决方法，不敢保证能解决所有问题，但还是可以解决大部分人的问题的，感谢支持，如果又哪里有问题或不懂的地方，下方留言哦。</p>
]]></content>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>利用费马小定理求逆元</title>
    <url>/2019/10/13/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>费马小定理：a是不能被质数p整除的正整数，则有a^(p-1)≡ 1 (mod p)</p>
<p>推导：a^(p−1) ≡ 1 (mod p) = a*a^(p−2 )≡ 1 (mod p) ;</p>
<p>则a的逆元 为 a^(p−2)。利用费马小定理求逆元的前提强调p一定是质数。</p>
<p>说这些你可能不太明白，先看一道题就明白了，</p>
<a id="more"></a>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" target="_blank" rel="noopener">HDU1576</a></p>
<p>要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。</p>
<p>Input<br>数据的第一行是一个T，表示有T组数据。<br>每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。</p>
<p>Output<br>对应每组数据输出(A/B)%9973。</p>
<p>Sample Input<br>2<br>1000 53<br>87 123456789</p>
<p>Sample Output<br>7922<br>6060 </p>
<p>如果我们直接求肯定不行 ，所以要利用逆元求解，并且9973（即是上面的p）为质数，</p>
<p>设C是B的逆元，则有B<em>C≡1(mod P)； 推论：(A/B)mod P = (A/B)</em>1mod p = (A/B)<em>B</em>C mod p=A<em>C(mod p); 即A/B的模等于A</em>(B的逆元)的模；l利用费马小定理得出C=B^(p-2);则原式可转化为（A<em>C）%p=（A%p</em>C%p）%p；个人见解，欢迎纠错.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define mod 9973</span><br><span class="line">typedef long long ll;//对 long long重命名 </span><br><span class="line">ll DD(ll a ,ll b)//求解 a^b%mod(因为a^b太大 需利用快速幂求解) </span><br><span class="line">&#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    if(b&lt;0)</span><br><span class="line">    return 0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ll a,b,i;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);</span><br><span class="line">        i=DD(b,(mod-2));//i即为 b的逆元 </span><br><span class="line">    printf(&quot;%lld\n&quot;,(a%mod*i%mod)%mod); //A*C）%p=（A%p*C%p）%p </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python打造淘宝抢购脚本</title>
    <url>/2019/07/31/%E5%88%A9%E7%94%A8python%E6%89%93%E9%80%A0%E6%B7%98%E5%AE%9D%E6%8A%A2%E8%B4%AD%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>说这是一款自动抢购脚本是没问题的，不过其实一款半自动抢购脚本，为什么这么说呢，因为并没有达到完全自动抢购，需要扫码登陆，登陆之后就可以自动抢购了，该脚本主要依赖第三方库selenium自动打开谷歌浏览器进行模拟登陆淘宝。</p>
<p>在进行该程序之前需要做的工作是<a id="more"></a></p>
<p>1.安装谷歌浏览器，也可以用其他浏览器比如火狐等，不过我的代码是通过谷歌实现的。</p>
<p>2.安装第三方库selenium,(通过pip命令比较方便)</p>
<p>3.安装谷歌驱动chomedriver,不会的<a href="https://prestu.github.io/2019/06/04/pytohn%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/#more" target="_blank" rel="noopener">点这里</a>.</p>
<p>好了开始放代码喽</p>
<p>可能该代码有所不成熟，且注释不够完善，有空进行补充，如果有问题，请大佬指出，评论在下方，感谢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">##################################################################################################################</span></span><br><span class="line"><span class="comment"># 淘宝抢购脚本                                                                                                    #</span></span><br><span class="line"><span class="comment"># 使用方法：                                                                                                      #</span></span><br><span class="line"><span class="comment">#     1、先将需要抢购的商品放到购物车中（注意购物车中只能放需要抢购的东西，到时抢购的时候会全部提交)                   #</span></span><br><span class="line"><span class="comment">#     2、修改下本脚本中的BUY_TIME值，设定为需要抢购的时间；                                                         #</span></span><br><span class="line"><span class="comment">#     3、执行此脚本，然后等待浏览器打开弹出登陆界面，手机淘宝扫描登陆；                                              #</span></span><br><span class="line"><span class="comment">#     4、脚本开始执行后，会定时刷新防止超时退出，到了设定时间点会自动尝试提交订单                                     #</span></span><br><span class="line"><span class="comment">#     5、抢购时为了防止一次网络拥堵出问题，设置了尝试机制，会不停尝试提交订单，直到提交成功或达到最大重试次数为止       #</span></span><br><span class="line"><span class="comment">#     6、脚本只负责提交订单，之后24小时内需要自行完成付款操作。                                                      #</span></span><br><span class="line"><span class="comment">##################################################################################################################</span></span><br><span class="line">login_sucess=<span class="literal">False</span></span><br><span class="line">retry_login_time=int(<span class="number">0</span>)</span><br><span class="line">max_retry_login_time=int(<span class="number">6</span>)</span><br><span class="line">buy_time=<span class="string">"2019-07-31 20:15:00"</span></span><br><span class="line">buy_time_obj=datetime.datetime.strptime(buy_time,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">now_time=datetime.datetime.now()</span><br><span class="line"><span class="keyword">if</span>(now_time &gt; buy_time_obj):</span><br><span class="line">    print(<span class="string">'抢购时间已过，确认时间是否填写错误'</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'正在打开浏览器...'</span>)</span><br><span class="line">print(<span class="string">'正在尝试登陆...'</span>)</span><br><span class="line">driver=webdriver.Chrome()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_oprator</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> driver.find_element_by_link_text(<span class="string">"亲，请登录"</span>):</span><br><span class="line">            print(<span class="string">'未登录，请点击登录按钮'</span>)</span><br><span class="line">            driver.find_element_by_link_text(<span class="string">'亲，请登录'</span>).click()</span><br><span class="line">            print(<span class="string">'请扫描二维码进行登陆'</span>)</span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'已登录，开始进行跳转...'</span>)</span><br><span class="line">        <span class="keyword">global</span> login_sucess</span><br><span class="line">        <span class="keyword">global</span> retry_login_time</span><br><span class="line">        login_sucess=<span class="literal">True</span></span><br><span class="line">        retry_login_time=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> retry_login_time</span><br><span class="line">    <span class="keyword">while</span> retry_login_time &lt; max_retry_login_time:</span><br><span class="line">        retry_login_time+=<span class="number">1</span></span><br><span class="line">        print(<span class="string">'正在尝试登陆次数'</span>+str(retry_login_time))</span><br><span class="line">        login_oprator()</span><br><span class="line">        <span class="keyword">if</span> login_sucess:</span><br><span class="line">            print(<span class="string">'登陆成功'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'等待登陆中...'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> login_sucess:</span><br><span class="line">        print(<span class="string">'规定时间内，未完成扫码登陆，登陆失败...退出程序！！'</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    now=datetime.datetime.now()</span><br><span class="line">    print(<span class="string">'登陆成功'</span>+str(now))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">refrsh_keep_alive</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">'https://cart.taobao.com/cart.htm'</span>)</span><br><span class="line">    print(<span class="string">'刷新购物页面，防止超时...'</span>)</span><br><span class="line">    time.sleep(<span class="number">30</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep_login_and_wait</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"当前距离抢购时间点还有较长时间，开始定时刷新防止登录超时..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        current_time=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">if</span>((buy_time_obj-current_time).seconds&gt;<span class="number">180</span>):</span><br><span class="line">            refrsh_keep_alive()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'抢购时间将近，停止自动刷新，准备进入抢购阶段...'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">()</span>:</span></span><br><span class="line">    driver.get(<span class="string">"https://cart.taobao.com/cart.htm"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">global</span> submit_success</span><br><span class="line">    submit_success=<span class="number">0</span></span><br><span class="line">    retry_sumit_times=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        now=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">if</span> now&gt;=buy_time_obj:</span><br><span class="line">            print(<span class="string">'到达抢购时间，开始抢购...尝试次数'</span>+str(retry_sumit_times))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> submit_success:</span><br><span class="line">                print(<span class="string">'抢购成功，无需继续抢购...'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> retry_sumit_times&gt;<span class="number">50</span>:</span><br><span class="line">                print(<span class="string">'抢购次数达到上限，停止抢购...'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            retry_sumit_times+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> (driver.find_element_by_id(<span class="string">'J_SelectAll1'</span>)):</span><br><span class="line">                    driver.find_element_by_id(<span class="string">'J_SelectAll1'</span>).click()</span><br><span class="line">                    print(<span class="string">'已选中全选按钮'</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span>(driver.find_element_by_id(<span class="string">'J_Go'</span>)):</span><br><span class="line">                    driver.find_element_by_id(<span class="string">'J_Go'</span>).click()</span><br><span class="line">                    print(<span class="string">'已经点击结算按钮...'</span>)</span><br><span class="line">                    click_button_times=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="keyword">if</span> click_button_times&lt;<span class="number">10</span> <span class="keyword">and</span> driver.find_element_by_link_text(<span class="string">'提交订单'</span>):</span><br><span class="line">                                driver.find_element_by_link_text(<span class="string">'提交订单'</span>).click()</span><br><span class="line">                                print(<span class="string">'已经点击提交订单按钮\n哈哈哈，抢购成功！！！'</span>)</span><br><span class="line">                                exit(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            print(<span class="string">'没有发现提交订单按钮，可能页面没加载出来，重试...'</span>)</span><br><span class="line">                            click_button_times+=<span class="number">1</span></span><br><span class="line">                            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                print(<span class="string">'提交订单失败'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">login()</span><br><span class="line">keep_login_and_wait()</span><br><span class="line">buy()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>统计三国演义中出场次数前十名的人物</title>
    <url>/2019/07/31/%E7%BB%9F%E8%AE%A1%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E4%B8%AD%E5%87%BA%E5%9C%BA%E6%AC%A1%E6%95%B0%E5%89%8D%E5%8D%81%E5%90%8D%E7%9A%84%E4%BA%BA%E7%89%A9/</url>
    <content><![CDATA[<p>利用第三方库jieba库，进行统计《三国演义》中出场次数前十名的任务，</p>
<p>由于较为基础，直接贴代码吧。<a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">excludes = &#123;<span class="string">"将军"</span>,<span class="string">"却说"</span>,<span class="string">"荆州"</span>,<span class="string">"二人"</span>,<span class="string">"不可"</span>,<span class="string">"不能"</span>,<span class="string">"如此"</span>,<span class="string">"商议"</span>,<span class="string">"主公"</span>,<span class="string">"如何"</span>,<span class="string">"军士"</span>,<span class="string">"左右"</span>,<span class="string">"军马"</span>,<span class="string">"引兵"</span>,<span class="string">"次日"</span>,<span class="string">"大喜"</span>,<span class="string">"天下"</span>,<span class="string">"于是"</span>,<span class="string">"东吴"</span>,<span class="string">"今日"</span>,<span class="string">"不敢"</span>,<span class="string">"魏兵"</span>,<span class="string">"陛下"</span>,<span class="string">"人马"</span>,<span class="string">"不知"</span>,<span class="string">"都督"</span>,<span class="string">"一人"</span>,<span class="string">"汉中"</span>&#125;		<span class="comment">#需要删除的无用词汇</span></span><br><span class="line">txt = open(<span class="string">"三国演义.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">'utf-8'</span>).read()<span class="comment">#打开提前下载好的txt文件</span></span><br><span class="line">words  = jieba.lcut(txt)   <span class="comment">#分词</span></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> len(word) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"诸葛亮"</span> <span class="keyword">or</span> word == <span class="string">"孔明曰"</span>:</span><br><span class="line">        rword = <span class="string">"孔明"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"关公"</span> <span class="keyword">or</span> word == <span class="string">"云长"</span>:</span><br><span class="line">        rword = <span class="string">"关羽"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"玄德"</span> <span class="keyword">or</span> word == <span class="string">"玄德曰"</span>:</span><br><span class="line">        rword = <span class="string">"刘备"</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">"孟德"</span> <span class="keyword">or</span> word == <span class="string">"丞相"</span>:</span><br><span class="line">        rword = <span class="string">"曹操"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rword = word</span><br><span class="line">    counts[rword] = counts.get(rword,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 如果不存在，其次数为零，否则加1</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> excludes:</span><br><span class="line">    <span class="keyword">del</span> counts[word]  <span class="comment">#删除无用词汇，意思就是我们的目的是统计人物出现次数，统计过程中会出现一些不是人物名字的大量词汇，所以要进行删除操作</span></span><br><span class="line">items = list(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)<span class="comment">#对人物次数，进行逆向排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;"</span>.format(word, count))<span class="comment">#对统计得到的前十名人物进行格式化输出</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python编写简易的名片管理系统</title>
    <url>/2019/07/31/%E5%88%A9%E7%94%A8python%E7%BC%96%E5%86%99%E7%9A%84%E7%AE%80%E6%98%93%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>利用python实现简单的名片的添加，修改，查询，删除等操作。</p>
<p>此代码仅限小白练手哦，大佬忽略就好了(因为代码太水了 23333)</p>
<p>如遇到bug或有任何疑问，在下方评论留言，感谢！<a id="more"></a></p>
<p><strong>注意：</strong></p>
<p>为了结果更清晰，下面将输出的内容进行了简单的颜色处理</p>
<p>格式：</p>
<p>​    开头部分：\033[显示方式;前景色;背景色m </p>
<p>​    结尾部分：\033[0m</p>
<p>关于字体颜色，更详细的内容请点击<a href="https://prestu.github.io/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/" target="_blank" rel="noopener">此处</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line">MingPian=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入姓名(输入0退出添加):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            print(<span class="string">'\033[0;31;1m此用户已存在，请重新输入！\033[0m'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            MingPian[name]=&#123;&#125;</span><br><span class="line">            sex = input(<span class="string">'性别:'</span>)</span><br><span class="line">            num=input(<span class="string">'联系方式:'</span>)</span><br><span class="line">            MingPian[name][<span class="string">'sex'</span>] = sex</span><br><span class="line">            MingPian[name][<span class="string">'num'</span>] = num</span><br><span class="line">            print(<span class="string">'\033[0;32;1m添加成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要删除的名字(输入0退出删除):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            <span class="keyword">del</span> MingPian[name]</span><br><span class="line">            print(<span class="string">'\033[0;32;1m删除成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你删除的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Modify</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要修改的名字(输入0退出修改):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            sex = input(<span class="string">'性别(M/F):'</span>)</span><br><span class="line">            num = input(<span class="string">'联系方式:'</span>)</span><br><span class="line">            MingPian[name][<span class="string">'sex'</span>]=sex</span><br><span class="line">            MingPian[name][<span class="string">'num'</span>]=num</span><br><span class="line">            print(<span class="string">'\033[0;32;1m修改成功！\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你修改的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name=input(<span class="string">'请输入要查询的名字(输入0退出查询):'</span>)</span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> MingPian.get(name):</span><br><span class="line">            print(<span class="string">'\033[0;35;1m'</span>)</span><br><span class="line">            print(MingPian[name])</span><br><span class="line">            print(<span class="string">'\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;31;1m你查询的名字不存在，或已被删除，请重新输入！\033[0m'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Look</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> MingPian.__len__():</span><br><span class="line">        print(<span class="string">'\033[0;35;1m'</span>)</span><br><span class="line">        print(MingPian)</span><br><span class="line">        print(<span class="string">'\033[0m'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'\033[0;31;1m此管理系统已空！\033[0m'</span>)</span><br><span class="line">msg = <span class="string">'''=====名片管理系统=====</span></span><br><span class="line"><span class="string">*    1. 添加名片     *</span></span><br><span class="line"><span class="string">*    2. 删除名片     *  </span></span><br><span class="line"><span class="string">*    3. 修改名片     *</span></span><br><span class="line"><span class="string">*    4. 查询名片     * </span></span><br><span class="line"><span class="string">*    5. 查询全部信息 *</span></span><br><span class="line"><span class="string">*    6. 退出名片     *</span></span><br><span class="line"><span class="string">*********************'''</span></span><br><span class="line">print(<span class="string">'\033[0;34;1m'</span>)</span><br><span class="line">print(msg)</span><br><span class="line">print(<span class="string">'\033[0m'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msg1 = <span class="string">'''&gt;&gt;&gt;1. 添加 2. 删除  3. 修改 4. 查询 5. 查询全部 6. 退出名片&lt;&lt;&lt;'''</span></span><br><span class="line">        Input=input(<span class="string">'\033[0;30;46m请输入要操作的序号:\033[0m'</span>)</span><br><span class="line">        Input=int(Input)</span><br><span class="line">        <span class="keyword">if</span> Input==<span class="number">6</span>:</span><br><span class="line">            print(<span class="string">'[6. 退出名片]'</span>)</span><br><span class="line">            print(<span class="string">'\033[0;31;1m程序已退出...\033[0m'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[1. 添加名片]\033[0m'</span>)</span><br><span class="line">            Add()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">2</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[2. 删除名片]\033[0m'</span>)</span><br><span class="line">            Delete()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">3</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[3. 修改名片]\033[0m'</span>)</span><br><span class="line">            Modify()</span><br><span class="line">        <span class="keyword">elif</span> Input==<span class="number">4</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[4. 查询名片]\033[0m'</span>)</span><br><span class="line">            Search()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\033[0;34;1m[5. 查询全部信息]\033[0m'</span>)</span><br><span class="line">            Look()</span><br><span class="line">        print(<span class="string">'\033[0;34;1m'</span>)</span><br><span class="line">        print(msg1)</span><br><span class="line">        print(<span class="string">'\033[0m'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'\033[0;31;1m输入有误!  请重新输入!\033[0m'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式的一些实例</title>
    <url>/2019/07/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>实例1.</strong></p>
<p>验证用户输入的密码是否符合要求，密码的要求是：</p>
<p>(1)不得少于8个字符.</p>
<p>(2) 只能包含大小写字母、数字和下划线.</p>
<p>(3) 大写字母、小写字母和数字这三种类型至少要包含两种.<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">print(&apos;\033[1;32;1m&apos;)</span><br><span class="line">print(&apos;请输入密码：\n1. 不得少于8个字符\n2.只能包含大小写字母，数字和下划线\n3.大写字母，小写字母和数字至少要包含两种&apos;)</span><br><span class="line">print(&apos;\033[0m&apos;) </span><br><span class="line">while True:</span><br><span class="line">    password=input(&apos;请输入:&apos;)</span><br><span class="line">    if len(password) &lt; 8:</span><br><span class="line">        print(&apos;输入错误!(不得少于8个字符)，请重新输入!&apos;)</span><br><span class="line">    else:</span><br><span class="line">        word=re.search(&apos;[\w_]+&apos;,password)</span><br><span class="line">        if word.group()==password:</span><br><span class="line">            a=b=c=int(0)</span><br><span class="line">            if re.findall(&apos;[a-z]&apos;,password) :</span><br><span class="line">                a=1</span><br><span class="line">            if re.findall(&apos;[A-Z]&apos;,password):</span><br><span class="line">                b=1</span><br><span class="line">            if re.findall(&apos;[\d]&apos;,password):</span><br><span class="line">                c=1</span><br><span class="line">            if a+b+c&gt;=2:</span><br><span class="line">                print(&apos;密码正确!程序结束!&apos;)</span><br><span class="line">                exit()</span><br><span class="line">            else:</span><br><span class="line">                print(&apos;密码有误，重新输入!&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;2密码有误，重新输入!&apos;)</span><br></pre></td></tr></table></figure>
<p>注意：\033[0m 是控制字体颜色的代码格式，详见<a href="https://prestu.github.io/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/" target="_blank" rel="noopener">点这里</a>。</p>
<p><strong>实例2.</strong></p>
<p>找出字符串”abcd123d123aad1v123“中以a开头，以123字符串结尾，但是中间不出现123这个字符串的字符串。结果应为:abcd123和ad1v123。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'abcd123d123ad1v123'</span></span><br><span class="line">x = re.compile(<span class="string">r'a.*?123'</span>)</span><br><span class="line">print(x.findall(s))</span><br></pre></td></tr></table></figure>
<p><strong>实例3.</strong></p>
<p>找出”a123abvpd123dpf12ab123sabd123f1123abc”中以123字符串开头，以ab字符串结尾，但是中间不出现123和“p”这两个字符串的子字符串。结果应为:123ab和123sab和123ab。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = re.compile(<span class="string">r'123[^p|123]*?ab'</span>)</span><br><span class="line">s = <span class="string">'a123abvpd123d“p”f12ab123sabd123f1123abc'</span></span><br><span class="line">print(x.findall(s))</span><br></pre></td></tr></table></figure>
<p><strong>实例4.</strong></p>
<p>匹配电话号码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p = re.compile(r&apos;\d&#123;3&#125;-\d&#123;6&#125;&apos;)</span><br><span class="line">print(p.findall(&apos;010-628888&apos;))</span><br></pre></td></tr></table></figure>
<p><strong>实例5.</strong></p>
<p>匹配IP.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x=re.search(r&quot;(([01]?\d?\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([01]?\d?\d|2[0-4]\d|25[0-5]\.)&quot;,&quot;192.168.1.1&quot;)</span><br><span class="line">print(x.group())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式中一些特殊构造</title>
    <url>/2019/07/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p><strong>特殊构造</strong></p>
<p>(?:…) (…)不分组版本,用于使用 | 或者后接数量词<br>(?iLmsux) iLmsux的每个字符代表一个匹配模式,只能用在正则表达式的开头,可选多个<br>(?#…) #号后的内容将作为注释<br>(?=…) 之后的字符串内容需要匹配表达式才能成功匹配<br>(?!…) 之后的字符串不匹配表达式才能成功<a id="more"></a><br>(?(?(?(id/name) yes |no) 如果编号为id/名字为name的组匹配到字符串,则需要匹配yes,否则匹配no,no可以省略</p>
<p><strong>“(?:…)” ：()里面有?:表示该()不是分组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;a(?:bc)&apos;)</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.match(&apos;abc&apos;).groups()   #显示不出分组</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p><strong>“(?=…)”：匹配…表达式，返回。对后进行匹配，总是对后面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;\w(?=\d)&apos;)  #匹配表达式\d，返回数字的前一位，\w：单词字符[A-Za-z0-9]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc1 def1 xyz1&apos;)</span><br><span class="line">[&apos;c&apos;, &apos;f&apos;, &apos;z&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;) #匹配数字的前一位，列表返回</span><br><span class="line">[&apos;y&apos;, &apos;2&apos;, &apos;0&apos;, &apos;1&apos;, &apos;3&apos;, &apos;0&apos;, &apos;6&apos;, &apos;2&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;\w+(?=\d)&apos;)</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc1,def1,xyz1&apos;)     #匹配最末数字的前字符串，列表返回</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc2&apos;, &apos;def3&apos;, &apos;xyz4&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou&apos;)</span><br><span class="line">[&apos;zhoujy2013062&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?=\d)&apos;)    #[A-Za-z],匹配字母,可以用其他的正则方法</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123&apos;) #匹配后面带有数字的字符串，列表返回</span><br><span class="line">[&apos;zhoujy&apos;, &apos;hangzhou&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?!…)” 不匹配…表达式，返回。对后进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;[A-Za-z]+(?!\d)&apos;)    #[A-Za-z],匹配字母,可以用其他的正则方法</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;) #匹配后面不是数字的字符串，列表返回</span><br><span class="line">[&apos;zhouj&apos;, &apos;hangzho&apos;, &apos;binjian&apos;]  #有疑问不应该是zhoujy吗？，因为y后面是数字，所以匹配到j终止</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;ab&apos;, &apos;de&apos;, &apos;xy&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?&lt;=…)”：匹配…表达式，总是对前面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;=\d)[A-Za-z]+&apos;)   #匹配前面是数字的字母</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;1abc21,2def31,3xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)</span><br><span class="line">[&apos;hangzhou&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?&lt;!…)”：不匹配…表达式，总是对前面进行匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?&lt;!\d)[A-Za-z]+&apos;)   #匹配前面不是数字的字母</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc21,def31,xyz41&apos;)</span><br><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;xyz&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;zhoujy20130628hangzhou123,12,binjiang310&apos;)</span><br><span class="line">[&apos;zhoujy&apos;, &apos;angzhou&apos;, &apos;binjiang&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>“(?i)…”: …为表达式，这里就介绍下i参数：大小写区分匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;(?i)abc&apos;)      #(?i) 不区分大小写</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)</span><br><span class="line">[&apos;ABC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBc&apos;)</span><br><span class="line">[&apos;aBc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)</span><br><span class="line">[&apos;aBC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat=re.compile(r&apos;abc&apos;,re.I)      #re.I 作为参数使用，推荐</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;aBC&apos;)</span><br><span class="line">[&apos;aBC&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;abc&apos;)</span><br><span class="line">[&apos;abc&apos;]</span><br><span class="line">&gt;&gt;&gt; pat.findall(&apos;ABC&apos;)</span><br><span class="line">[&apos;ABC&apos;]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的正则表达式re</title>
    <url>/2019/07/27/python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>，又称规则表达式<strong>。</strong>(英语:Regular Expression，在代码中常简写为regex、regexp或RE)，计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<p>​    许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在<a href="https://baike.so.com/doc/5106225-5334848.html" target="_blank" rel="noopener">Perl</a>中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件(例如sed和<a href="https://baike.so.com/doc/5454248-5692635.html" target="_blank" rel="noopener">grep</a>)普及开的。正则表达式通常缩写成”regex”，单数有regexp、regex，复数有regexps、regexes、regexen。<a id="more"></a></p>
<p>​    正则表达式是对字符串(包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为”元字符”))操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<p>正则表达式在很多语言里都支持，python也不例外，re模块就是正则表达式的应用.</p>
<p>1、正则表达式元字符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">\	转义字符，将后边紧跟着的字符变成特殊字符，或将后边的特殊字符变成普通字符</span><br><span class="line"></span><br><span class="line">如：在正则表达式中，"\n"换行符，"\\"则代表一个普通字符"\"</span><br><span class="line"></span><br><span class="line">^	匹配第一行行首，匹配多行需要传参 flags=re.MULTILINE</span><br><span class="line">$	匹配最后一行行尾，匹配多行需要传参 flags=re.MULTILINE</span><br><span class="line">.	除"\r""\n"外，匹配任意的单个字符，要使"."匹配换行符，flags=re.DOTALL或re.S</span><br><span class="line">|	或，如 "aaa|bbb|ccc"，表示"aaa","bbb","ccc"三选一</span><br><span class="line">?	匹配前边的子表达式0次或1次，等价于&#123;0,1&#125;,非贪婪模式</span><br><span class="line">+	匹配前边的子表达式1次或多次，等价于&#123;1,&#125;</span><br><span class="line">*	匹配前边的子表达式0次或多次,，等价于&#123;0,&#125;</span><br><span class="line">&#123;&#125;	&#123;n&#125;匹配前边的子表达式n次，&#123;n,&#125;匹配前边的子表达式至少n次，&#123;n,m&#125;匹配前边的子表达式n~m次</span><br><span class="line">()	分组，从1开始，从左至右数"("为第几组，下标0为全部分组</span><br><span class="line">[]	字符集匹配[]中的人一个字符，之匹配一次，如[abc]：表示"a","b","c"三选一。也可以给定范围(必须是连续的才行)，如[a-z]：表示a到z任意一个字符。</span><br><span class="line"></span><br><span class="line">还可以取反，如[^abc]：除"a","b","c"外的任意字符。注：[]中只有"^","-","\"三个特殊字符，其中"\"代表转义字符，其它的都代表原本普通的字符，如:[.]只是一个普通的点字符</span><br><span class="line">注：要使用元字符本身的普通字符，请使用转义字符转义一下，如 ："\(" 在正则表达式中代表普通给"("字符，其它的雷同</span><br></pre></td></tr></table></figure>
<p>分组的用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">(\num)	引用指定第几分组的值</span><br><span class="line">(?P<span class="tag">&lt;<span class="name">name</span>&gt;</span>)	指定分组别名"name"</span><br><span class="line">(?P=name)	引用指定别名的分组的值</span><br><span class="line">(?:)	相当于去分组化，变成"与"()子集，如:"abc(?:qqq|www)"--&gt;相当于"abcqqq|abcwww"</span><br></pre></td></tr></table></figure>
<p>2、预定义字符集</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">\b	匹配一个单词边界，也就是指单词和空格间的位置，其它特殊字符也可以是单词的边界，如"#","$","&amp;","*"等</span><br><span class="line">\B	匹配非单词边界</span><br><span class="line">\d	匹配一个数字字符。等价于[0-9]</span><br><span class="line">\D	匹配一个非数字字符。等价于[^0-9]</span><br><span class="line">\s	匹配任何不可见字符，包括空格、制表符、换页符等，等价于[ \f\n\r\t\v]</span><br><span class="line">\S	匹配任何可见字符。等价于[^ \f\n\r\t\v]</span><br><span class="line">\w	匹配包括下划线的任何单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[A-Za-z0-9_]”，还包含汉字等它国字符</span><br><span class="line">\W	匹配任何非单词字符。这里的"单词"字符使用Unicode字符集，类似但不等价于“[^A-Za-z0-9_]”，还包含汉字等它国字符</span><br></pre></td></tr></table></figure>
<p>3、re模块常用函数</p>
<table>
<thead>
<tr>
<th>re.A 或 re.ASCII</th>
<th>使用ASCII字符集进行匹配(不常用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I 或 re.IGNORECASE</td>
<td>忽略大小写匹配</td>
</tr>
<tr>
<td>re.L 或 re.LOCALE</td>
<td>使用当前预定字符类 \w \W \b \B \s \S 取决于当前区域设定(不常用)</td>
</tr>
<tr>
<td>re.U 或 re.UNICODE</td>
<td>使用Unicode字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性(不常用)</td>
</tr>
<tr>
<td>re.M 或 re.MULTILINE</td>
<td>多行匹配，使”^”,”$”可以在每一行中都进行匹配</td>
</tr>
<tr>
<td>re.S 或 re.DOTALL</td>
<td>使 “.” 可以匹配换行符”\r”,”\n”</td>
</tr>
<tr>
<td>re.X 或 re.VERBOSE</td>
<td>去掉正则表达式中的所有空格符(不常用)</td>
</tr>
</tbody>
</table>
<p><strong>1）re.compile(pattern, flags=0) :创建模式对象</strong></p>
<p>编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）</p>
<p>pattern: 编译时用的表达式字符串，flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等,(常用的flags即re模块常用函数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; rg = re.compile(r&quot;\d+&quot;, flags=0)</span><br><span class="line">&gt;&gt;&gt; re.findall(rg, &quot;a1bb22ccc333&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;22&apos;, &apos;333&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>2）re.findall(pattern, string, flags=0)</strong></p>
<p>re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(r"hello", "hello world hello")  # 普通匹配</span><br><span class="line">['hello', 'hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"^hello", "hello world hello")  # 匹配开头</span><br><span class="line">['hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"^hello", "hello world\nhello", flags=re.MULTILINE)  # 多行匹配开头</span><br><span class="line">['hello', 'hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"hello$", "hello world hello")  # 匹配结尾</span><br><span class="line">['hello']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\d+", "aaa111bbb222ccc333")  # 匹配数字</span><br><span class="line">['111', '222', '333']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\d&#123;2&#125;", "aaa111bbb222ccc333")  # 匹配两位的数字</span><br><span class="line">['11', '22', '33']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"ab|cd", "ab000cd00")  # 匹配"ab"或"cd"</span><br><span class="line">['ab', 'cd']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"\(", "ab(cd"))  # 匹配"("</span><br><span class="line">['(']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"(abc)+", "abcabcabc")  # 想要匹配多个"abc"，使用分组时会优先把分组的内容返回</span><br><span class="line">['abc']</span><br><span class="line">&gt;&gt;&gt; re.findall(r"(?:abc)+", "abcabcabc")  # 想要匹配多个"abc"，(?:)把分组去掉，变成一个普通的字符串</span><br><span class="line">['abcabcabc']</span><br></pre></td></tr></table></figure>
<p><strong>3）re.search(pattern, string, flags=0)</strong></p>
<p>在字符串中寻找模式,只要找到一个符合条件的就返回.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 5), match=&apos;hello&apos;&gt;  # 可以看到只返回了第一个&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;hello&quot;, &quot;hello world hello&quot;).group()</span><br><span class="line">&apos;hello&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(abc) \1&quot;, &quot;abc abc&quot;).group()  # \1 引用分组1的值</span><br><span class="line">&apos;abc abc&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;abc) (?P=name)&quot;, &quot;abc abc&quot;).group()  # (?P=name) 引用分组别名&quot;name&quot;的值</span><br><span class="line">&apos;abc abc&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group()</span><br><span class="line">&apos;zhansan 23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(0)  # 分组0--即匹配的结果</span><br><span class="line">&apos;zhansan 23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(1)  # 分组1的值</span><br><span class="line">&apos;zhansan&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(2)  # 分组2的值</span><br><span class="line">&apos;23&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;name&quot;)  # 分组别名name的值</span><br><span class="line">&apos;zhansan&apos;</span><br><span class="line">&gt;&gt;&gt; re.search(r&quot;(?P&lt;name&gt;zhansan) (?P&lt;age&gt;23)&quot;, &quot;zhansan 23&quot;).group(&quot;age&quot;)  # 分组别名age的值</span><br><span class="line">&apos;23&apos;</span><br></pre></td></tr></table></figure>
<p><strong>4）re.match(pattern, string, flags=0)</strong></p>
<p>在字符串开始处匹配模式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r"abc"</span>, <span class="string">"abcooooo"</span>).group()</span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line">&gt;&gt;&gt;m = re.search(<span class="string">'asd'</span>,<span class="string">'ASDasd'</span>)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0xb72cd6e8</span>&gt; <span class="comment">#匹配到了，返回MatchObject（True）</span></span><br><span class="line">&gt;&gt;&gt;m = re.search(<span class="string">'asd'</span>,<span class="string">'ASDASD'</span>)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line"><span class="literal">None</span>   <span class="comment">#没有匹配到，返回None（False）</span></span><br></pre></td></tr></table></figure>
<p><strong>5）re.finditer(pattern, string, flags=0)</strong></p>
<p>finditer与findall相似，只不过finditer返回一个迭代器,通过group()可以获取值,搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iter = re.finditer(<span class="string">r'\d+'</span>,<span class="string">'12 drumm44ers drumming, 11 ... 10 ...'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter:</span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">20</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    print(i.group())</span><br><span class="line">    print(i.span())</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&apos;12&apos;&gt;</span><br><span class="line">12</span><br><span class="line">(0, 2)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(8, 10), match=&apos;44&apos;&gt;</span><br><span class="line">44</span><br><span class="line">(8, 10)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(24, 26), match=&apos;11&apos;&gt;</span><br><span class="line">11</span><br><span class="line">(24, 26)</span><br><span class="line">********************</span><br><span class="line">&lt;re.Match object; span=(31, 33), match=&apos;10&apos;&gt;</span><br><span class="line">10</span><br><span class="line">(31, 33)</span><br></pre></td></tr></table></figure>
<p><strong>6）re.sub(pattern, repl, string, count=0, flags=0)</strong></p>
<p>sub按照给定的规则将string字符串中的相应的片段替换为repl，count 最多替换的次数，count=0默认为全部替换，返回替换后的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r"\d+"</span>, <span class="string">"$"</span>, <span class="string">"aaa1bb2ccc333"</span>)  <span class="comment"># 将连续的数字变成"$"</span></span><br><span class="line"><span class="string">'aaa$bb$ccc$'</span></span><br></pre></td></tr></table></figure>
<p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。</p>
<p>如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</span><br><span class="line">print(re.sub(r&apos;\s+&apos;, lambda m:&apos;[&apos;+m.group(0)+&apos;]&apos;, text,0))</span><br><span class="line">执行结果如下：</span><br><span class="line">JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on...</span><br></pre></td></tr></table></figure>
<p><strong>7）re.subn(pattern, repl, string, count=0, flags=0)</strong></p>
<p>返回替换次数，与sub相似，count 最多替换的次数，count=0默认为全部替换，返回 一个元组，下标0为替换后的字符串，下标1成功替换的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaabbccc&quot;)</span><br><span class="line">2 (&apos;aaabbccc&apos;, 0)  #未出现替换</span><br><span class="line">3 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;)</span><br><span class="line">4 (&apos;aaa$bb$ccc&apos;, 2)   #成功替换了两次</span><br><span class="line">5 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 1)  # 最多替换1次</span><br><span class="line">6 (&apos;aaa$bb22ccc&apos;, 1)</span><br><span class="line">7 &gt;&gt;&gt; re.subn(r&quot;\d+&quot;, &quot;$&quot;, &quot;aaa11bb22ccc&quot;, 10)  # 最多替换10次</span><br><span class="line">8 (&apos;aaa$bb$ccc&apos;, 2)  # 成功替换2次</span><br></pre></td></tr></table></figure>
<p><strong>8）re.split(pattern, string, maxsplit=0, flags=0)</strong></p>
<p>通过给定规则，将string进行切割，maxsplit最多切割次数，maxsplit=0默认全部切割，返回一个列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &gt;&gt;&gt; re.split(r&quot;@&quot;, &quot;a#b#c#d#e&quot;)  # 没有找到&quot;@&quot;，不切割</span><br><span class="line">2 [&apos;a#b#c#d#e&apos;]</span><br><span class="line">3 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;)  # 按&quot;#&quot;对字符串进行切割</span><br><span class="line">4 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">5 &gt;&gt;&gt; re.split(r&quot;#&quot;, &quot;a#b#c#d#e&quot;, 2)  # 按&quot;#&quot;对字符串进行切割，最多切割2次</span><br><span class="line">6 [&apos;a&apos;, &apos;b&apos;, &apos;c#d#e&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>9）group：获取子模式(组)的匹配项</strong></p>
<p>match和search一旦匹配成功，就是一个match object对象，需要用group()才可以打印匹配到的字符串。</p>
<p>b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常<br>c.groups（）方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;pat = re.compile(r&apos;www\.(.*)\.(.*)&apos;)    #用()表示1个组，2个组</span><br><span class="line">&gt;&gt;&gt;m = pat.match(&apos;www.dxy.com&apos;)</span><br><span class="line">&gt;&gt;&gt;m</span><br><span class="line">&lt;re.Match object; span=(0, 11), match=&apos;www.dxy.com&apos;&gt;</span><br><span class="line">&gt;&gt;&gt;m.group()                 #默认为0，表示匹配整个字符串  </span><br><span class="line">&apos;www.dxy.com&apos;</span><br><span class="line">&gt;&gt;&gt;m.group(1)                 #返回给定组1匹配的子字符串</span><br><span class="line">&apos;dxy&apos;</span><br><span class="line">&gt;&gt;&gt;m.group(2)</span><br><span class="line">&apos;com&apos;</span><br><span class="line">&gt;&gt;&gt;m.groups()</span><br><span class="line">(&apos;dxy&apos;, &apos;com&apos;)</span><br><span class="line">&gt;&gt;&gt;m.start(2)                 #组2开始的索引</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt;m.end(2)                  #组2结束的索引</span><br><span class="line">11</span><br><span class="line">&gt;&gt;&gt;m.span(2)                 #组2开始、结束的索引</span><br><span class="line">(8, 11)</span><br></pre></td></tr></table></figure>
<p><strong>10)贪婪匹配与非贪婪匹配</strong></p>
<p>贪婪匹配，也就是尽可能多的匹配，后面加?号使其变成惰性匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = re.findall(r&quot;a(\d+?)&quot;,&apos;a23b&apos;)</span><br><span class="line">print(a)</span><br><span class="line">b = re.findall(r&quot;a(\d+)&quot;,&apos;a23b&apos;)</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">[&apos;2&apos;]</span><br><span class="line">[&apos;23&apos;]</span><br><span class="line">a = re.match(&apos;&lt;(.*)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()</span><br><span class="line">print(a)</span><br><span class="line">b = re.match(&apos;&lt;(.*?)&gt;&apos;,&apos;&lt;H1&gt;title&lt;H1&gt;&apos;).group()</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">&lt;H1&gt;title&lt;H1&gt;</span><br><span class="line">&lt;H1&gt;</span><br></pre></td></tr></table></figure>
<p><strong>最后：</strong>用flags时遇到的小坑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(re.split(&apos;a&apos;,&apos;1A1a2A3&apos;,re.I))#输出结果并未能区分大小写</span><br><span class="line">这是因为re.split(pattern，string，maxsplit,flags)默认是四个参数，</span><br><span class="line">当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用。</span><br><span class="line">如果想让这里的re.I起作用，写成flags=re.I即可。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器设置字体大小颜色</title>
    <url>/2019/07/22/Markdown%E7%BC%96%E8%BE%91%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p><strong>Markdown</strong>是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！</p>
<p>  <strong>CSDN-markdown</strong>编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、<strong>内嵌HTML</strong>等等）！对，就是<strong>内嵌HTML</strong>，接下来要讲的功能就需要使用<strong>内嵌HTML</strong>的方法来实现。<a id="more"></a></p>
<p><strong>字体，字号和颜色:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=#00ffff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>呈现效果如下：</strong></p>
<font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="7" face="黑体">color=#0099ff</font><br><font color="#00ffff" size="72">color=#00ffff</font><br><font color="gray" size="72">color=gray</font>

<p><strong>颜色对应表：</strong></p>
<table>
<thead>
<tr>
<th>颜色名</th>
<th>十六进制颜色值</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>AliceBlue</td>
<td>#F0F8FF</td>
<td>rgb(240, 248, 255)</td>
</tr>
<tr>
<td>AntiqueWhite</td>
<td>#FAEBD7</td>
<td>rgb(250, 235, 215)</td>
</tr>
<tr>
<td>Aqua</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
</tr>
<tr>
<td>Aquamarine</td>
<td>#7FFFD4</td>
<td>rgb(127, 255, 212)</td>
</tr>
<tr>
<td>Azure</td>
<td>#F0FFFF</td>
<td>rgb(240, 255, 255)</td>
</tr>
<tr>
<td>Beige</td>
<td>#F5F5DC</td>
<td>rgb(245, 245, 220)</td>
</tr>
<tr>
<td>Bisque</td>
<td>#FFE4C4</td>
<td>rgb(255, 228, 196)</td>
</tr>
<tr>
<td>Black</td>
<td>#000000</td>
<td>rgb(0, 0, 0)</td>
</tr>
<tr>
<td>BlanchedAlmond</td>
<td>#FFEBCD</td>
<td>rgb(255, 235, 205)</td>
</tr>
<tr>
<td>Blue</td>
<td>#0000FF</td>
<td>rgb(0, 0, 255)</td>
</tr>
<tr>
<td>BlueViolet</td>
<td>#8A2BE2</td>
<td>rgb(138, 43, 226)</td>
</tr>
<tr>
<td>Brown</td>
<td>#A52A2A</td>
<td>rgb(165, 42, 42)</td>
</tr>
<tr>
<td>BurlyWood</td>
<td>#DEB887</td>
<td>rgb(222, 184, 135)</td>
</tr>
<tr>
<td>CadetBlue</td>
<td>#5F9EA0</td>
<td>rgb(95, 158, 160)</td>
</tr>
<tr>
<td>Chartreuse</td>
<td>#7FFF00</td>
<td>rgb(127, 255, 0)</td>
</tr>
<tr>
<td>Chocolate</td>
<td>#D2691E</td>
<td>rgb(210, 105, 30)</td>
</tr>
<tr>
<td>Coral</td>
<td>#FF7F50</td>
<td>rgb(255, 127, 80)</td>
</tr>
<tr>
<td>CornflowerBlue</td>
<td>#6495ED</td>
<td>rgb(100, 149, 237)</td>
</tr>
<tr>
<td>Cornsilk</td>
<td>#FFF8DC</td>
<td>rgb(255, 248, 220)</td>
</tr>
<tr>
<td>Crimson</td>
<td>#DC143C</td>
<td>rgb(220, 20, 60)</td>
</tr>
<tr>
<td>Cyan</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
</tr>
<tr>
<td>DarkBlue</td>
<td>#00008B</td>
<td>rgb(0, 0, 139)</td>
</tr>
<tr>
<td>DarkCyan</td>
<td>#008B8B</td>
<td>rgb(0, 139, 139)</td>
</tr>
<tr>
<td>DarkGoldenRod</td>
<td>#B8860B</td>
<td>rgb(184, 134, 11)</td>
</tr>
<tr>
<td>DarkGray</td>
<td>#A9A9A9</td>
<td>rgb(169, 169, 169)</td>
</tr>
<tr>
<td>DarkGreen</td>
<td>#006400</td>
<td>rgb(0, 100, 0)</td>
</tr>
<tr>
<td>DarkKhaki</td>
<td>#BDB76B</td>
<td>rgb(189, 183, 107)</td>
</tr>
<tr>
<td>DarkMagenta</td>
<td>#8B008B</td>
<td>rgb(139, 0, 139)</td>
</tr>
<tr>
<td>DarkOliveGreen</td>
<td>#556B2F</td>
<td>rgb(85, 107, 47)</td>
</tr>
<tr>
<td>Darkorange</td>
<td>#FF8C00</td>
<td>rgb(255, 140, 0)</td>
</tr>
<tr>
<td>DarkOrchid</td>
<td>#9932CC</td>
<td>rgb(153, 50, 204)</td>
</tr>
<tr>
<td>DarkRed</td>
<td>#8B0000</td>
<td>rgb(139, 0, 0)</td>
</tr>
<tr>
<td>DarkSalmon</td>
<td>#E9967A</td>
<td>rgb(233, 150, 122)</td>
</tr>
<tr>
<td>DarkSeaGreen</td>
<td>#8FBC8F</td>
<td>rgb(143, 188, 143)</td>
</tr>
<tr>
<td>DarkSlateBlue</td>
<td>#483D8B</td>
<td>rgb(72, 61, 139)</td>
</tr>
<tr>
<td>DarkSlateGray</td>
<td>#2F4F4F</td>
<td>rgb(47, 79, 79)</td>
</tr>
<tr>
<td>DarkTurquoise</td>
<td>#00CED1</td>
<td>rgb(0, 206, 209)</td>
</tr>
<tr>
<td>DarkViolet</td>
<td>#9400D3</td>
<td>rgb(148, 0, 211)</td>
</tr>
<tr>
<td>DeepPink</td>
<td>#FF1493</td>
<td>rgb(255, 20, 147)</td>
</tr>
<tr>
<td>DeepSkyBlue</td>
<td>#00BFFF</td>
<td>rgb(0, 191, 255)</td>
</tr>
<tr>
<td>DimGray</td>
<td>#696969</td>
<td>rgb(105, 105, 105)</td>
</tr>
<tr>
<td>DodgerBlue</td>
<td>#1E90FF</td>
<td>rgb(30, 144, 255)</td>
</tr>
<tr>
<td>Feldspar</td>
<td>#D19275</td>
<td>rgb(209, 146, 117)</td>
</tr>
<tr>
<td>FireBrick</td>
<td>#B22222</td>
<td>rgb(178, 34, 34)</td>
</tr>
<tr>
<td>FloralWhite</td>
<td>#FFFAF0</td>
<td>rgb(255, 250, 240)</td>
</tr>
<tr>
<td>ForestGreen</td>
<td>#228B22</td>
<td>rgb(34, 139, 34)</td>
</tr>
<tr>
<td>Fuchsia</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
</tr>
<tr>
<td>Gainsboro</td>
<td>#DCDCDC</td>
<td>rgb(220, 220, 220)</td>
</tr>
<tr>
<td>GhostWhite</td>
<td>#F8F8FF</td>
<td>rgb(248, 248, 255)</td>
</tr>
<tr>
<td>Gold</td>
<td>#FFD700</td>
<td>rgb(255, 215, 0)</td>
</tr>
<tr>
<td>GoldenRod</td>
<td>#DAA520</td>
<td>rgb(218, 165, 32)</td>
</tr>
<tr>
<td>Gray</td>
<td>#808080</td>
<td>rgb(128, 128, 128)</td>
</tr>
<tr>
<td>Green</td>
<td>#008000</td>
<td>rgb(0, 128, 0)</td>
</tr>
<tr>
<td>GreenYellow</td>
<td>#ADFF2F</td>
<td>rgb(173, 255, 47)</td>
</tr>
<tr>
<td>HoneyDew</td>
<td>#F0FFF0</td>
<td>rgb(240, 255, 240)</td>
</tr>
<tr>
<td>HotPink</td>
<td>#FF69B4</td>
<td>rgb(255, 105, 180)</td>
</tr>
<tr>
<td>IndianRed</td>
<td>#CD5C5C</td>
<td>rgb(205, 92, 92)</td>
</tr>
<tr>
<td>Indigo</td>
<td>#4B0082</td>
<td>rgb(75, 0, 130)</td>
</tr>
<tr>
<td>Ivory</td>
<td>#FFFFF0</td>
<td>rgb(255, 255, 240)</td>
</tr>
<tr>
<td>Khaki</td>
<td>#F0E68C</td>
<td>rgb(240, 230, 140)</td>
</tr>
<tr>
<td>Lavender</td>
<td>#E6E6FA</td>
<td>rgb(230, 230, 250)</td>
</tr>
<tr>
<td>LavenderBlush</td>
<td>#FFF0F5</td>
<td>rgb(255, 240, 245)</td>
</tr>
<tr>
<td>LawnGreen</td>
<td>#7CFC00</td>
<td>rgb(124, 252, 0)</td>
</tr>
<tr>
<td>LemonChiffon</td>
<td>#FFFACD</td>
<td>rgb(255, 250, 205)</td>
</tr>
<tr>
<td>LightBlue</td>
<td>#ADD8E6</td>
<td>rgb(173, 216, 230)</td>
</tr>
<tr>
<td>LightCoral</td>
<td>#F08080</td>
<td>rgb(240, 128, 128)</td>
</tr>
<tr>
<td>LightCyan</td>
<td>#E0FFFF</td>
<td>rgb(224, 255, 255)</td>
</tr>
<tr>
<td>LightGoldenRodYellow</td>
<td>#FAFAD2</td>
<td>rgb(250, 250, 210)</td>
</tr>
<tr>
<td>LightGrey</td>
<td>#D3D3D3</td>
<td>rgb(211, 211, 211)</td>
</tr>
<tr>
<td>LightGreen</td>
<td>#90EE90</td>
<td>rgb(144, 238, 144)</td>
</tr>
<tr>
<td>LightPink</td>
<td>#FFB6C1</td>
<td>rgb(255, 182, 193)</td>
</tr>
<tr>
<td>LightSalmon</td>
<td>#FFA07A</td>
<td>rgb(255, 160, 122)</td>
</tr>
<tr>
<td>LightSeaGreen</td>
<td>#20B2AA</td>
<td>rgb(32, 178, 170)</td>
</tr>
<tr>
<td>LightSkyBlue</td>
<td>#87CEFA</td>
<td>rgb(135, 206, 250)</td>
</tr>
<tr>
<td>LightSlateBlue</td>
<td>#8470FF</td>
<td>rgb(132, 112, 255)</td>
</tr>
<tr>
<td>LightSlateGray</td>
<td>#778899</td>
<td>rgb(119, 136, 153)</td>
</tr>
<tr>
<td>LightSteelBlue</td>
<td>#B0C4DE</td>
<td>rgb(176, 196, 222)</td>
</tr>
<tr>
<td>LightYellow</td>
<td>#FFFFE0</td>
<td>rgb(255, 255, 224)</td>
</tr>
<tr>
<td>Lime</td>
<td>#00FF00</td>
<td>rgb(0, 255, 0)</td>
</tr>
<tr>
<td>LimeGreen</td>
<td>#32CD32</td>
<td>rgb(50, 205, 50)</td>
</tr>
<tr>
<td>Linen</td>
<td>#FAF0E6</td>
<td>rgb(250, 240, 230)</td>
</tr>
<tr>
<td>Magenta</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
</tr>
<tr>
<td>Maroon</td>
<td>#800000</td>
<td>rgb(128, 0, 0)</td>
</tr>
<tr>
<td>MediumAquaMarine</td>
<td>#66CDAA</td>
<td>rgb(102, 205, 170)</td>
</tr>
<tr>
<td>MediumBlue</td>
<td>#0000CD</td>
<td>rgb(0, 0, 205)</td>
</tr>
<tr>
<td>MediumOrchid</td>
<td>#BA55D3</td>
<td>rgb(186, 85, 211)</td>
</tr>
<tr>
<td>MediumPurple</td>
<td>#9370D8</td>
<td>rgb(147, 112, 216)</td>
</tr>
<tr>
<td>MediumSeaGreen</td>
<td>#3CB371</td>
<td>rgb(60, 179, 113)</td>
</tr>
<tr>
<td>MediumSlateBlue</td>
<td>#7B68EE</td>
<td>rgb(123, 104, 238)</td>
</tr>
<tr>
<td>MediumSpringGreen</td>
<td>#00FA9A</td>
<td>rgb(0, 250, 154)</td>
</tr>
<tr>
<td>MediumTurquoise</td>
<td>#48D1CC</td>
<td>rgb(72, 209, 204)</td>
</tr>
<tr>
<td>MediumVioletRed</td>
<td>#C71585</td>
<td>rgb(199, 21, 133)</td>
</tr>
<tr>
<td>MidnightBlue</td>
<td>#191970</td>
<td>rgb(25, 25, 112)</td>
</tr>
<tr>
<td>MintCream</td>
<td>#F5FFFA</td>
<td>rgb(245, 255, 250)</td>
</tr>
<tr>
<td>MistyRose</td>
<td>#FFE4E1</td>
<td>rgb(255, 228, 225)</td>
</tr>
<tr>
<td>Moccasin</td>
<td>#FFE4B5</td>
<td>rgb(255, 228, 181)</td>
</tr>
<tr>
<td>NavajoWhite</td>
<td>#FFDEAD</td>
<td>rgb(255, 222, 173)</td>
</tr>
<tr>
<td>Navy</td>
<td>#000080</td>
<td>rgb(0, 0, 128)</td>
</tr>
<tr>
<td>OldLace</td>
<td>#FDF5E6</td>
<td>rgb(253, 245, 230)</td>
</tr>
<tr>
<td>Olive</td>
<td>#808000</td>
<td>rgb(128, 128, 0)</td>
</tr>
<tr>
<td>OliveDrab</td>
<td>#6B8E23</td>
<td>rgb(107, 142, 35)</td>
</tr>
<tr>
<td>Orange</td>
<td>#FFA500</td>
<td>rgb(255, 165, 0)</td>
</tr>
<tr>
<td>OrangeRed</td>
<td>#FF4500</td>
<td>rgb(255, 69, 0)</td>
</tr>
<tr>
<td>Orchid</td>
<td>#DA70D6</td>
<td>rgb(218, 112, 214)</td>
</tr>
<tr>
<td>PaleGoldenRod</td>
<td>#EEE8AA</td>
<td>rgb(238, 232, 170)</td>
</tr>
<tr>
<td>PaleGreen</td>
<td>#98FB98</td>
<td>rgb(152, 251, 152)</td>
</tr>
<tr>
<td>PaleTurquoise</td>
<td>#AFEEEE</td>
<td>rgb(175, 238, 238)</td>
</tr>
<tr>
<td>PaleVioletRed</td>
<td>#D87093</td>
<td>rgb(216, 112, 147)</td>
</tr>
<tr>
<td>PapayaWhip</td>
<td>#FFEFD5</td>
<td>rgb(255, 239, 213)</td>
</tr>
<tr>
<td>PeachPuff</td>
<td>#FFDAB9</td>
<td>rgb(255, 218, 185)</td>
</tr>
<tr>
<td>Peru</td>
<td>#CD853F</td>
<td>rgb(205, 133, 63)</td>
</tr>
<tr>
<td>Pink</td>
<td>#FFC0CB</td>
<td>rgb(255, 192, 203)</td>
</tr>
<tr>
<td>Plum</td>
<td>#DDA0DD</td>
<td>rgb(221, 160, 221)</td>
</tr>
<tr>
<td>PowderBlue</td>
<td>#B0E0E6</td>
<td>rgb(176, 224, 230)</td>
</tr>
<tr>
<td>Purple</td>
<td>#800080</td>
<td>rgb(128, 0, 128)</td>
</tr>
<tr>
<td>Red</td>
<td>#FF0000</td>
<td>rgb(255, 0, 0)</td>
</tr>
<tr>
<td>RosyBrown</td>
<td>#BC8F8F</td>
<td>rgb(188, 143, 143)</td>
</tr>
<tr>
<td>RoyalBlue</td>
<td>#4169E1</td>
<td>rgb(65, 105, 225)</td>
</tr>
<tr>
<td>SaddleBrown</td>
<td>#8B4513</td>
<td>rgb(139, 69, 19)</td>
</tr>
<tr>
<td>Salmon</td>
<td>#FA8072</td>
<td>rgb(250, 128, 114)</td>
</tr>
<tr>
<td>SandyBrown</td>
<td>#F4A460</td>
<td>rgb(244, 164, 96)</td>
</tr>
<tr>
<td>SeaGreen</td>
<td>#2E8B57</td>
<td>rgb(46, 139, 87)</td>
</tr>
<tr>
<td>SeaShell</td>
<td>#FFF5EE</td>
<td>rgb(255, 245, 238)</td>
</tr>
<tr>
<td>Sienna</td>
<td>#A0522D</td>
<td>rgb(160, 82, 45)</td>
</tr>
<tr>
<td>Silver</td>
<td>#C0C0C0</td>
<td>rgb(192, 192, 192)</td>
</tr>
<tr>
<td>SkyBlue</td>
<td>#87CEEB</td>
<td>rgb(135, 206, 235)</td>
</tr>
<tr>
<td>SlateBlue</td>
<td>#6A5ACD</td>
<td>rgb(106, 90, 205)</td>
</tr>
<tr>
<td>SlateGray</td>
<td>#708090</td>
<td>rgb(112, 128, 144)</td>
</tr>
<tr>
<td>Snow</td>
<td>#FFFAFA</td>
<td>rgb(255, 250, 250)</td>
</tr>
<tr>
<td>SpringGreen</td>
<td>#00FF7F</td>
<td>rgb(0, 255, 127)</td>
</tr>
<tr>
<td>SteelBlue</td>
<td>#4682B4</td>
<td>rgb(70, 130, 180)</td>
</tr>
<tr>
<td>Tan</td>
<td>#D2B48C</td>
<td>rgb(210, 180, 140)</td>
</tr>
<tr>
<td>Teal</td>
<td>#008080</td>
<td>rgb(0, 128, 128)</td>
</tr>
<tr>
<td>Thistle</td>
<td>#D8BFD8</td>
<td>rgb(216, 191, 216)</td>
</tr>
<tr>
<td>Tomato</td>
<td>#FF6347</td>
<td>rgb(255, 99, 71)</td>
</tr>
<tr>
<td>Turquoise</td>
<td>#40E0D0</td>
<td>rgb(64, 224, 208)</td>
</tr>
<tr>
<td>Violet</td>
<td>#EE82EE</td>
<td>rgb(238, 130, 238)</td>
</tr>
<tr>
<td>VioletRed</td>
<td>#D02090</td>
<td>rgb(208, 32, 144)</td>
</tr>
<tr>
<td>Wheat</td>
<td>#F5DEB3</td>
<td>rgb(245, 222, 179)</td>
</tr>
<tr>
<td>White</td>
<td>#FFFFFF</td>
<td>rgb(255, 255, 255)</td>
</tr>
<tr>
<td>WhiteSmoke</td>
<td>#F5F5F5</td>
<td>rgb(245, 245, 245)</td>
</tr>
<tr>
<td>Yellow</td>
<td>#FFFF00</td>
<td>rgb(255, 255, 0)</td>
</tr>
<tr>
<td>YellowGreen</td>
<td>#9ACD32</td>
<td>rgb(154, 205, 50)</td>
</tr>
</tbody>
</table>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\1.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\2.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\3.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\4.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\5.png" alt="1"></p>
<p><img src="/.com//blog\source\_posts\Markdown编辑器设置字体大小颜色\6.png" alt="1"></p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm控制台打印带颜色</title>
    <url>/2019/07/22/pycharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%B8%A6%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>​    在python开发的过程中，经常会遇到需要打印各种信息。海量的信息堆砌在控制台中，就会导致信息都混在一起，降低了重要信息的可读性。这时候，如果能给重要的信息加上字体颜色，那么就会更加方便用户阅读了。 　　</p>
<p>　　当然了，控制台的展示效果有限，并不能像前段一样炫酷，只能做一些简单的设置。不过站在可读性的角度来看，已经好很多了。</p>
<p><strong>书写格式：</strong>   <a id="more"></a>  </p>
<p><strong>开头部分</strong>：\033[显示方式;前景色;背景色m +内容+ <strong>结尾部分：</strong>\033[0m</p>
<p>​     注意：开头部分的三个参数：显示方式，前景色，背景色是可选参数，可以只写其中的某一个；另外由于表示三个参数不同含义的数值都是唯一的没有重复的，所以三个参数的书写先后顺序没有固定要求，系统都能识别；但是，建议按照默认的格式规范书写。</p>
<p>​     对于结尾部分，其实也可以省略，但是为了书写规范，建议\033[***开头，\033[0m结尾。</p>
<p><strong>数值表示的参数含义：</strong></p>
<p><strong>显示方式:</strong> 0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、 5（闪烁）、25（非闪烁）、7（反显）、27（非反显）<br><strong>前景色:</strong> 30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋 红）、36（青色）、37（白色）<br><strong>背景色:</strong> 40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋 红）、46（青色）、47（白色）</p>
<p><strong>常见开头格式</strong>：<br>\033[0m            默认字体正常显示，不高亮<br>\033[32;0m       红色字体正常显示<br>\033[1;32;40m  显示方式: 高亮    字体前景色：绿色  背景色：黑色<br>\033[0;31;46m  显示方式: 正常    字体前景色：红色  背景色：青色</p>
<p>\033[1;31m  显示方式: 高亮    字体前景色：红色  背景色：无</p>
<p><strong>示例格式1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\033[1;35;0m字体变色，但无背景色 \033[0m'</span>)  <span class="comment"># 有高亮 或者 print('\033[1;35m字体有色，但无背景色 \033[0m')</span></span><br><span class="line">print(<span class="string">'\033[1;45m 字体不变色，有背景色 \033[0m'</span>)  <span class="comment"># 有高亮</span></span><br><span class="line">print(<span class="string">'\033[1;35;46m 字体有色，且有背景色 \033[0m'</span>)  <span class="comment"># 有高亮</span></span><br><span class="line">print(<span class="string">'\033[0;35;46m 字体有色，且有背景色 \033[0m'</span>)  <span class="comment"># 无高亮</span></span><br></pre></td></tr></table></figure>
<p><strong>示例格式2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\033[0;36m'</span>)</span><br><span class="line">print(<span class="string">'hello world!'</span>)</span><br><span class="line">print(<span class="string">'\033[0m'</span>)</span><br></pre></td></tr></table></figure>
<p>参考自博客[老虎死了还有狼],更多展示效果请点击<a href="https://www.cnblogs.com/daofaziran/p/9015284.html" target="_blank" rel="noopener">此处</a>.</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序初识</title>
    <url>/2019/07/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>新创建的小程序项目，会默认生成一份demo代码，用于展示代码结构.</p>
<p>新建项目已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js，app.json，app.wxss 这三个。其中js`后缀的是脚本文件json后缀的文件是配置文件，后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。<a id="more"></a></p>
<ol>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
</li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。</p>
</li>
</ol>
<p>​    注意：该文件不可添加任何注释。</p>
<ol start="3">
<li>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</li>
</ol>
<p>我们注意到，在实例程序的代码中还有2个文件夹，一个是pages，一个是utils，其中utils是放通用工具类方法的一个文件夹，pages是存放所有页面的文件夹。我们着重讲一下这个pages。</p>
<p>小程序页面文件构成</p>
<p>　　在这个示例中，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p> 每一个小程序页面是由同路径下同名的四个不同后缀文件组成的，如：index.js、index.wxml、index.wxss、index.json。.js<code>后缀的文件是脚本文件，.</code>json<code>后缀的文件是配置文件，</code>.wxss<code>后缀的是样式表文件，</code>.wxml`后缀的文件是页面结构文件。</p>
<p> index.wxml 是页面的结构文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"getUserInfo"</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"user-motto"</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本例中使用了view，image，text，button等<code>组件</code>来搭建页面结构，绑定数据和交互处理函数。</p>
<p> index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//获取应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">motto: <span class="string">'Hello World'</span>,</span><br><span class="line">userInfo: &#123;&#125;,</span><br><span class="line">hasUserInfo: <span class="literal">false</span>,</span><br><span class="line">canIUse: wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line">bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url: <span class="string">'../logs/logs'</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (app.globalData.userInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: app.globalData.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.data.canIUse)&#123;</span><br><span class="line"><span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line"><span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">app.userInfoReadyCallback = <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: res.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 在没有 open-type=getUserInfo 版本的兼容处理</span></span><br><span class="line">wx.getUserInfo(&#123;</span><br><span class="line">success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">app.globalData.userInfo = res.userInfo</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: res.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">getUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">app.globalData.userInfo = e.detail.userInfo</span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">userInfo: e.detail.userInfo,</span><br><span class="line">hasUserInfo: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>index.wxss 是页面的样式表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**index.wxss**/</span></span><br><span class="line">.userinfo &#123;</span><br><span class="line">display: flex;</span><br><span class="line">flex-direction: column;</span><br><span class="line">align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-avatar &#123;</span><br><span class="line">width: <span class="number">128</span>rpx;</span><br><span class="line">height: <span class="number">128</span>rpx;</span><br><span class="line">margin: <span class="number">20</span>rpx;</span><br><span class="line">border-radius: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.userinfo-nickname &#123;</span><br><span class="line">color: <span class="meta">#aaa;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.usermotto &#123;</span><br><span class="line">margin-top: <span class="number">200</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
<p> index.json 是页面的配置文件：</p>
<p> 页面的配置文件也是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
<p> logs 的页面结构:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--logs.wxml--&gt;</span><br><span class="line">&lt;view class="container log-list"&gt;</span><br><span class="line">  &lt;block wx:for-items="&#123;&#123;logs&#125;&#125;" wx:for-item="log"&gt;</span><br><span class="line">    &lt;text class="log-item"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p> logs 页面使用 block 控制标签来组织代码，在 <code>&lt;/block&gt;</code> 上使用 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1474644083132#block-wxfor" target="_blank" rel="noopener"><code>wx:for-items</code></a> 绑定 <code>logs</code> 数据，并将 <code>logs</code> 数据循环展开节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//logs.js</span></span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'../../utils/util.js'</span>)</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    logs: []</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      logs: (wx.getStorageSync(<span class="string">'logs'</span>) || []).map(<span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> util.formatTime(<span class="keyword">new</span> <span class="built_in">Date</span>(log))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>手机预览</p>
<p>点击开发工具的顶部工具栏中的”预览”，即可生成预览二维码，用微信扫码后即可在微信客户端中预览体验</p>
<p>以上便是微信小程序前端开发的基本流程，而实际上要做一个内容可以更新的小程序，单有前端开发是远远不够的，还需要后台开发。后台开发与web开发的后台基本无异，可以选择用java、php、nodejs等任一语言，有一点需要注意的是小程序后台服务器必须是https协议的，这就要求必须购买云服务器并将后台服务器设置成https服务。</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>python中列表(list)排序的一些常见操作</title>
    <url>/2019/06/18/python%E4%B8%AD%E5%88%97%E8%A1%A8-list-%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>对列表排序一般有两种操作:my_list.sort()和sorted(my_list)</strong></p>
<p><strong>1.使用sort排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">my_list.sort()</span><br><span class="line">print(my_list)</span><br><span class="line"><span class="comment">#输出[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>2.使用sorted排序</strong><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">my_list_1=sorted(my_list)</span><br><span class="line">print(my_list_1)</span><br><span class="line"><span class="comment">#输出[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>可以看出操作有所不同，使用sort()方法对list排序会修改list本身,不会返回新list，而sorted()方法不会对原list进行修改，而是返回一个新list，但是如果你不需要保留原来的list，此方法将更有效sort()。</p>
<p>另外sort()不能对dict字典进行排序，如果sort()里面不填参数，即默认升序，若要降序只需my_list.sort(reverse=True),(True降序，False升序(sorted()操作与之一样))</p>
<p><strong>3.列表里嵌套列表且里面的列表有多个值，并指定以第几个值进行排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个进行升序排序</span></span><br><span class="line">users=[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">user=sorted(users,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个升序排序，如果第二个相等，则以第一个排序</span></span><br><span class="line">user=sorted(users,key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个升序排序，如果第二个相等，则以第一降序排列</span></span><br><span class="line">s=sorted(users,key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],-x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">1</span>],-x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定第二个降序排序，如果第二个相等，则以第一升序排列</span></span><br><span class="line">s=sorted(users,key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">0</span>]))</span><br><span class="line">users.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中一些常见的问题</title>
    <url>/2019/06/04/pytohn%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1.为什么import 调用的模块 在pycharm中 会有红色的波浪线？</strong></p>
<p>是因为该模块为第三方库，你未导入，进行导入就可以了，一般用pip指令导入比较方便</p>
<p><strong>2</strong>.<strong>为什么用import 调用模块有的’import’显示灰色,有的显示高亮？</strong></p>
<p>灰色是表示没有用到这个模块里的任何一个东西，可以把这一行去掉的。</p>
<p><strong>3</strong>.<strong>selenium的使用</strong><a id="more"></a></p>
<p>   1.运行报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.chrome()</span><br><span class="line">TypeError: <span class="string">'module'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure>
<p>​    解决方案：浏览器的名称需要大写，即Chrome和Firefox</p>
<p>   2.selenium中安装chrome浏览器驱动(chomedriver)</p>
<p>​    1.下载对应版本的chromedriver 下载地址：<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">点这里</a></p>
<pre><code>选择需要的浏览器驱动版本，点击**notes.txt**可以查看当前版本支持的浏览器版本，确定是否下载。
</code></pre><p>​    2.解压复制chromedriver.exe到chrome浏览器的安装目录(C:\Program Files (x86)\Google\Chrome\Application)</p>
<p>​        如果找不到此文件夹就将此文件解压到和你py文件同一个文件夹下，正常启动即可。</p>
<p>​    3.启动脚本，浏览器正常打开</p>
<p>​    使用格式 driver = webdriver.Chrome()</p>
<p> <strong>4.try -except 异常处理：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      A</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">      B</span><br><span class="line">  <span class="keyword">except</span>会捕获所有异常，包括键盘中断和程序退出请求（用sys.exit()就无法退出程序了，因为异常被捕获了），因此慎用。</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:可以捕获除与程序退出sys.exit()相关之外的所有异常</span><br><span class="line">  老版本的Python，<span class="keyword">except</span>语句写作<span class="string">"except Exception, e"</span>，Python <span class="number">2.6</span>后应写作<span class="string">"except Exception as e"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">except</span> &lt;异常名<span class="number">1</span>,异常名<span class="number">2</span>&gt;:&lt;数据&gt;:捕获异常名<span class="number">1</span>或者异常名<span class="number">2</span>,及附加的数据库</span><br><span class="line">  例如：</span><br><span class="line">  	<span class="keyword">try</span>:</span><br><span class="line">          <span class="keyword">print</span> (<span class="number">2</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (IOError,ZeroDivisionError):</span><br><span class="line">  		print( <span class="string">'类型异常'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键字          关键字说明</span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span>           抛出/引发异常</span><br><span class="line"><span class="keyword">try</span>/<span class="keyword">except</span>      捕获异常并处理</span><br><span class="line"><span class="keyword">pass</span>            忽略异常</span><br><span class="line"><span class="keyword">as</span>              定义异常实例(<span class="keyword">except</span> IOError <span class="keyword">as</span> e)</span><br><span class="line"><span class="keyword">finally</span>         无论是否出现异常，都执行的代码</span><br><span class="line"><span class="keyword">else</span>            如果<span class="keyword">try</span>中的语句没有引发异常，则执行<span class="keyword">else</span>中的语句</span><br></pre></td></tr></table></figure>
<p>​    常用异常名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">异常名    描述</span><br><span class="line">   AttributeError 调用不存在的方法引发的异常</span><br><span class="line">   EOFError       遇到文件末尾引发的异常</span><br><span class="line">   ImportError    导入模块出错引发的异常</span><br><span class="line">   IndexError     列表越界引发的异常</span><br><span class="line">   IOError        I/O操作引发的异常，如打开文件出错等</span><br><span class="line">   KeyError       使用字典中不存在的关键字引发的异常</span><br><span class="line">   NameError      使用不存在的变量名引发的异常</span><br><span class="line">   TabError       语句块缩进不正确引发的异常</span><br><span class="line">   ValueError     搜索列表中不存在的值引发的异常</span><br><span class="line">   ZeroDivisionError   除数为零引发的异常</span><br><span class="line"></span><br><span class="line">   使用<span class="keyword">raise</span> 引发异常几种方式：</span><br><span class="line"></span><br><span class="line">   <span class="keyword">raise</span> 异常名</span><br><span class="line">   <span class="keyword">raise</span> 异常名,附加数据</span><br><span class="line">   <span class="keyword">raise</span> 类名</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span> 简化了<span class="keyword">raise</span>语句：</span><br><span class="line">   需要注意的是，<span class="keyword">assert</span>语句一般用于开发时对程序条件的验证，只有当内置_debug_为<span class="literal">True</span>时，<span class="keyword">assert</span>语句才有效。当Python脚     本以-O选项编译成为字节码文件时，<span class="keyword">assert</span>语句将被移除。</span><br><span class="line">   但与<span class="keyword">raise</span>语句不同的是，<span class="keyword">assert</span>语句是在条件测试为假时，才引发异常。<span class="keyword">assert</span>语言的一般形式如下：</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assert</span>&lt;条件测试&gt;,&lt;异常附加数据&gt;<span class="comment">#其中异常附加数据是可选的</span></span><br></pre></td></tr></table></figure>
<p><strong>5.try-finally:异常处理</strong></p>
<p>   1.无论try语句中是否抛出异常，finally中的语句一定会被执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   f = open(<span class="string">"/tmp/output"</span>, <span class="string">"w"</span>)</span><br><span class="line">   f.write(<span class="string">"hello"</span>)</span><br><span class="line">   <span class="comment">#raise Exception("something wrong")</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">   print(<span class="string">"closing file"</span>)</span><br><span class="line">   f.close()</span><br></pre></td></tr></table></figure>
<p>​    不论try中写文件的过程中是否有异常，finally中关闭文件的操作一定会执行。由于finally的这个特性，finally经常被用来做    一些清理工作。</p>
<p>   2.try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">print(func1())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">a</span><br><span class="line">A</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​    再例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'b'</span>)</span><br><span class="line">            <span class="keyword">raise</span> IOError<span class="comment">#指定引发异常</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            print(<span class="string">'B'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            print(<span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    print(func1())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">运行结果为：</span><br><span class="line">b</span><br><span class="line">X</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>​    try中抛出的异常是IOError类型的，而except中定位的是IndexError类型的，try中抛出的异常没有被捕获到，所以except中    的语句没有被执行，但不论异常有没有被捕获，finally还是会执行，最终函数返回了finally中的返回值3。</p>
<p>​    这里还可以看到另外一个问题。try中抛出的异常没有被捕获到，按理说当finally执行完毕后，应该被再次抛出，但finally里    执行了return，导致异常被丢失。<br>​    可以看到在finally中使用return会导致很多问题。实际应用中，不推荐在finally中使用return返回。</p>
<p><strong>6.def函数中的一些问题</strong></p>
<p>1.返回值问题：</p>
<p>返回个数：(不涉及*args和**kwargs参数)</p>
<p>​    0：返回None</p>
<p>​    1：返回object</p>
<p>​    =&gt;2：返回tuple</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>2.形参与实参问题：</p>
<p>问题1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; &gt; &gt; &gt; &gt; &gt; <span class="function"><span class="keyword">def</span> <span class="title">text1</span><span class="params">(x,y)</span>:</span></span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt;  print(x,y)</span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt; print(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&gt; &gt; &gt; &gt; &gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>输出结果为：1,2<br>如果这样赋值：text1(y=1,x=2)#与形参顺序无关<br>则输出结果为：2,1<br>即如果你不指定赋值，它会默认与形参一一对应<br>你也可以 text1(1,y=2)，但不可以text1(x=1,2)或text1(y=1,2).</p>
<p>问题2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2</span><span class="params">(x,y=<span class="number">2</span>)</span>:</span></span><br><span class="line">    print(x,y)</span><br></pre></td></tr></table></figure>
<p>你可以给形参赋个初值<br>你就可以这样调用text2(1),输出结果为：1,2<br>因为你给y形参已赋初值，如果你调用时未给y赋值，它会默认y=2<br>如果你这样调用 text2(1,3),则输出结果为：1,3.</p>
<p>问题3：</p>
<p>问题1与问题2都是传参个数必须与形参个数相等<br>接下来写一种个数不用相等的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#*args:把N个位置参数转化为元组的形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text3</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">text3(<span class="number">1</span>)</span><br><span class="line">text3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#或text3(*[1,2,3])</span></span><br><span class="line"><span class="comment">#则结果分别为：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)		<span class="comment">#以元组(tuple)的方式返回.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text4</span><span class="params">(x,*args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">text4(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">#则运行结果为：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>另一种方式：#**kwargs:把N个关键字参数转化为字典的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text5</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">text5(name=<span class="string">'Lihua'</span>,age=<span class="number">18</span>,sex=<span class="string">'M'</span>)</span><br><span class="line"><span class="comment">#运行结果为：</span></span><br><span class="line">&#123;<span class="string">'name'</span>:<span class="string">'Lihua'</span>,<span class="string">'age'</span>=<span class="number">18</span>,<span class="string">'sex'</span>=<span class="string">'M'</span>&#125;<span class="comment">#以字典的形式返回</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：args和kwargs都必须放在最后</strong></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2019蓝桥杯国赛C++B组</title>
    <url>/2019/05/27/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E8%B5%9BC-B%E7%BB%84/</url>
    <content><![CDATA[<p>​    比赛结束的第二天，坐标HPU，此次的蓝桥杯国赛其实收获挺多的，也是第一次来北京，还是借着公费的理由进行的旅游，哈哈哈，北京三日游很奈斯，本以为会混个国优，空手而归呢，第二天上午官网一查成绩，震惊，还混了个国三，哈哈哈，心想就做出来两个填空题，还能国三，可想蓝桥杯多水了，都说蓝桥杯是暴力杯，啊啊啊，我竟然没想到暴力，不然可能就国二了，甚至国一(国特做梦可以想想)，本来一道编程大题，可以暴力打表多混点分呢，时间都浪费在了某坑爹的用dfs跑的填空题上了 ，一直调试还是未果(浪费那么多时间做出来还好嘛，然鹅 汗，15分啊 啊啊啊)，心桑啊，不过虽然不是很理想，但对我来说已经很奈斯了.<a id="more"></a></p>
<p>​    昨天在北大体育馆举行的颁奖仪式，不过只颁发特等奖，国一二三也不知道有没有奖品，羡慕国特的华为笔记本和华为手机一部(不羡慕，不嫉妒，直接恨)。印象最深的只记得北大欠我两瓶可乐，记心里啦，进场不让带吃的喝的，安检人员说，你出来如果还有，你就拿，没有的话就不拿，我们不负责保管，然而出来去一看，果然啥都没了，啊啊啊，好气哟.不过颁奖典礼体验挺棒的 ，尤其是北大小姐姐们跳到舞蹈，哈哈哈.  奈斯到爆哦，其他不多说了，北京之旅完美谢幕，再见北京！！！</p>
<p>​    简单说一下题目，每年国赛都是六道，今年十道，大概因为是今年是蓝桥杯十周年吧，具体题目忘了，大致描述一下我会的几题吧</p>
<p>A题： 2019  x y 三个数形成等差数列，问x+y最小值为多少？我觉得这是最水的题了 利用等差数列 两项之差相等就行了代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll n=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//如果怕范围小，可以把n定义大一点</span></span><br><span class="line">        <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i*i<span class="number">-2019</span>*<span class="number">2019</span>==j*j-i*i)</span><br><span class="line">                minn=min(minn,i+j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,minn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B题：2019分成若干个两两不相等的质数和，问有多少种符合的分法？</p>
<p>据说是01背包，不会写 跳过，后续会的话再补</p>
<p>D题：应该是 求谁的约数个数等于100，例如S1=1，S2=2，S4=3，S6=4…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">1000000</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n=k;</span><br><span class="line">		<span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>)	a[s++]=i;</span><br><span class="line">		<span class="comment">//打印每个数的约数进行验证 </span></span><br><span class="line">		<span class="comment">//printf("%d: ",k);</span></span><br><span class="line">		<span class="comment">//	for(int j=0;j&lt;s;j++)</span></span><br><span class="line">		<span class="comment">//	printf("%d ",a[j]);</span></span><br><span class="line">        <span class="comment">//	puts("");</span></span><br><span class="line">		<span class="keyword">if</span>(s==<span class="number">100</span>)</span><br><span class="line">		&#123;	 </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E题：是5*5的方格从左上角出发沿边走然后回到左上角，问有多少种走法，其中步数不能超过12步，并且同一个边不能走两遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> kk,zz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="keyword">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>( xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">6</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">6</span>  &amp;&amp; !vis[xx][yy]  &amp;&amp;  s&lt;=<span class="number">12</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(xx!=<span class="number">0</span>||yy!=<span class="number">0</span>) vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">			s++;</span><br><span class="line">			<span class="keyword">if</span>(xx==<span class="number">0</span> &amp;&amp; yy==<span class="number">0</span>)&#123;</span><br><span class="line">				ans++;</span><br><span class="line"><span class="comment">//				printf("方案 %d:\n",ans); </span></span><br><span class="line"><span class="comment">//				for(int i=0;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					for(int j=0;j&lt;6;j++)</span></span><br><span class="line"><span class="comment">//					&#123;</span></span><br><span class="line"><span class="comment">//						printf("%d ",vis[i][j]);</span></span><br><span class="line"><span class="comment">//					&#125;</span></span><br><span class="line"><span class="comment">//					puts("");</span></span><br><span class="line"><span class="comment">//				 &#125; </span></span><br><span class="line"><span class="comment">//				 puts("");</span></span><br><span class="line">			&#125;</span><br><span class="line">			dfs(xx,yy);</span><br><span class="line">			vis[xx][yy]=<span class="number">0</span>;</span><br><span class="line">			s--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="comment">//freopen("text.txt","w",stdout);</span></span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"总方案数：%d\n"</span>,ans<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待续。。。</p>
]]></content>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否为素数，一些优化方式</title>
    <url>/2019/04/22/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>素数判断是acm及各种比赛中频繁出现的内容，也是最基础的，所以一定要完全掌握，下面就介绍几种常用的素数判断的优化方法。</p>
<p>1.(1)先说最简单的吧，复杂度o(n),也是最容易想到的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;<span class="comment">//如果flag==0则说明n是非素数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>(2)对于一般题目来说往往会超时的，所以可以将其复杂度降至o(sqrt(n))<br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3还有一种更高级优化，可以将其复杂度降至o(sqrt(n)/3),首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；</p>
<p>证明：令x≥1，将大于等于5的自然数表示如下：</p>
<p> ··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···</p>
<p>可以看到，不和6的倍数相邻的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到sqrt(n)中每6个数只判断2个，时间复杂度O(sqrt(n)/3)。</p>
<p>在(2)(3)(4)中，都是一个剪枝的思想，(3)中裁剪了不必要的偶数，(4)中裁剪了不和6</p>
<p>的倍数相邻的数，虽然都没有降低时间复杂度的阶数，但都一定程度上加快了判断的速度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>)</span><br><span class="line">		 flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=n;i+=<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.再说下打表法吧，就是你先开一个bool型数组(int型，也行，不过bool稍微快一点，数组大小须是&lt;=所求最大数的大小)，这个缺点就是数据最大不能超过数组的最大范围(一般在1e8以内) 复杂度o(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dabiao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//先初始化为false，不是素数的标为true</span></span><br><span class="line">    vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j+=i)</span><br><span class="line">				vis[j]=<span class="literal">true</span>;<span class="comment">//素数(除了本身)它的所有倍数即为非素数，然后把他的倍数全标记为true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新手上路不喜勿喷，后续如有发现错误，会及时修正的。</p>
]]></content>
      <tags>
        <tag>判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛13 I题(博弈论)</title>
    <url>/2019/04/13/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-I%E9%A2%98-%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>题目：[<a href="https://ac.nowcoder.com/acm/contest/549/I" target="_blank" rel="noopener">链接</a>]</p>
<p><strong>题目描述</strong>：</p>
<p>小A也听说了取石子这个游戏，也决定和小B一起来玩这个游戏。总共有n堆石子，双方轮流取石子，每次都可以从任意一堆中取走任意数量的石子，但是不可以不取。规定谁先取完所有的石子就获胜。但是小A实在是太想赢了，所以在游戏开始之前，小A有一次机会，可以趁小B不注意的时候选择其中一堆石子拿走其中的k个，当然小A也可以选择不拿石子。小A先手。双方都会选择最优的策略，请问在这样的情况下小A有没有必胜的策略，如果有输出YES，否则就输出NO。<a id="more"></a></p>
<p><strong>输入描述</strong>：</p>
<p>一行两个整数N,K，表示分别有N堆石子以及小A可以拿走的石子个数k。<br>接下来N个整数表示每一堆的石子个数 a[i].</p>
<p><strong>输出描述：</strong></p>
<p>一行一个结果表示小A是否有必胜策略，如果有则输出YES，否则输出NO。</p>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<p><strong>备注：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤N≤1e5，1≤a[i]≤1e5，0≤K≤1e5</span><br></pre></td></tr></table></figure>
<p>经过分析很容易发现此题是Nim游戏，也是经典的博弈论，关于Nim游戏详解[<a href="https://www.cnblogs.com/exponent/articles/2141477.html" target="_blank" rel="noopener">点这里</a>]，对于此题，先不考虑K，将所有的a[i]异或，如果a[i]的异或值非0，则小A有必胜的策略，否则小B有必胜的策略，此题在于怎样处理K，K的意思就是小A可以比小B多操作一次，可以从任意一堆拿走k个，或选择不拿，所以有两种情况，拿或不拿，对于所有a[i]进行遍历，就看这两种情况，哪一种情况异或值是非零，如果出现非零，则小A必胜，遍历结束，仍未出现非零，则小B必胜.</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100003</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum^=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum!=<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum^=a[i];<span class="comment">//例如a[0]^a[1]^a[2]=sum,则a[1]^a[2]=sum^a[0]</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=k)<span class="comment">//判断k能不能拿，能拿的话，是否能出现想要的结果</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum^=(a[i]-k);</span><br><span class="line">			<span class="keyword">if</span>(sum!=<span class="number">0</span>)flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛13 D题(位运算)</title>
    <url>/2019/04/13/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B13-D%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>题目：[<a href="https://ac.nowcoder.com/acm/contest/549/D" target="_blank" rel="noopener">链接</a>]</p>
<p><strong>题目描述：</strong>  </p>
<p>位运算是一个非常重要的东西。而小A最近在学习位运算，小A看到了一道很简单的例题，是说从N个数里面选出N-1个数要让它们或起来的值最大，小A想知道这个答案是多少。你可以帮帮他吗？</p>
<p><strong>输入描述：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN第一行一个整数N表示有N个数接下来一行N个数表示A1,A2...AN</span><br></pre></td></tr></table></figure>
<p><strong>输出描述：</strong><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行输出个结果代表最大值一行输出个结果代表最大值</span><br></pre></td></tr></table></figure>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 8 16</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择2,4,8,16或的和是最大的，没有比这个更大的方案。</span><br><span class="line"></span><br><span class="line">1≤N≤5e6，1≤Ai≤longlong</span><br></pre></td></tr></table></figure>
<p>第一次看到题，直接上去sort排序，从第二个开始或运算和(贼尴尬啊)，肯定秒WA啊，原来没想象的那么水哇，这题恶心就恶心到n个数就让你或运算n-1个(或运算n个就多好)，后来通过大神室友的指点，略懂一二，我试着解释解释吧，或运算 1|1=1，1|0=1,0|0=0，此题就是每个数值位1，0之间的或运算(<strong>最下面有后续</strong>)</p>
<p>此题思路就是，将每数位1的个数记录下来</p>
<p>比如 n个数每个位上的1的总个数为 </p>
<p>4  2  5  1  3  1</p>
<p>对a[i]进行遍历，</p>
<p>例如a[0]=5转化为二进制</p>
<p>0  0  0  1  0  1</p>
<p>对应位上减掉1的个数</p>
<p>则变成</p>
<p>4  2  5  0  3  0</p>
<p>则此时最大值即是</p>
<p>1  1  1  0  1  0 (即是各位置剩余1的个数&gt;=1 即对应的值为1)此时的十进制为2^5+2^4+2^3+2^1 将此时的最大值保存下来</p>
<p>然后继续对a[i]重复进行上面的操作，每次保存下来最大值</p>
<p>遍历结束</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll a[<span class="number">500003</span>];</span><br><span class="line"><span class="keyword">int</span> bits[<span class="number">64</span>],c[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	ll maxx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)<span class="comment">//题上范围long long 最大2^63-1，所以定义64，也可以先求出a[i]的最大值，来获得最高位</span></span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">				bits[j]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));<span class="comment">//c数组用来存放当前最大或值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(bits[j]<span class="number">-1</span>&gt;=<span class="number">1</span>) </span><br><span class="line">					c[j]=<span class="number">1</span>;	</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(bits[j]&gt;=<span class="number">1</span>) 	</span><br><span class="line">					c[j]=<span class="number">1</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">		ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">64</span>;x++)</span><br><span class="line">			sum+=c[x]*<span class="built_in">pow</span>(<span class="number">2</span>,x);</span><br><span class="line">		maxx=max(maxx,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后续补充：</strong></p>
<p>无意中看到大佬利用前缀和与后缀和求的，思路比这个清晰，简单(还是自己太菜，当时没想到)，下面就简单分享下思路，</p>
<p>先用一个数组保存下所有的或前缀和，再用另一个数组保存所有的或后缀和，然后保存前缀和与后缀和或的最大值即可 ，</p>
<p>pre[i] | suf[i+2]，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll a[<span class="number">500003</span>];</span><br><span class="line">ll pre[<span class="number">500003</span>],suf[<span class="number">500003</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	ll maxx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">	<span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="keyword">sizeof</span>(suf));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">		pre[i]=pre[i<span class="number">-1</span>]|a[i];<span class="comment">//求或的前缀和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		suf[i]=suf[i+<span class="number">1</span>]|a[i];<span class="comment">//求或的后缀和</span></span><br><span class="line">	maxx=suf[<span class="number">2</span>];<span class="comment">//先把第一个元素不取的或的和赋值给maxx</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">		maxx=max(maxx,pre[i]|suf[i+<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//由题意知取n-1个元素，所以每次取前缀和然后隔一个元素的后缀和的或值，然后最大值保存在maxx中</span></span><br><span class="line">	maxx=max(maxx,pre[n<span class="number">-1</span>]);<span class="comment">//pre[n-1]即是最后一个元素不取的或值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>阶乘(factorial) 牛客小白月赛5</title>
    <url>/2019/04/12/%E9%98%B6%E4%B9%98-factorial-%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B5/</url>
    <content><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/135/D?&amp;headNav=www" target="_blank" rel="noopener">阶乘(factorial)</a></p>
<p><strong>问题描述：</strong>   1! 2! 3! …n! 阶乘相乘的末尾零的个数</p>
<p><strong>输入描述：</strong></p>
<p>输入数据共一行，一个正整数n，意义如“问题描述”。<br><strong>输出描述：</strong><a id="more"></a></p>
<p>输出一行描述答案：</p>
<p>一个正整数k，表示S的末尾有k个0</p>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>对于100%的数据，1&lt;=n&lt;=1e8</p>
<p>题目让求阶乘最后有几个0，即为该表达式的最后结果含有10的几次方的因子，直接求的话，不太好求 不妨转化一下思路，容易发现10的几次方都有一个通性：质因子只有2和5，</p>
<p>显然，阶乘中 质因子2的个数比5多。所以这个题可以转换为 求 因子5的个数，5的个数即是所求末尾0的个数，那么此题就迎刃而解了</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll t = i;</span><br><span class="line">        <span class="keyword">while</span>(t%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1285(拓扑排序模板)</title>
    <url>/2019/04/12/HDU-1285-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">HDU1285</a></p>
<p>Problem Description</p>
<p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p>
<p>Input<a id="more"></a></p>
<p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p>
<p>Output</p>
<p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<p><code>Sample Output</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure>
<p>此题就是拓扑排序的模板题，关系中不能出现环,跑一边模板即可,既然没有环，那肯定有入度为零的点，</p>
<p>1.首先找到入度为零的点，然后将他的所有出边减掉，</p>
<p>2.然后在找下一个入度为零的点，同样将其所有的出边减掉，直到遍历完所有的点。</p>
<p>注意每找到一个入度为零的点就把它输出来，当然也可以保存到数组里，等遍历完所有点，再输出也行，要注意行末空格的处理</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">503</span>][<span class="number">503</span>],vis[<span class="number">503</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuopu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]==<span class="number">0</span>)<span class="comment">//寻找入度为0的点</span></span><br><span class="line">			&#123;</span><br><span class="line">				res=j;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">if</span>(ans==<span class="number">1</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,res);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,res);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[res]=<span class="number">-1</span>;<span class="comment">//等于-1说明已被访问过了</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[res][k]==<span class="number">1</span>)vis[k]--;<span class="comment">//将入度为0的点它的出边剪掉</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,u,v;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">			<span class="keyword">if</span>(pre[u][v]==<span class="number">0</span>)<span class="comment">//防止出现重边 </span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[u][v]=<span class="number">1</span>;</span><br><span class="line">				vis[v]++;<span class="comment">//记录点V的入度个数</span></span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		tuopu(n);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1962-洛谷-斐波那契数列</title>
    <url>/2019/04/12/P1962-%E6%B4%9B%E8%B0%B7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>题目：<a href="https://www.luogu.org/problemnew/show/P1962" target="_blank" rel="noopener">P1962</a></p>
<p><strong>题目背景</strong></p>
<p>大家都知道，斐波那契数列是满足如下性质的一个数列：</p>
<p>• f(1) = 1 ， f(2) = 1 ， f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数)</p>
<p><strong>输入格式：</strong> 第 1 行：一个整数 n<a id="more"></a></p>
<p><strong>输出格式：</strong> 第 1 行： f(n) mod 1000000007 的值</p>
<p>输入样例#1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>输出样例#1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>输入样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>输出样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure>
<p>说明<br> 对于 60% 的数据： n ≤ 92<br> 对于 100% 的数据： n在long long(INT64)范围内<br> ​</p>
<p>根据数据范围这个题用打表或递归方法显然是超时的，所以就用到了矩阵快速幂，这一题难点就在于怎样构造矩阵，关于矩阵快速幂可以参考上篇博客<a href="https://prestu.github.io/2019/04/11/%E6%B4%9B%E8%B0%B7P3390-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" target="_blank" rel="noopener">矩阵快速幂纯模板</a>这次主要讲述怎样构造矩阵，</p>
<p>对于 f(n)=f(n-1)+f(n-2)…这道题目的关键之处在于构造初始矩阵，矩阵快速幂是核心所在。</p>
<p>如何构造：<a href="https://blog.csdn.net/FlushHip/article/details/80068888" target="_blank" rel="noopener">各种构造方法点此处</a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span>&#123;</span></span><br><span class="line">	ll a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">st <span class="title">Martrix</span><span class="params">(st x,st y)</span></span>&#123;</span><br><span class="line">	st ans;</span><br><span class="line">	<span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.a));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">st <span class="title">fast_power</span><span class="params">(st s,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) res.a[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> res.a[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=Martrix(res,s);</span><br><span class="line">		s=Martrix(s,s);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	st s;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)<span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(s.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(s.a));</span><br><span class="line">		s.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;s.a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;s.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		s=fast_power(s,n<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(s.a[<span class="number">0</span>][<span class="number">0</span>]+s.a[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>斐波那契</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3390(矩阵快速幂)</title>
    <url>/2019/04/11/%E6%B4%9B%E8%B0%B7P3390-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目：<a href="https://www.luogu.org/problemnew/show/P3390" target="_blank" rel="noopener">P3390</a></p>
<p>题目描述：给定n*n的矩阵A，求A^k</p>
<p><strong>输入格式：</strong>第一行，n,k第2至n+1行，每行n个数，第i+1行第j个数表示矩阵第i行第j列的元素</p>
<a id="more"></a>
<p><strong>输出格式：</strong>输出A^k共n行，每行n个数，第i行第j个数表示矩阵第i行第j列的元素，每个元素模10^9+7</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p>快速矩阵模板题，直接套用模板即可</p>
<p>矩阵乘法不懂的同学<a href="https://wenku.baidu.com/view/e3842cc42cc58bd63186bdeb.html" target="_blank" rel="noopener">点这里</a></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll  a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">Matrix</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node s;</span><br><span class="line">	<span class="built_in">memset</span>(s.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(s.a));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;n;z++)</span><br><span class="line">				s.a[i][j]=(s.a[i][j]+x.a[i][z]*y.a[z][j])%mod;<span class="comment">//矩阵乘法计算</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">fast_power</span><span class="params">(node x,ll k)</span><span class="comment">//快速幂运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node res;</span><br><span class="line">	<span class="built_in">memset</span>(res.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(i==j) res.a[i][j]=<span class="number">1</span>;<span class="comment">//res为单位矩阵</span></span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)	res=Matrix(res,x);</span><br><span class="line">		x=Matrix(x,x);</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll k;</span><br><span class="line">	node pre;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pre.a[i][j]);</span><br><span class="line">	pre=fast_power(pre,k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,pre.a[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pre.a[i][n<span class="number">-1</span>]);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1094(拓扑排序)</title>
    <url>/2019/04/11/poj-1094-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：<a href="http://poj.org/problem?id=1094" target="_blank" rel="noopener">POJ1094</a></p>
<p>大致题意就是多组输入，输入n，m（可以视为n个点，有m个关系）m个关系在字母A-Z范围内，给你一些关系比如A&lt;B，就认为A到B之间有条有向路，可以分三种情况：</p>
<p>1.当出现了一组关系使图出现了环，则输出“Inconsistency found after K1 relations”  其中的K1就是在第几个关系出现了环，后面的关系就可以忽略不处理了<a id="more"></a></p>
<p>2.当还未输入完给的关系就确定了，n个点的关系，则后面的关系就不用处理了，直接输出“Sorted sequence determined after K2 relations: （点关系的顺序）.” K2是此时确定关系的点的个数；</p>
<p>3.当输入完给的关系，还未确定n个点的关系，则输出“Sorted sequence cannot be determined.”</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">300</span>][<span class="number">300</span>];<span class="comment">//存放村庄之间的关系 1即相通（单向）0即无路</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1000</span>],b[<span class="number">1000</span>],c[<span class="number">1000</span>];<span class="comment">//vis记录通向该点的关系数（即入度）c[]存放确定关系的点</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tuopu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rem,FLAG=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		b[i]=vis[i];</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">0</span>;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				res++;</span><br><span class="line">				rem=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;<span class="number">1</span>) <span class="comment">//说明多个入度为零的点 即n个点的顺序不确定</span></span><br><span class="line">		&#123;</span><br><span class="line">			FLAG=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//无入度为零的点 即出现环</span></span><br><span class="line">		b[rem]=<span class="number">-1</span>;<span class="comment">//把找到的入度为零的点 标记为-1 表示访问过了</span></span><br><span class="line">		c[g++]=rem;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">			<span class="keyword">if</span>(pre[rem][k])	b[k]--;	<span class="comment">//把入度为零的点 它的出边去掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FLAG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;(n+m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">			<span class="keyword">if</span>(ans) <span class="keyword">continue</span>;<span class="comment">//ans 如果是1 则说明已经出结果了，下面的关系就不用处理了。直接跳过即可</span></span><br><span class="line">			<span class="keyword">if</span>(pre[a[<span class="number">0</span>]-<span class="string">'A'</span>][a[<span class="number">2</span>]-<span class="string">'A'</span>]==<span class="number">0</span>)<span class="comment">//防止重边</span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[a[<span class="number">0</span>]-<span class="string">'A'</span>][a[<span class="number">2</span>]-<span class="string">'A'</span>]=<span class="number">1</span>;</span><br><span class="line">				vis[a[<span class="number">2</span>]-<span class="string">'A'</span>]++;<span class="comment">//记录 a[2]点的入度个数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> s=tuopu();</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="number">-2</span>)<span class="comment">//即出现环了</span></span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>,i+<span class="number">1</span>);<span class="comment">//即输出第几个关系出现了环</span></span><br><span class="line">				ans=<span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>,i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%c"</span>,c[i]+<span class="string">'A'</span>);</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line">				ans=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ans)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2631 树的直径</title>
    <url>/2019/03/31/Poj2631-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>题目：<a href="http://poj.org/problem?id=2631" target="_blank" rel="noopener">POJ2631</a></p>
<p>题意：    大致就是村庄之间修路，从一个村庄到另一个村庄只有一条路，而不经过其他一些村庄两次。有若干村庄和道路，其中任何村庄都可以通过公路从任何其他村庄到达。就是让找出该地区两个最偏远村庄之间的公路距离。这些村庄从1开始编号。</p>
<p>题解：    这个就是求树的直径的模板题，两遍BFS即可，第一遍，从任意一个点遍历，记录最远的那个村庄，然后<a id="more"></a>第二遍从第一遍找到的那个最远村庄为起点进行遍历，这样得到的就是两个最偏远地区的距离，即树的直径，本来想用邻接矩阵(浪费空间)存图，题目提到有多达1万条路，所以我选择了邻接表存数据。如果是初学者话，估计这个邻接表不太好理解，我尽可能用通俗的语言让大家理解</p>
<p>AC代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w,next;<span class="comment">//u,v是两个村庄；w是u,v两个村庄的距离;next 是记录此条路上一次存表的编号</span></span><br><span class="line">&#125;edge[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">10001</span>]；<span class="comment">//vis是遍历时记录该条路是否被访问</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">10001</span>]；<span class="comment">//d是记录最远距离，遍历过程中不断更新</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">10001</span>];<span class="comment">//head是记录每条路的头结点</span></span><br><span class="line"><span class="keyword">int</span> cnt,j,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><span class="comment">//邻接表的创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].u=u;</span><br><span class="line">	edge[cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];<span class="comment">//next指向上一次该路存表的编号，</span></span><br><span class="line">	head[u]=cnt++;<span class="comment">//将该条路的编号赋值给head</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">	que.push(x);</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> xx=que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[xx];i!=<span class="number">-1</span>;i=edge[i].next)<span class="comment">//遍历与xx相连的所有村庄，i=-1即与xx相连的村庄遍历完了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> vv=edge[i].v;</span><br><span class="line">			<span class="keyword">if</span>(!vis[vv]&amp;&amp;d[vv]&lt;d[xx]+edge[i].w)<span class="comment">//不断维护最远距离</span></span><br><span class="line">			&#123;</span><br><span class="line">				vis[vv]=<span class="number">1</span>;</span><br><span class="line">				d[vv]=d[xx]+edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(d[vv]&gt;ans)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=d[vv];<span class="comment">//ans是记录最远距离</span></span><br><span class="line">					j=vv;<span class="comment">//j是记录最偏远的村庄编号</span></span><br><span class="line">				&#125;</span><br><span class="line">				que.push(vv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w))</span><br><span class="line">	&#123;</span><br><span class="line">		add(u,v,w);add(v,u,w);<span class="comment">//因为路是双向的，这也是可以用两遍BFS的原因</span></span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	bfs(j);<span class="comment">//j是第一遍BFS找到的最远村庄的编号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>邻接表</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1232畅通工程（并查集)</title>
    <url>/2019/03/27/HDU1232%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86)/</url>
    <content><![CDATA[<p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">HDU1232</a></p>
<p>题意：    某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br>Input<br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后</p>
<a id="more"></a>
<p>的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。<br>Output<br>对每个测试用例，在1行里输出最少还需要建设的道路数目。<br>Sample Input<br>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0<br>Sample Output<br>1<br>0<br>2<br>998</p>
<p>这是并查集的模板题，直接套模板即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pre[x]==x?x:pre[x]=find(pre[x]);<span class="comment">//利用递归将所有他的子节点指向父节点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//将两个集合连接成一个集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx=find(x),yy=find(y);<span class="comment">//xx是x的父节点，yy是y的父节点</span></span><br><span class="line">	<span class="keyword">if</span>(xx!=yy)<span class="comment">//如果x，y的父节点不是同一个，则将他们的父节点相连，使他们成为一个集合</span></span><br><span class="line">    &#123;		</span><br><span class="line">		<span class="keyword">if</span>(yy&lt;xx)</span><br><span class="line">			pre[xx]=yy;<span class="comment">//为了方便，将编号小的视为父节点</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pre[yy]=xx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,s,a,b;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;n)&#123;</span><br><span class="line">		s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			pre[i]=i;<span class="comment">//初始化，先将所有的点指向本身，即先让每一个点都是孤立的点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			Union(a,b);<span class="comment">//让a和b连通</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[i]==i)<span class="comment">//有几个指向本身的点，就有几个集合，</span></span><br><span class="line">			s++;<span class="comment">//s是集合个数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s<span class="number">-1</span>);<span class="comment">//要想让所有的集合连成一个集合，则最少需要 s-1边（例如有两个集合，则变成一个集合只需一条边即可）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>2019蓝桥杯-E题:迷宫</title>
    <url>/2019/03/25/%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<p>试题 E: 迷宫<br>本题总分：15 分<br>【问题描述】<br>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可<br>以通行的地方。<br>010000<br>000100<br>001001<br>110000<br>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这</p>
<a id="more"></a>
<p>个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可</p>
<p>以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别</p>
<p>表示向下、向上、向左、向右走。对于下面这个更复杂的迷宫（30 行 50 列），</p>
<p>请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，</p>
<p>请找出字典序最小的一个作为答案。请注意在字典序中D&lt;L&lt;R&lt;U。</p>
<p>01010101001011001001010110010110100100001000101010<br>00001000100000101010010000100000001001100110100101<br>01111011010010001000001101001011100011000000010000<br>01000000001010100011010000101000001010101011001011<br>00011111000000101000010010100010100000101100000000<br>11001000110101000010101100011010011010101011110111<br>00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010<br>00111000001010100001100010000001000101001100001001<br>11000110100001110010001001010101010101010001101000<br>00010000100100000101001010101110100010101010000101<br>11100100101001001000010000010101010100100100010100<br>00000010000000101011001111010001100000101010100011<br>10101010011100001000011000010110011110110100001000<br>10101010100001101010100101000010100000111011101001<br>10000000101100010000101100101101001011100000000100<br>10101001000000010100100001000100000100011110101001<br>00101001010101101001010100011010101101110000110101<br>11001010000100001100000010100101000001000111000010<br>00001000110000110101101000000100101001001000011101<br>10100101000101000000001110110010110101101010100001<br>00101000010000110101010000100010001001000100010101<br>10100001000110010001000010101001010101011111010010<br>00000100101000000110010100101001000001000000000010<br>11010000001001110111001001000011101001011011101000<br>00000110100010001000100000001000011101000000110011<br>10101000101000100010001111100010101001010000001000<br>10000010100101001010110000000100101010001011101000<br>00111100001000010000000110111000000001000000001011<br>10000001100111010111010001000110111010101101111000<br>【答案提交】<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一<br>个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填<br>写多余的内容将无法得分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//D&lt;L&lt;R&lt;U,这样初始化,为了保证输出的路径是最小字典序 </span></span><br><span class="line"><span class="keyword">int</span> ans[MAXN][MAXN];<span class="comment">//记录是否被访问 </span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN],path[MAXN][MAXN];<span class="comment">//dis记录步数 ，数组path记录路径</span></span><br><span class="line"><span class="keyword">char</span> a[MAXN][MAXN];<span class="comment">//数组a是存迷宫</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	st s,ss;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">	<span class="built_in">queue</span>&lt;st&gt;que;</span><br><span class="line">	ans[x][y]=<span class="number">1</span>;</span><br><span class="line">	s.x=x; s.y=y;</span><br><span class="line">	que.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		s=que.front();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> xx=s.x+dx[i];</span><br><span class="line">			<span class="keyword">int</span> yy=s.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;m&amp;&amp;ans[xx][yy]==<span class="number">0</span>&amp;&amp;a[xx][yy]==<span class="string">'0'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[xx][yy]=dis[s.x][s.y]+<span class="number">1</span>;<span class="comment">//记录步数 </span></span><br><span class="line">				path[xx][yy]=i+<span class="number">1</span>;<span class="comment">//记录上一步从哪过来的 </span></span><br><span class="line">				ans[xx][yy]=<span class="number">1</span>;</span><br><span class="line">				ss.x=xx,ss.y=yy;</span><br><span class="line">				que.push(ss);</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">		que.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[n<span class="number">-1</span>][m<span class="number">-1</span>]);<span class="comment">//输出z走到终点a[n-1][m-1]的最少步数 (题上没要求) </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y)</span><span class="comment">//利用递归输出路径 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">		print(x<span class="number">-1</span>,y);<span class="built_in">cout</span>&lt;&lt;<span class="string">"D"</span>; <span class="comment">//等于1，即上一步向下走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">2</span>)&#123;</span><br><span class="line">		print(x,y+<span class="number">1</span>);<span class="built_in">cout</span>&lt;&lt;<span class="string">"L"</span>;<span class="comment">//等于2，即上一步向左走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">		print(x,y<span class="number">-1</span>);<span class="built_in">cout</span>&lt;&lt;<span class="string">"R"</span>;<span class="comment">//等于3，即上一步向右走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(path[x][y]==<span class="number">4</span>)&#123;</span><br><span class="line">		print(x+<span class="number">1</span>,y);<span class="built_in">cout</span>&lt;&lt;<span class="string">"U"</span>;<span class="comment">//等于4，即上一步向上走一步得到的 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]); </span><br><span class="line">	bfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	print(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最短步数为：186</span><br><span class="line">DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>bfs</tag>
        <tag>记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/03/15/hello-world/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">welcome to my blog!</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
